// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_base.proto

#include "steammessages_base.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgIPAddress::CMsgIPAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ip_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CMsgIPAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgIPAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgIPAddressDefaultTypeInternal() {}
  union {
    CMsgIPAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgIPAddressDefaultTypeInternal _CMsgIPAddress_default_instance_;
PROTOBUF_CONSTEXPR CMsgIPAddressBucket::CMsgIPAddressBucket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.original_ip_address_)*/nullptr
  , /*decltype(_impl_.bucket_)*/uint64_t{0u}} {}
struct CMsgIPAddressBucketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgIPAddressBucketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgIPAddressBucketDefaultTypeInternal() {}
  union {
    CMsgIPAddressBucket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgIPAddressBucketDefaultTypeInternal _CMsgIPAddressBucket_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCRoutingProtoBufHeader::CMsgGCRoutingProtoBufHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dst_gcid_queue_)*/uint64_t{0u}
  , /*decltype(_impl_.dst_gc_dir_index_)*/0u} {}
struct CMsgGCRoutingProtoBufHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCRoutingProtoBufHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCRoutingProtoBufHeaderDefaultTypeInternal() {}
  union {
    CMsgGCRoutingProtoBufHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCRoutingProtoBufHeaderDefaultTypeInternal _CMsgGCRoutingProtoBufHeader_default_instance_;
PROTOBUF_CONSTEXPR CMsgProtoBufHeader::CMsgProtoBufHeader(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.forward_to_sysid_)*/{}
  , /*decltype(_impl_.target_job_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.error_message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.debug_source_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.wg_token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.webui_auth_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.routing_gc_)*/nullptr
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.client_sessionid_)*/0
  , /*decltype(_impl_.routing_appid_)*/0u
  , /*decltype(_impl_.auth_account_flags_)*/0u
  , /*decltype(_impl_.publisher_group_id_)*/0u
  , /*decltype(_impl_.trace_tag_)*/uint64_t{0u}
  , /*decltype(_impl_.sysid_)*/0u
  , /*decltype(_impl_.token_source_)*/0u
  , /*decltype(_impl_.seq_num_)*/0
  , /*decltype(_impl_.admin_spoofing_user_)*/false
  , /*decltype(_impl_.is_from_external_source_)*/false
  , /*decltype(_impl_.webapi_key_id_)*/0u
  , /*decltype(_impl_.cm_sysid_)*/0u
  , /*decltype(_impl_.launcher_type_)*/0u
  , /*decltype(_impl_.realm_)*/0u
  , /*decltype(_impl_.token_id_)*/uint64_t{0u}
  , /*decltype(_impl_.debug_source_string_index_)*/0u
  , /*decltype(_impl_.session_disposition_)*/0
  , /*decltype(_impl_.timeout_ms_)*/-1
  , /*decltype(_impl_.jobid_source_)*/uint64_t{18446744073709551615u}
  , /*decltype(_impl_.jobid_target_)*/uint64_t{18446744073709551615u}
  , /*decltype(_impl_.eresult_)*/2
  , /*decltype(_impl_.transport_error_)*/1
  , /*decltype(_impl_.messageid_)*/uint64_t{18446744073709551615u}
  , /*decltype(_impl_.ip_addr_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct CMsgProtoBufHeaderDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgProtoBufHeaderDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgProtoBufHeaderDefaultTypeInternal() {}
  union {
    CMsgProtoBufHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgProtoBufHeaderDefaultTypeInternal _CMsgProtoBufHeader_default_instance_;
PROTOBUF_CONSTEXPR CMsgMulti::CMsgMulti(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.size_unzipped_)*/0u} {}
struct CMsgMultiDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgMultiDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgMultiDefaultTypeInternal() {}
  union {
    CMsgMulti _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgMultiDefaultTypeInternal _CMsgMulti_default_instance_;
PROTOBUF_CONSTEXPR CMsgProtobufWrapped::CMsgProtobufWrapped(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.message_body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgProtobufWrappedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgProtobufWrappedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgProtobufWrappedDefaultTypeInternal() {}
  union {
    CMsgProtobufWrapped _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgProtobufWrappedDefaultTypeInternal _CMsgProtobufWrapped_default_instance_;
PROTOBUF_CONSTEXPR CMsgAuthTicket::CMsgAuthTicket(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ticket_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_secret_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.estate_)*/0u
  , /*decltype(_impl_.h_steam_pipe_)*/0u
  , /*decltype(_impl_.gameid_)*/uint64_t{0u}
  , /*decltype(_impl_.ticket_crc_)*/0u
  , /*decltype(_impl_.ticket_type_)*/0u
  , /*decltype(_impl_.eresult_)*/2u} {}
struct CMsgAuthTicketDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAuthTicketDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAuthTicketDefaultTypeInternal() {}
  union {
    CMsgAuthTicket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAuthTicketDefaultTypeInternal _CMsgAuthTicket_default_instance_;
PROTOBUF_CONSTEXPR CCDDBAppDetailCommon::CCDDBAppDetailCommon(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.content_descriptorids_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.icon_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.friendly_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.propagation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.tool_)*/false
  , /*decltype(_impl_.demo_)*/false
  , /*decltype(_impl_.media_)*/false
  , /*decltype(_impl_.community_visible_stats_)*/false
  , /*decltype(_impl_.app_type_)*/0u
  , /*decltype(_impl_.has_adult_content_)*/false
  , /*decltype(_impl_.is_visible_in_steam_china_)*/false
  , /*decltype(_impl_.has_adult_content_sex_)*/false
  , /*decltype(_impl_.has_adult_content_violence_)*/false} {}
struct CCDDBAppDetailCommonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCDDBAppDetailCommonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCDDBAppDetailCommonDefaultTypeInternal() {}
  union {
    CCDDBAppDetailCommon _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCDDBAppDetailCommonDefaultTypeInternal _CCDDBAppDetailCommon_default_instance_;
PROTOBUF_CONSTEXPR CMsgAppRights::CMsgAppRights(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.edit_info_)*/false
  , /*decltype(_impl_.publish_)*/false
  , /*decltype(_impl_.view_error_data_)*/false
  , /*decltype(_impl_.download_)*/false
  , /*decltype(_impl_.upload_cdkeys_)*/false
  , /*decltype(_impl_.generate_cdkeys_)*/false
  , /*decltype(_impl_.view_financials_)*/false
  , /*decltype(_impl_.manage_ceg_)*/false
  , /*decltype(_impl_.manage_signing_)*/false
  , /*decltype(_impl_.manage_cdkeys_)*/false
  , /*decltype(_impl_.edit_marketing_)*/false
  , /*decltype(_impl_.economy_support_)*/false
  , /*decltype(_impl_.economy_support_supervisor_)*/false
  , /*decltype(_impl_.manage_pricing_)*/false
  , /*decltype(_impl_.broadcast_live_)*/false
  , /*decltype(_impl_.view_marketing_traffic_)*/false
  , /*decltype(_impl_.edit_store_display_content_)*/false} {}
struct CMsgAppRightsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgAppRightsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgAppRightsDefaultTypeInternal() {}
  union {
    CMsgAppRights _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgAppRightsDefaultTypeInternal _CMsgAppRights_default_instance_;
PROTOBUF_CONSTEXPR CCuratorPreferences::CCuratorPreferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tagids_curated_)*/{}
  , /*decltype(_impl_.tagids_filtered_)*/{}
  , /*decltype(_impl_.website_title_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.website_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.discussion_url_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.supported_languages_)*/0u
  , /*decltype(_impl_.platform_windows_)*/false
  , /*decltype(_impl_.platform_mac_)*/false
  , /*decltype(_impl_.platform_linux_)*/false
  , /*decltype(_impl_.vr_content_)*/false
  , /*decltype(_impl_.timestamp_updated_)*/0u
  , /*decltype(_impl_.adult_content_violence_)*/false
  , /*decltype(_impl_.adult_content_sex_)*/false
  , /*decltype(_impl_.show_broadcast_)*/false} {}
struct CCuratorPreferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCuratorPreferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCuratorPreferencesDefaultTypeInternal() {}
  union {
    CCuratorPreferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCuratorPreferencesDefaultTypeInternal _CCuratorPreferences_default_instance_;
PROTOBUF_CONSTEXPR CLocalizationToken::CLocalizationToken(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.localized_string_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/0u} {}
struct CLocalizationTokenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CLocalizationTokenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CLocalizationTokenDefaultTypeInternal() {}
  union {
    CLocalizationToken _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CLocalizationTokenDefaultTypeInternal _CLocalizationToken_default_instance_;
PROTOBUF_CONSTEXPR CClanEventUserNewsTuple::CClanEventUserNewsTuple(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.event_gid_)*/uint64_t{0u}
  , /*decltype(_impl_.clanid_)*/0u
  , /*decltype(_impl_.rtime_start_)*/0u
  , /*decltype(_impl_.announcement_gid_)*/uint64_t{0u}
  , /*decltype(_impl_.rtime_end_)*/0u
  , /*decltype(_impl_.priority_score_)*/0u
  , /*decltype(_impl_.type_)*/0u
  , /*decltype(_impl_.clamp_range_slot_)*/0u
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.rtime32_last_modified_)*/0u} {}
struct CClanEventUserNewsTupleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CClanEventUserNewsTupleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CClanEventUserNewsTupleDefaultTypeInternal() {}
  union {
    CClanEventUserNewsTuple _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CClanEventUserNewsTupleDefaultTypeInternal _CClanEventUserNewsTuple_default_instance_;
PROTOBUF_CONSTEXPR CClanMatchEventByRange::CClanMatchEventByRange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.events_)*/{}
  , /*decltype(_impl_.rtime_before_)*/0u
  , /*decltype(_impl_.rtime_after_)*/0u
  , /*decltype(_impl_.qualified_)*/0u} {}
struct CClanMatchEventByRangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CClanMatchEventByRangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CClanMatchEventByRangeDefaultTypeInternal() {}
  union {
    CClanMatchEventByRange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CClanMatchEventByRangeDefaultTypeInternal _CClanMatchEventByRange_default_instance_;
PROTOBUF_CONSTEXPR CCommunity_ClanAnnouncementInfo::CCommunity_ClanAnnouncementInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tags_)*/{}
  , /*decltype(_impl_.headline_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.body_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gid_)*/uint64_t{0u}
  , /*decltype(_impl_.clanid_)*/uint64_t{0u}
  , /*decltype(_impl_.posterid_)*/uint64_t{0u}
  , /*decltype(_impl_.posttime_)*/0u
  , /*decltype(_impl_.updatetime_)*/0u
  , /*decltype(_impl_.commentcount_)*/0
  , /*decltype(_impl_.language_)*/0
  , /*decltype(_impl_.forum_topic_id_)*/uint64_t{0u}
  , /*decltype(_impl_.event_gid_)*/uint64_t{0u}
  , /*decltype(_impl_.voteupcount_)*/0
  , /*decltype(_impl_.hidden_)*/false
  , /*decltype(_impl_.banned_)*/false
  , /*decltype(_impl_.votedowncount_)*/0
  , /*decltype(_impl_.ban_check_result_)*/0} {}
struct CCommunity_ClanAnnouncementInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCommunity_ClanAnnouncementInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCommunity_ClanAnnouncementInfoDefaultTypeInternal() {}
  union {
    CCommunity_ClanAnnouncementInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCommunity_ClanAnnouncementInfoDefaultTypeInternal _CCommunity_ClanAnnouncementInfo_default_instance_;
PROTOBUF_CONSTEXPR CClanEventData::CClanEventData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.referenced_appids_)*/{}
  , /*decltype(_impl_.event_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.server_password_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.event_notes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.jsondata_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.build_branch_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.announcement_body_)*/nullptr
  , /*decltype(_impl_.gid_)*/uint64_t{0u}
  , /*decltype(_impl_.clan_steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.appid_)*/0u
  , /*decltype(_impl_.rtime32_start_time_)*/0u
  , /*decltype(_impl_.rtime32_end_time_)*/0u
  , /*decltype(_impl_.comment_count_)*/0
  , /*decltype(_impl_.creator_steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.last_update_steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.published_)*/false
  , /*decltype(_impl_.hidden_)*/false
  , /*decltype(_impl_.rtime32_visibility_start_)*/0u
  , /*decltype(_impl_.rtime32_visibility_end_)*/0u
  , /*decltype(_impl_.broadcaster_accountid_)*/0u
  , /*decltype(_impl_.follower_count_)*/0u
  , /*decltype(_impl_.ignore_count_)*/0u
  , /*decltype(_impl_.forum_topic_id_)*/uint64_t{0u}
  , /*decltype(_impl_.news_post_gid_)*/uint64_t{0u}
  , /*decltype(_impl_.rtime32_last_modified_)*/0u
  , /*decltype(_impl_.rtime_mod_reviewed_)*/0u
  , /*decltype(_impl_.featured_app_tagid_)*/0u
  , /*decltype(_impl_.build_id_)*/0u
  , /*decltype(_impl_.event_type_)*/1} {}
struct CClanEventDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CClanEventDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CClanEventDataDefaultTypeInternal() {}
  union {
    CClanEventData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CClanEventDataDefaultTypeInternal _CClanEventData_default_instance_;
PROTOBUF_CONSTEXPR CBilling_Address::CBilling_Address(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.first_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.last_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address1_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address2_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.city_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.us_state_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.postcode_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.phone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.zip_plus4_)*/0} {}
struct CBilling_AddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBilling_AddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBilling_AddressDefaultTypeInternal() {}
  union {
    CBilling_Address _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBilling_AddressDefaultTypeInternal _CBilling_Address_default_instance_;
PROTOBUF_CONSTEXPR CPackageReservationStatus::CPackageReservationStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.reservation_country_code_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.packageid_)*/0u
  , /*decltype(_impl_.reservation_state_)*/0
  , /*decltype(_impl_.queue_position_)*/0
  , /*decltype(_impl_.total_queue_size_)*/0
  , /*decltype(_impl_.expired_)*/false
  , /*decltype(_impl_.time_expires_)*/0u
  , /*decltype(_impl_.time_reserved_)*/0u} {}
struct CPackageReservationStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CPackageReservationStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CPackageReservationStatusDefaultTypeInternal() {}
  union {
    CPackageReservationStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPackageReservationStatusDefaultTypeInternal _CPackageReservationStatus_default_instance_;
PROTOBUF_CONSTEXPR CMsgKeyValuePair::CMsgKeyValuePair(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CMsgKeyValuePairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgKeyValuePairDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgKeyValuePairDefaultTypeInternal() {}
  union {
    CMsgKeyValuePair _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgKeyValuePairDefaultTypeInternal _CMsgKeyValuePair_default_instance_;
PROTOBUF_CONSTEXPR CMsgKeyValueSet::CMsgKeyValueSet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.pairs_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgKeyValueSetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgKeyValueSetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgKeyValueSetDefaultTypeInternal() {}
  union {
    CMsgKeyValueSet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgKeyValueSetDefaultTypeInternal _CMsgKeyValueSet_default_instance_;
PROTOBUF_CONSTEXPR UserContentDescriptorPreferences_ContentDescriptor::UserContentDescriptorPreferences_ContentDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.content_descriptorid_)*/0u
  , /*decltype(_impl_.timestamp_added_)*/0u} {}
struct UserContentDescriptorPreferences_ContentDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserContentDescriptorPreferences_ContentDescriptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserContentDescriptorPreferences_ContentDescriptorDefaultTypeInternal() {}
  union {
    UserContentDescriptorPreferences_ContentDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserContentDescriptorPreferences_ContentDescriptorDefaultTypeInternal _UserContentDescriptorPreferences_ContentDescriptor_default_instance_;
PROTOBUF_CONSTEXPR UserContentDescriptorPreferences::UserContentDescriptorPreferences(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.content_descriptors_to_exclude_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserContentDescriptorPreferencesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserContentDescriptorPreferencesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserContentDescriptorPreferencesDefaultTypeInternal() {}
  union {
    UserContentDescriptorPreferences _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserContentDescriptorPreferencesDefaultTypeInternal _UserContentDescriptorPreferences_default_instance_;
static ::_pb::Metadata file_level_metadata_steammessages_5fbase_2eproto[21];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_steammessages_5fbase_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_steammessages_5fbase_2eproto = nullptr;

const uint32_t TableStruct_steammessages_5fbase_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddress, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddress, _impl_.ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddressBucket, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddressBucket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddressBucket, _impl_.original_ip_address_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPAddressBucket, _impl_.bucket_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgGCRoutingProtoBufHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRoutingProtoBufHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCRoutingProtoBufHeader, _impl_.dst_gcid_queue_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCRoutingProtoBufHeader, _impl_.dst_gc_dir_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.client_sessionid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.routing_appid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.jobid_source_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.jobid_target_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.target_job_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.seq_num_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.eresult_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.error_message_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.auth_account_flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.token_source_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.admin_spoofing_user_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.transport_error_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.messageid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.publisher_group_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.sysid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.trace_tag_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.webapi_key_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.is_from_external_source_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.forward_to_sysid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.cm_sysid_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.launcher_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.realm_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.timeout_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.debug_source_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.debug_source_string_index_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.token_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.routing_gc_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.session_disposition_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.wg_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.webui_auth_key_),
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::CMsgProtoBufHeader, _impl_.ip_addr_),
  6,
  7,
  8,
  25,
  26,
  0,
  14,
  27,
  1,
  9,
  13,
  15,
  28,
  29,
  10,
  12,
  11,
  17,
  16,
  ~0u,
  18,
  19,
  20,
  24,
  2,
  22,
  21,
  5,
  23,
  3,
  4,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgMulti, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMulti, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMulti, _impl_.size_unzipped_),
  PROTOBUF_FIELD_OFFSET(::CMsgMulti, _impl_.message_body_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgProtobufWrapped, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgProtobufWrapped, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgProtobufWrapped, _impl_.message_body_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.estate_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.eresult_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.gameid_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.h_steam_pipe_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.ticket_crc_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.ticket_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.server_secret_),
  PROTOBUF_FIELD_OFFSET(::CMsgAuthTicket, _impl_.ticket_type_),
  3,
  8,
  2,
  5,
  4,
  6,
  0,
  1,
  7,
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.icon_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.tool_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.demo_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.media_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.community_visible_stats_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.friendly_name_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.propagation_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.has_adult_content_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.is_visible_in_steam_china_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.app_type_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.has_adult_content_sex_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.has_adult_content_violence_),
  PROTOBUF_FIELD_OFFSET(::CCDDBAppDetailCommon, _impl_.content_descriptorids_),
  4,
  0,
  1,
  5,
  6,
  7,
  8,
  2,
  3,
  10,
  11,
  9,
  12,
  13,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.edit_info_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.publish_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.view_error_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.download_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.upload_cdkeys_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.generate_cdkeys_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.view_financials_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.manage_ceg_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.manage_signing_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.manage_cdkeys_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.edit_marketing_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.economy_support_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.economy_support_supervisor_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.manage_pricing_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.broadcast_live_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.view_marketing_traffic_),
  PROTOBUF_FIELD_OFFSET(::CMsgAppRights, _impl_.edit_store_display_content_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.supported_languages_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.platform_windows_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.platform_mac_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.platform_linux_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.vr_content_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.adult_content_violence_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.adult_content_sex_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.timestamp_updated_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.tagids_curated_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.tagids_filtered_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.website_title_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.website_url_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.discussion_url_),
  PROTOBUF_FIELD_OFFSET(::CCuratorPreferences, _impl_.show_broadcast_),
  3,
  4,
  5,
  6,
  7,
  9,
  10,
  8,
  ~0u,
  ~0u,
  0,
  1,
  2,
  11,
  PROTOBUF_FIELD_OFFSET(::CLocalizationToken, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CLocalizationToken, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CLocalizationToken, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CLocalizationToken, _impl_.localized_string_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.clanid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.event_gid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.announcement_gid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.rtime_start_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.rtime_end_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.priority_score_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.clamp_range_slot_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventUserNewsTuple, _impl_.rtime32_last_modified_),
  1,
  0,
  3,
  2,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CClanMatchEventByRange, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CClanMatchEventByRange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CClanMatchEventByRange, _impl_.rtime_before_),
  PROTOBUF_FIELD_OFFSET(::CClanMatchEventByRange, _impl_.rtime_after_),
  PROTOBUF_FIELD_OFFSET(::CClanMatchEventByRange, _impl_.qualified_),
  PROTOBUF_FIELD_OFFSET(::CClanMatchEventByRange, _impl_.events_),
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.gid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.clanid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.posterid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.headline_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.posttime_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.updatetime_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.body_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.commentcount_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.tags_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.hidden_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.forum_topic_id_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.event_gid_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.voteupcount_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.votedowncount_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.ban_check_result_),
  PROTOBUF_FIELD_OFFSET(::CCommunity_ClanAnnouncementInfo, _impl_.banned_),
  2,
  3,
  4,
  0,
  5,
  6,
  1,
  7,
  ~0u,
  8,
  12,
  9,
  10,
  11,
  14,
  15,
  13,
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.gid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.clan_steamid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.event_name_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.event_type_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.appid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.server_address_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.server_password_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.rtime32_start_time_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.rtime32_end_time_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.comment_count_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.creator_steamid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.last_update_steamid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.event_notes_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.jsondata_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.announcement_body_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.published_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.hidden_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.rtime32_visibility_start_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.rtime32_visibility_end_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.broadcaster_accountid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.follower_count_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.ignore_count_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.forum_topic_id_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.rtime32_last_modified_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.news_post_gid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.rtime_mod_reviewed_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.featured_app_tagid_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.referenced_appids_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.build_id_),
  PROTOBUF_FIELD_OFFSET(::CClanEventData, _impl_.build_branch_),
  7,
  8,
  0,
  28,
  9,
  1,
  2,
  10,
  11,
  12,
  13,
  14,
  3,
  4,
  6,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  24,
  23,
  25,
  26,
  ~0u,
  27,
  5,
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.first_name_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.last_name_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.address1_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.address2_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.city_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.us_state_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.country_code_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.postcode_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.zip_plus4_),
  PROTOBUF_FIELD_OFFSET(::CBilling_Address, _impl_.phone_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  9,
  8,
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.packageid_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.reservation_state_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.queue_position_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.total_queue_size_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.reservation_country_code_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.expired_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.time_expires_),
  PROTOBUF_FIELD_OFFSET(::CPackageReservationStatus, _impl_.time_reserved_),
  1,
  2,
  3,
  4,
  0,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgKeyValuePair, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgKeyValuePair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgKeyValuePair, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CMsgKeyValuePair, _impl_.value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgKeyValueSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgKeyValueSet, _impl_.pairs_),
  PROTOBUF_FIELD_OFFSET(::UserContentDescriptorPreferences_ContentDescriptor, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::UserContentDescriptorPreferences_ContentDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UserContentDescriptorPreferences_ContentDescriptor, _impl_.content_descriptorid_),
  PROTOBUF_FIELD_OFFSET(::UserContentDescriptorPreferences_ContentDescriptor, _impl_.timestamp_added_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::UserContentDescriptorPreferences, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UserContentDescriptorPreferences, _impl_.content_descriptors_to_exclude_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::CMsgIPAddress)},
  { 9, 17, -1, sizeof(::CMsgIPAddressBucket)},
  { 19, 27, -1, sizeof(::CMsgGCRoutingProtoBufHeader)},
  { 29, 69, -1, sizeof(::CMsgProtoBufHeader)},
  { 102, 110, -1, sizeof(::CMsgMulti)},
  { 112, 119, -1, sizeof(::CMsgProtobufWrapped)},
  { 120, 135, -1, sizeof(::CMsgAuthTicket)},
  { 144, 165, -1, sizeof(::CCDDBAppDetailCommon)},
  { 180, 203, -1, sizeof(::CMsgAppRights)},
  { 220, 240, -1, sizeof(::CCuratorPreferences)},
  { 254, 262, -1, sizeof(::CLocalizationToken)},
  { 264, 280, -1, sizeof(::CClanEventUserNewsTuple)},
  { 290, 300, -1, sizeof(::CClanMatchEventByRange)},
  { 304, 327, -1, sizeof(::CCommunity_ClanAnnouncementInfo)},
  { 344, 380, -1, sizeof(::CClanEventData)},
  { 410, 426, -1, sizeof(::CBilling_Address)},
  { 436, 450, -1, sizeof(::CPackageReservationStatus)},
  { 458, 466, -1, sizeof(::CMsgKeyValuePair)},
  { 468, -1, -1, sizeof(::CMsgKeyValueSet)},
  { 475, 483, -1, sizeof(::UserContentDescriptorPreferences_ContentDescriptor)},
  { 485, -1, -1, sizeof(::UserContentDescriptorPreferences)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgIPAddress_default_instance_._instance,
  &::_CMsgIPAddressBucket_default_instance_._instance,
  &::_CMsgGCRoutingProtoBufHeader_default_instance_._instance,
  &::_CMsgProtoBufHeader_default_instance_._instance,
  &::_CMsgMulti_default_instance_._instance,
  &::_CMsgProtobufWrapped_default_instance_._instance,
  &::_CMsgAuthTicket_default_instance_._instance,
  &::_CCDDBAppDetailCommon_default_instance_._instance,
  &::_CMsgAppRights_default_instance_._instance,
  &::_CCuratorPreferences_default_instance_._instance,
  &::_CLocalizationToken_default_instance_._instance,
  &::_CClanEventUserNewsTuple_default_instance_._instance,
  &::_CClanMatchEventByRange_default_instance_._instance,
  &::_CCommunity_ClanAnnouncementInfo_default_instance_._instance,
  &::_CClanEventData_default_instance_._instance,
  &::_CBilling_Address_default_instance_._instance,
  &::_CPackageReservationStatus_default_instance_._instance,
  &::_CMsgKeyValuePair_default_instance_._instance,
  &::_CMsgKeyValueSet_default_instance_._instance,
  &::_UserContentDescriptorPreferences_ContentDescriptor_default_instance_._instance,
  &::_UserContentDescriptorPreferences_default_instance_._instance,
};

const char descriptor_table_protodef_steammessages_5fbase_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030steammessages_base.proto\032 google/proto"
  "buf/descriptor.proto\"1\n\rCMsgIPAddress\022\014\n"
  "\002v4\030\001 \001(\007H\000\022\014\n\002v6\030\002 \001(\014H\000B\004\n\002ip\"R\n\023CMsgI"
  "PAddressBucket\022+\n\023original_ip_address\030\001 "
  "\001(\0132\016.CMsgIPAddress\022\016\n\006bucket\030\002 \001(\006\"O\n\033C"
  "MsgGCRoutingProtoBufHeader\022\026\n\016dst_gcid_q"
  "ueue\030\001 \001(\004\022\030\n\020dst_gc_dir_index\030\002 \001(\r\"\216\010\n"
  "\022CMsgProtoBufHeader\022\017\n\007steamid\030\001 \001(\006\022\030\n\020"
  "client_sessionid\030\002 \001(\005\022\025\n\rrouting_appid\030"
  "\003 \001(\r\022*\n\014jobid_source\030\n \001(\006:\02418446744073"
  "709551615\022*\n\014jobid_target\030\013 \001(\006:\0241844674"
  "4073709551615\022\027\n\017target_job_name\030\014 \001(\t\022\017"
  "\n\007seq_num\030\030 \001(\005\022\022\n\007eresult\030\r \001(\005:\0012\022\025\n\re"
  "rror_message\030\016 \001(\t\022\032\n\022auth_account_flags"
  "\030\020 \001(\r\022\024\n\014token_source\030\026 \001(\r\022\033\n\023admin_sp"
  "oofing_user\030\027 \001(\010\022\032\n\017transport_error\030\021 \001"
  "(\005:\0011\022\'\n\tmessageid\030\022 \001(\004:\02418446744073709"
  "551615\022\032\n\022publisher_group_id\030\023 \001(\r\022\r\n\005sy"
  "sid\030\024 \001(\r\022\021\n\ttrace_tag\030\025 \001(\004\022\025\n\rwebapi_k"
  "ey_id\030\031 \001(\r\022\037\n\027is_from_external_source\030\032"
  " \001(\010\022\030\n\020forward_to_sysid\030\033 \003(\r\022\020\n\010cm_sys"
  "id\030\034 \001(\r\022\030\n\rlauncher_type\030\037 \001(\r:\0010\022\020\n\005re"
  "alm\030  \001(\r:\0010\022\026\n\ntimeout_ms\030! \001(\005:\002-1\022\024\n\014"
  "debug_source\030\" \001(\t\022!\n\031debug_source_strin"
  "g_index\030# \001(\r\022\020\n\010token_id\030$ \001(\004\0220\n\nrouti"
  "ng_gc\030% \001(\0132\034.CMsgGCRoutingProtoBufHeade"
  "r\022a\n\023session_disposition\030& \001(\0162\'.CMsgPro"
  "toBufHeader.ESessionDisposition:\033k_ESess"
  "ionDispositionNormal\022\020\n\010wg_token\030\' \001(\t\022\026"
  "\n\016webui_auth_key\030( \001(\t\022\014\n\002ip\030\017 \001(\rH\000\022\017\n\005"
  "ip_v6\030\035 \001(\014H\000\"[\n\023ESessionDisposition\022\037\n\033"
  "k_ESessionDispositionNormal\020\000\022#\n\037k_ESess"
  "ionDispositionDisconnect\020\001B\t\n\007ip_addr\"8\n"
  "\tCMsgMulti\022\025\n\rsize_unzipped\030\001 \001(\r\022\024\n\014mes"
  "sage_body\030\002 \001(\014\"+\n\023CMsgProtobufWrapped\022\024"
  "\n\014message_body\030\001 \001(\014\"\273\001\n\016CMsgAuthTicket\022"
  "\016\n\006estate\030\001 \001(\r\022\022\n\007eresult\030\002 \001(\r:\0012\022\017\n\007s"
  "teamid\030\003 \001(\006\022\016\n\006gameid\030\004 \001(\006\022\024\n\014h_steam_"
  "pipe\030\005 \001(\r\022\022\n\nticket_crc\030\006 \001(\r\022\016\n\006ticket"
  "\030\007 \001(\014\022\025\n\rserver_secret\030\010 \001(\014\022\023\n\013ticket_"
  "type\030\t \001(\r\"\353\002\n\024CCDDBAppDetailCommon\022\r\n\005a"
  "ppid\030\001 \001(\r\022\014\n\004name\030\002 \001(\t\022\014\n\004icon\030\003 \001(\t\022\014"
  "\n\004tool\030\006 \001(\010\022\014\n\004demo\030\007 \001(\010\022\r\n\005media\030\010 \001("
  "\010\022\037\n\027community_visible_stats\030\t \001(\010\022\025\n\rfr"
  "iendly_name\030\n \001(\t\022\023\n\013propagation\030\013 \001(\t\022\031"
  "\n\021has_adult_content\030\014 \001(\010\022!\n\031is_visible_"
  "in_steam_china\030\r \001(\010\022\020\n\010app_type\030\016 \001(\r\022\035"
  "\n\025has_adult_content_sex\030\017 \001(\010\022\"\n\032has_adu"
  "lt_content_violence\030\020 \001(\010\022\035\n\025content_des"
  "criptorids\030\021 \003(\r\"\263\003\n\rCMsgAppRights\022\021\n\ted"
  "it_info\030\001 \001(\010\022\017\n\007publish\030\002 \001(\010\022\027\n\017view_e"
  "rror_data\030\003 \001(\010\022\020\n\010download\030\004 \001(\010\022\025\n\rupl"
  "oad_cdkeys\030\005 \001(\010\022\027\n\017generate_cdkeys\030\006 \001("
  "\010\022\027\n\017view_financials\030\007 \001(\010\022\022\n\nmanage_ceg"
  "\030\010 \001(\010\022\026\n\016manage_signing\030\t \001(\010\022\025\n\rmanage"
  "_cdkeys\030\n \001(\010\022\026\n\016edit_marketing\030\013 \001(\010\022\027\n"
  "\017economy_support\030\014 \001(\010\022\"\n\032economy_suppor"
  "t_supervisor\030\r \001(\010\022\026\n\016manage_pricing\030\016 \001"
  "(\010\022\026\n\016broadcast_live\030\017 \001(\010\022\036\n\026view_marke"
  "ting_traffic\030\020 \001(\010\022\"\n\032edit_store_display"
  "_content\030\021 \001(\010\"\361\002\n\023CCuratorPreferences\022\033"
  "\n\023supported_languages\030\001 \001(\r\022\030\n\020platform_"
  "windows\030\002 \001(\010\022\024\n\014platform_mac\030\003 \001(\010\022\026\n\016p"
  "latform_linux\030\004 \001(\010\022\022\n\nvr_content\030\005 \001(\010\022"
  "\036\n\026adult_content_violence\030\006 \001(\010\022\031\n\021adult"
  "_content_sex\030\007 \001(\010\022\031\n\021timestamp_updated\030"
  "\010 \001(\r\022\026\n\016tagids_curated\030\t \003(\r\022\027\n\017tagids_"
  "filtered\030\n \003(\r\022\025\n\rwebsite_title\030\013 \001(\t\022\023\n"
  "\013website_url\030\014 \001(\t\022\026\n\016discussion_url\030\r \001"
  "(\t\022\026\n\016show_broadcast\030\016 \001(\010\"@\n\022CLocalizat"
  "ionToken\022\020\n\010language\030\001 \001(\r\022\030\n\020localized_"
  "string\030\002 \001(\t\"\354\001\n\027CClanEventUserNewsTuple"
  "\022\016\n\006clanid\030\001 \001(\r\022\021\n\tevent_gid\030\002 \001(\006\022\030\n\020a"
  "nnouncement_gid\030\003 \001(\006\022\023\n\013rtime_start\030\004 \001"
  "(\r\022\021\n\trtime_end\030\005 \001(\r\022\026\n\016priority_score\030"
  "\006 \001(\r\022\014\n\004type\030\007 \001(\r\022\030\n\020clamp_range_slot\030"
  "\010 \001(\r\022\r\n\005appid\030\t \001(\r\022\035\n\025rtime32_last_mod"
  "ified\030\n \001(\r\"\200\001\n\026CClanMatchEventByRange\022\024"
  "\n\014rtime_before\030\001 \001(\r\022\023\n\013rtime_after\030\002 \001("
  "\r\022\021\n\tqualified\030\003 \001(\r\022(\n\006events\030\004 \003(\0132\030.C"
  "ClanEventUserNewsTuple\"\233\003\n\037CCommunity_Cl"
  "anAnnouncementInfo\022\013\n\003gid\030\001 \001(\004\022\016\n\006clani"
  "d\030\002 \001(\004\022\020\n\010posterid\030\003 \001(\004\022\020\n\010headline\030\004 "
  "\001(\t\022\020\n\010posttime\030\005 \001(\r\022\022\n\nupdatetime\030\006 \001("
  "\r\022\014\n\004body\030\007 \001(\t\022\024\n\014commentcount\030\010 \001(\005\022\014\n"
  "\004tags\030\t \003(\t\022\020\n\010language\030\n \001(\005\022\016\n\006hidden\030"
  "\013 \001(\010\022\026\n\016forum_topic_id\030\014 \001(\006\022\021\n\tevent_g"
  "id\030\r \001(\006\022\023\n\013voteupcount\030\016 \001(\005\022\025\n\rvotedow"
  "ncount\030\017 \001(\005\022V\n\020ban_check_result\030\020 \001(\0162\027"
  ".EBanContentCheckResult:#k_EBanContentCh"
  "eckResult_NotScanned\022\016\n\006banned\030\021 \001(\010\"\246\006\n"
  "\016CClanEventData\022\013\n\003gid\030\001 \001(\006\022\024\n\014clan_ste"
  "amid\030\002 \001(\006\022\022\n\nevent_name\030\003 \001(\t\022;\n\nevent_"
  "type\030\004 \001(\0162\024.EProtoClanEventType:\021k_ECla"
  "nOtherEvent\022\r\n\005appid\030\005 \001(\r\022\026\n\016server_add"
  "ress\030\006 \001(\t\022\027\n\017server_password\030\007 \001(\t\022\032\n\022r"
  "time32_start_time\030\010 \001(\r\022\030\n\020rtime32_end_t"
  "ime\030\t \001(\r\022\025\n\rcomment_count\030\n \001(\005\022\027\n\017crea"
  "tor_steamid\030\013 \001(\006\022\033\n\023last_update_steamid"
  "\030\014 \001(\006\022\023\n\013event_notes\030\r \001(\t\022\020\n\010jsondata\030"
  "\016 \001(\t\022;\n\021announcement_body\030\017 \001(\0132 .CComm"
  "unity_ClanAnnouncementInfo\022\021\n\tpublished\030"
  "\020 \001(\010\022\016\n\006hidden\030\021 \001(\010\022 \n\030rtime32_visibil"
  "ity_start\030\022 \001(\r\022\036\n\026rtime32_visibility_en"
  "d\030\023 \001(\r\022\035\n\025broadcaster_accountid\030\024 \001(\r\022\026"
  "\n\016follower_count\030\025 \001(\r\022\024\n\014ignore_count\030\026"
  " \001(\r\022\026\n\016forum_topic_id\030\027 \001(\006\022\035\n\025rtime32_"
  "last_modified\030\030 \001(\r\022\025\n\rnews_post_gid\030\031 \001"
  "(\006\022\032\n\022rtime_mod_reviewed\030\032 \001(\r\022\032\n\022featur"
  "ed_app_tagid\030\033 \001(\r\022\031\n\021referenced_appids\030"
  "\034 \003(\r\022\020\n\010build_id\030\035 \001(\r\022\024\n\014build_branch\030"
  "\036 \001(\t\"\307\001\n\020CBilling_Address\022\022\n\nfirst_name"
  "\030\001 \001(\t\022\021\n\tlast_name\030\002 \001(\t\022\020\n\010address1\030\003 "
  "\001(\t\022\020\n\010address2\030\004 \001(\t\022\014\n\004city\030\005 \001(\t\022\020\n\010u"
  "s_state\030\006 \001(\t\022\024\n\014country_code\030\007 \001(\t\022\020\n\010p"
  "ostcode\030\010 \001(\t\022\021\n\tzip_plus4\030\t \001(\005\022\r\n\005phon"
  "e\030\n \001(\t\"\333\001\n\031CPackageReservationStatus\022\021\n"
  "\tpackageid\030\001 \001(\r\022\031\n\021reservation_state\030\002 "
  "\001(\005\022\026\n\016queue_position\030\003 \001(\005\022\030\n\020total_que"
  "ue_size\030\004 \001(\005\022 \n\030reservation_country_cod"
  "e\030\005 \001(\t\022\017\n\007expired\030\006 \001(\010\022\024\n\014time_expires"
  "\030\007 \001(\r\022\025\n\rtime_reserved\030\010 \001(\r\"/\n\020CMsgKey"
  "ValuePair\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"3"
  "\n\017CMsgKeyValueSet\022 \n\005pairs\030\001 \003(\0132\021.CMsgK"
  "eyValuePair\"\313\001\n UserContentDescriptorPre"
  "ferences\022[\n\036content_descriptors_to_exclu"
  "de\030\001 \003(\01323.UserContentDescriptorPreferen"
  "ces.ContentDescriptor\032J\n\021ContentDescript"
  "or\022\034\n\024content_descriptorid\030\001 \001(\r\022\027\n\017time"
  "stamp_added\030\002 \001(\r*\330\002\n\026EBanContentCheckRe"
  "sult\022\'\n#k_EBanContentCheckResult_NotScan"
  "ned\020\000\022\"\n\036k_EBanContentCheckResult_Reset\020"
  "\001\022*\n&k_EBanContentCheckResult_NeedsCheck"
  "ing\020\002\022)\n%k_EBanContentCheckResult_VeryUn"
  "likely\020\005\022%\n!k_EBanContentCheckResult_Unl"
  "ikely\020\036\022%\n!k_EBanContentCheckResult_Poss"
  "ible\0202\022#\n\037k_EBanContentCheckResult_Likel"
  "y\020K\022\'\n#k_EBanContentCheckResult_VeryLike"
  "ly\020d*\353\007\n\023EProtoClanEventType\022\025\n\021k_EClanO"
  "therEvent\020\001\022\024\n\020k_EClanGameEvent\020\002\022\025\n\021k_E"
  "ClanPartyEvent\020\003\022\027\n\023k_EClanMeetingEvent\020"
  "\004\022\034\n\030k_EClanSpecialCauseEvent\020\005\022\034\n\030k_ECl"
  "anMusicAndArtsEvent\020\006\022\026\n\022k_EClanSportsEv"
  "ent\020\007\022\024\n\020k_EClanTripEvent\020\010\022\024\n\020k_EClanCh"
  "atEvent\020\t\022\033\n\027k_EClanGameReleaseEvent\020\n\022\031"
  "\n\025k_EClanBroadcastEvent\020\013\022\033\n\027k_EClanSmal"
  "lUpdateEvent\020\014\022&\n\"k_EClanPreAnnounceMajo"
  "rUpdateEvent\020\r\022\033\n\027k_EClanMajorUpdateEven"
  "t\020\016\022\032\n\026k_EClanDLCReleaseEvent\020\017\022\035\n\031k_ECl"
  "anFutureReleaseEvent\020\020\022&\n\"k_EClanESportT"
  "ournamentStreamEvent\020\021\022\031\n\025k_EClanDevStre"
  "amEvent\020\022\022\034\n\030k_EClanFamousStreamEvent\020\023\022"
  "\031\n\025k_EClanGameSalesEvent\020\024\022\035\n\031k_EClanGam"
  "eItemSalesEvent\020\025\022\035\n\031k_EClanInGameBonusX"
  "PEvent\020\026\022\032\n\026k_EClanInGameLootEvent\020\027\022\033\n\027"
  "k_EClanInGamePerksEvent\020\030\022\037\n\033k_EClanInGa"
  "meChallengeEvent\020\031\022\035\n\031k_EClanInGameConte"
  "stEvent\020\032\022\023\n\017k_EClanIRLEvent\020\033\022\024\n\020k_ECla"
  "nNewsEvent\020\034\022\033\n\027k_EClanBetaReleaseEvent\020"
  "\035\022$\n k_EClanInGameContentReleaseEvent\020\036\022"
  "\024\n\020k_EClanFreeTrial\020\037\022\030\n\024k_EClanSeasonRe"
  "lease\020 \022\027\n\023k_EClanSeasonUpdate\020!\022\031\n\025k_EC"
  "lanCrosspostEvent\020\"\022\035\n\031k_EClanInGameEven"
  "tGeneral\020#*\201\001\n\034PartnerEventNotificationT"
  "ype\022\021\n\rk_EEventStart\020\000\022\032\n\026k_EEventBroadc"
  "astStart\020\001\022\026\n\022k_EEventMatchStart\020\002\022\032\n\026k_"
  "EEventPartnerMaxType\020\003:A\n\022msgpool_soft_l"
  "imit\022\037.google.protobuf.MessageOptions\030\320\206"
  "\003 \001(\005:\00232:B\n\022msgpool_hard_limit\022\037.google"
  ".protobuf.MessageOptions\030\321\206\003 \001(\005:\003384:C\n"
  "\024force_php_generation\022\034.google.protobuf."
  "FileOptions\030\320\206\003 \001(\010:\005false:H\n\030php_output"
  "_always_number\022\035.google.protobuf.FieldOp"
  "tions\030\344\206\003 \001(\010:\005false:J\n\032allow_field_name"
  "d_steam_id\022\035.google.protobuf.FieldOption"
  "s\030\350\206\003 \001(\010:\005falseB\tH\001\200\001\001\200\265\030\001"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_steammessages_5fbase_2eproto_deps[1] = {
  &::descriptor_table_google_2fprotobuf_2fdescriptor_2eproto,
};
static ::_pbi::once_flag descriptor_table_steammessages_5fbase_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_steammessages_5fbase_2eproto = {
    false, false, 7027, descriptor_table_protodef_steammessages_5fbase_2eproto,
    "steammessages_base.proto",
    &descriptor_table_steammessages_5fbase_2eproto_once, descriptor_table_steammessages_5fbase_2eproto_deps, 1, 21,
    schemas, file_default_instances, TableStruct_steammessages_5fbase_2eproto::offsets,
    file_level_metadata_steammessages_5fbase_2eproto, file_level_enum_descriptors_steammessages_5fbase_2eproto,
    file_level_service_descriptors_steammessages_5fbase_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_steammessages_5fbase_2eproto_getter() {
  return &descriptor_table_steammessages_5fbase_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fbase_2eproto(&descriptor_table_steammessages_5fbase_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgProtoBufHeader_ESessionDisposition_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fbase_2eproto);
  return file_level_enum_descriptors_steammessages_5fbase_2eproto[0];
}
bool CMsgProtoBufHeader_ESessionDisposition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgProtoBufHeader_ESessionDisposition CMsgProtoBufHeader::k_ESessionDispositionNormal;
constexpr CMsgProtoBufHeader_ESessionDisposition CMsgProtoBufHeader::k_ESessionDispositionDisconnect;
constexpr CMsgProtoBufHeader_ESessionDisposition CMsgProtoBufHeader::ESessionDisposition_MIN;
constexpr CMsgProtoBufHeader_ESessionDisposition CMsgProtoBufHeader::ESessionDisposition_MAX;
constexpr int CMsgProtoBufHeader::ESessionDisposition_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBanContentCheckResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fbase_2eproto);
  return file_level_enum_descriptors_steammessages_5fbase_2eproto[1];
}
bool EBanContentCheckResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 5:
    case 30:
    case 50:
    case 75:
    case 100:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProtoClanEventType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fbase_2eproto);
  return file_level_enum_descriptors_steammessages_5fbase_2eproto[2];
}
bool EProtoClanEventType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PartnerEventNotificationType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fbase_2eproto);
  return file_level_enum_descriptors_steammessages_5fbase_2eproto[3];
}
bool PartnerEventNotificationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgIPAddress::_Internal {
 public:
};

CMsgIPAddress::CMsgIPAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgIPAddress)
}
CMsgIPAddress::CMsgIPAddress(const CMsgIPAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgIPAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ip();
  switch (from.ip_case()) {
    case kV4: {
      _this->_internal_set_v4(from._internal_v4());
      break;
    }
    case kV6: {
      _this->_internal_set_v6(from._internal_v6());
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CMsgIPAddress)
}

inline void CMsgIPAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ip_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ip();
}

CMsgIPAddress::~CMsgIPAddress() {
  // @@protoc_insertion_point(destructor:CMsgIPAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgIPAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ip()) {
    clear_ip();
  }
}

void CMsgIPAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgIPAddress::clear_ip() {
// @@protoc_insertion_point(one_of_clear_start:CMsgIPAddress)
  switch (ip_case()) {
    case kV4: {
      // No need to clear
      break;
    }
    case kV6: {
      _impl_.ip_.v6_.Destroy();
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = IP_NOT_SET;
}


void CMsgIPAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgIPAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ip();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgIPAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed32 v4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _internal_set_v4(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // bytes v6 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_v6();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgIPAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgIPAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (ip_case()) {
    case kV4: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_v4(), target);
      break;
    }
    case kV6: {
      target = stream->WriteBytesMaybeAliased(
          2, this->_internal_v6(), target);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgIPAddress)
  return target;
}

size_t CMsgIPAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgIPAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ip_case()) {
    // fixed32 v4 = 1;
    case kV4: {
      total_size += 1 + 4;
      break;
    }
    // bytes v6 = 2;
    case kV6: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_v6());
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgIPAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgIPAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgIPAddress::GetClassData() const { return &_class_data_; }


void CMsgIPAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgIPAddress*>(&to_msg);
  auto& from = static_cast<const CMsgIPAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgIPAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ip_case()) {
    case kV4: {
      _this->_internal_set_v4(from._internal_v4());
      break;
    }
    case kV6: {
      _this->_internal_set_v6(from._internal_v6());
      break;
    }
    case IP_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgIPAddress::CopyFrom(const CMsgIPAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgIPAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgIPAddress::IsInitialized() const {
  return true;
}

void CMsgIPAddress::InternalSwap(CMsgIPAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ip_, other->_impl_.ip_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgIPAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[0]);
}

// ===================================================================

class CMsgIPAddressBucket::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgIPAddressBucket>()._impl_._has_bits_);
  static const ::CMsgIPAddress& original_ip_address(const CMsgIPAddressBucket* msg);
  static void set_has_original_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bucket(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgIPAddress&
CMsgIPAddressBucket::_Internal::original_ip_address(const CMsgIPAddressBucket* msg) {
  return *msg->_impl_.original_ip_address_;
}
CMsgIPAddressBucket::CMsgIPAddressBucket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgIPAddressBucket)
}
CMsgIPAddressBucket::CMsgIPAddressBucket(const CMsgIPAddressBucket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgIPAddressBucket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.original_ip_address_){nullptr}
    , decltype(_impl_.bucket_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_original_ip_address()) {
    _this->_impl_.original_ip_address_ = new ::CMsgIPAddress(*from._impl_.original_ip_address_);
  }
  _this->_impl_.bucket_ = from._impl_.bucket_;
  // @@protoc_insertion_point(copy_constructor:CMsgIPAddressBucket)
}

inline void CMsgIPAddressBucket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.original_ip_address_){nullptr}
    , decltype(_impl_.bucket_){uint64_t{0u}}
  };
}

CMsgIPAddressBucket::~CMsgIPAddressBucket() {
  // @@protoc_insertion_point(destructor:CMsgIPAddressBucket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgIPAddressBucket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.original_ip_address_;
}

void CMsgIPAddressBucket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgIPAddressBucket::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgIPAddressBucket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.original_ip_address_ != nullptr);
    _impl_.original_ip_address_->Clear();
  }
  _impl_.bucket_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgIPAddressBucket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgIPAddress original_ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_original_ip_address(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 bucket = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_bucket(&has_bits);
          _impl_.bucket_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgIPAddressBucket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgIPAddressBucket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgIPAddress original_ip_address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::original_ip_address(this),
        _Internal::original_ip_address(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 bucket = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_bucket(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgIPAddressBucket)
  return target;
}

size_t CMsgIPAddressBucket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgIPAddressBucket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgIPAddress original_ip_address = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.original_ip_address_);
    }

    // optional fixed64 bucket = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgIPAddressBucket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgIPAddressBucket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgIPAddressBucket::GetClassData() const { return &_class_data_; }


void CMsgIPAddressBucket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgIPAddressBucket*>(&to_msg);
  auto& from = static_cast<const CMsgIPAddressBucket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgIPAddressBucket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_original_ip_address()->::CMsgIPAddress::MergeFrom(
          from._internal_original_ip_address());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.bucket_ = from._impl_.bucket_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgIPAddressBucket::CopyFrom(const CMsgIPAddressBucket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgIPAddressBucket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgIPAddressBucket::IsInitialized() const {
  return true;
}

void CMsgIPAddressBucket::InternalSwap(CMsgIPAddressBucket* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgIPAddressBucket, _impl_.bucket_)
      + sizeof(CMsgIPAddressBucket::_impl_.bucket_)
      - PROTOBUF_FIELD_OFFSET(CMsgIPAddressBucket, _impl_.original_ip_address_)>(
          reinterpret_cast<char*>(&_impl_.original_ip_address_),
          reinterpret_cast<char*>(&other->_impl_.original_ip_address_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgIPAddressBucket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[1]);
}

// ===================================================================

class CMsgGCRoutingProtoBufHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCRoutingProtoBufHeader>()._impl_._has_bits_);
  static void set_has_dst_gcid_queue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dst_gc_dir_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgGCRoutingProtoBufHeader::CMsgGCRoutingProtoBufHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCRoutingProtoBufHeader)
}
CMsgGCRoutingProtoBufHeader::CMsgGCRoutingProtoBufHeader(const CMsgGCRoutingProtoBufHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCRoutingProtoBufHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dst_gcid_queue_){}
    , decltype(_impl_.dst_gc_dir_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dst_gcid_queue_, &from._impl_.dst_gcid_queue_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dst_gc_dir_index_) -
    reinterpret_cast<char*>(&_impl_.dst_gcid_queue_)) + sizeof(_impl_.dst_gc_dir_index_));
  // @@protoc_insertion_point(copy_constructor:CMsgGCRoutingProtoBufHeader)
}

inline void CMsgGCRoutingProtoBufHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dst_gcid_queue_){uint64_t{0u}}
    , decltype(_impl_.dst_gc_dir_index_){0u}
  };
}

CMsgGCRoutingProtoBufHeader::~CMsgGCRoutingProtoBufHeader() {
  // @@protoc_insertion_point(destructor:CMsgGCRoutingProtoBufHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCRoutingProtoBufHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgGCRoutingProtoBufHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCRoutingProtoBufHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCRoutingProtoBufHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dst_gcid_queue_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dst_gc_dir_index_) -
        reinterpret_cast<char*>(&_impl_.dst_gcid_queue_)) + sizeof(_impl_.dst_gc_dir_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCRoutingProtoBufHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 dst_gcid_queue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dst_gcid_queue(&has_bits);
          _impl_.dst_gcid_queue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dst_gc_dir_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dst_gc_dir_index(&has_bits);
          _impl_.dst_gc_dir_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCRoutingProtoBufHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCRoutingProtoBufHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 dst_gcid_queue = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_dst_gcid_queue(), target);
  }

  // optional uint32 dst_gc_dir_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_dst_gc_dir_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCRoutingProtoBufHeader)
  return target;
}

size_t CMsgGCRoutingProtoBufHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCRoutingProtoBufHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 dst_gcid_queue = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_dst_gcid_queue());
    }

    // optional uint32 dst_gc_dir_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dst_gc_dir_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCRoutingProtoBufHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCRoutingProtoBufHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCRoutingProtoBufHeader::GetClassData() const { return &_class_data_; }


void CMsgGCRoutingProtoBufHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCRoutingProtoBufHeader*>(&to_msg);
  auto& from = static_cast<const CMsgGCRoutingProtoBufHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCRoutingProtoBufHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dst_gcid_queue_ = from._impl_.dst_gcid_queue_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dst_gc_dir_index_ = from._impl_.dst_gc_dir_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCRoutingProtoBufHeader::CopyFrom(const CMsgGCRoutingProtoBufHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCRoutingProtoBufHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCRoutingProtoBufHeader::IsInitialized() const {
  return true;
}

void CMsgGCRoutingProtoBufHeader::InternalSwap(CMsgGCRoutingProtoBufHeader* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCRoutingProtoBufHeader, _impl_.dst_gc_dir_index_)
      + sizeof(CMsgGCRoutingProtoBufHeader::_impl_.dst_gc_dir_index_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCRoutingProtoBufHeader, _impl_.dst_gcid_queue_)>(
          reinterpret_cast<char*>(&_impl_.dst_gcid_queue_),
          reinterpret_cast<char*>(&other->_impl_.dst_gcid_queue_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCRoutingProtoBufHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[2]);
}

// ===================================================================

class CMsgProtoBufHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgProtoBufHeader>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_routing_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_jobid_source(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_jobid_target(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_target_job_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auth_account_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_token_source(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_admin_spoofing_user(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_transport_error(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_messageid(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_publisher_group_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_sysid(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_trace_tag(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_webapi_key_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_from_external_source(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_cm_sysid(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_launcher_type(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_realm(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_debug_source(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_debug_source_string_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static const ::CMsgGCRoutingProtoBufHeader& routing_gc(const CMsgProtoBufHeader* msg);
  static void set_has_routing_gc(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_session_disposition(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_wg_token(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_webui_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgGCRoutingProtoBufHeader&
CMsgProtoBufHeader::_Internal::routing_gc(const CMsgProtoBufHeader* msg) {
  return *msg->_impl_.routing_gc_;
}
CMsgProtoBufHeader::CMsgProtoBufHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgProtoBufHeader)
}
CMsgProtoBufHeader::CMsgProtoBufHeader(const CMsgProtoBufHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgProtoBufHeader* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.forward_to_sysid_){from._impl_.forward_to_sysid_}
    , decltype(_impl_.target_job_name_){}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.debug_source_){}
    , decltype(_impl_.wg_token_){}
    , decltype(_impl_.webui_auth_key_){}
    , decltype(_impl_.routing_gc_){nullptr}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.client_sessionid_){}
    , decltype(_impl_.routing_appid_){}
    , decltype(_impl_.auth_account_flags_){}
    , decltype(_impl_.publisher_group_id_){}
    , decltype(_impl_.trace_tag_){}
    , decltype(_impl_.sysid_){}
    , decltype(_impl_.token_source_){}
    , decltype(_impl_.seq_num_){}
    , decltype(_impl_.admin_spoofing_user_){}
    , decltype(_impl_.is_from_external_source_){}
    , decltype(_impl_.webapi_key_id_){}
    , decltype(_impl_.cm_sysid_){}
    , decltype(_impl_.launcher_type_){}
    , decltype(_impl_.realm_){}
    , decltype(_impl_.token_id_){}
    , decltype(_impl_.debug_source_string_index_){}
    , decltype(_impl_.session_disposition_){}
    , decltype(_impl_.timeout_ms_){}
    , decltype(_impl_.jobid_source_){}
    , decltype(_impl_.jobid_target_){}
    , decltype(_impl_.eresult_){}
    , decltype(_impl_.transport_error_){}
    , decltype(_impl_.messageid_){}
    , decltype(_impl_.ip_addr_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.target_job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_job_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_target_job_name()) {
    _this->_impl_.target_job_name_.Set(from._internal_target_job_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    _this->_impl_.error_message_.Set(from._internal_error_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.debug_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_debug_source()) {
    _this->_impl_.debug_source_.Set(from._internal_debug_source(), 
      _this->GetArenaForAllocation());
  }
  _impl_.wg_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wg_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_wg_token()) {
    _this->_impl_.wg_token_.Set(from._internal_wg_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.webui_auth_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.webui_auth_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_webui_auth_key()) {
    _this->_impl_.webui_auth_key_.Set(from._internal_webui_auth_key(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_routing_gc()) {
    _this->_impl_.routing_gc_ = new ::CMsgGCRoutingProtoBufHeader(*from._impl_.routing_gc_);
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.messageid_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.messageid_));
  clear_has_ip_addr();
  switch (from.ip_addr_case()) {
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpV6: {
      _this->_internal_set_ip_v6(from._internal_ip_v6());
      break;
    }
    case IP_ADDR_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CMsgProtoBufHeader)
}

inline void CMsgProtoBufHeader::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.forward_to_sysid_){arena}
    , decltype(_impl_.target_job_name_){}
    , decltype(_impl_.error_message_){}
    , decltype(_impl_.debug_source_){}
    , decltype(_impl_.wg_token_){}
    , decltype(_impl_.webui_auth_key_){}
    , decltype(_impl_.routing_gc_){nullptr}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.client_sessionid_){0}
    , decltype(_impl_.routing_appid_){0u}
    , decltype(_impl_.auth_account_flags_){0u}
    , decltype(_impl_.publisher_group_id_){0u}
    , decltype(_impl_.trace_tag_){uint64_t{0u}}
    , decltype(_impl_.sysid_){0u}
    , decltype(_impl_.token_source_){0u}
    , decltype(_impl_.seq_num_){0}
    , decltype(_impl_.admin_spoofing_user_){false}
    , decltype(_impl_.is_from_external_source_){false}
    , decltype(_impl_.webapi_key_id_){0u}
    , decltype(_impl_.cm_sysid_){0u}
    , decltype(_impl_.launcher_type_){0u}
    , decltype(_impl_.realm_){0u}
    , decltype(_impl_.token_id_){uint64_t{0u}}
    , decltype(_impl_.debug_source_string_index_){0u}
    , decltype(_impl_.session_disposition_){0}
    , decltype(_impl_.timeout_ms_){-1}
    , decltype(_impl_.jobid_source_){uint64_t{18446744073709551615u}}
    , decltype(_impl_.jobid_target_){uint64_t{18446744073709551615u}}
    , decltype(_impl_.eresult_){2}
    , decltype(_impl_.transport_error_){1}
    , decltype(_impl_.messageid_){uint64_t{18446744073709551615u}}
    , decltype(_impl_.ip_addr_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  _impl_.target_job_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.target_job_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.debug_source_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.debug_source_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.wg_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.wg_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.webui_auth_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.webui_auth_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  clear_has_ip_addr();
}

CMsgProtoBufHeader::~CMsgProtoBufHeader() {
  // @@protoc_insertion_point(destructor:CMsgProtoBufHeader)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgProtoBufHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.forward_to_sysid_.~RepeatedField();
  _impl_.target_job_name_.Destroy();
  _impl_.error_message_.Destroy();
  _impl_.debug_source_.Destroy();
  _impl_.wg_token_.Destroy();
  _impl_.webui_auth_key_.Destroy();
  if (this != internal_default_instance()) delete _impl_.routing_gc_;
  if (has_ip_addr()) {
    clear_ip_addr();
  }
}

void CMsgProtoBufHeader::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgProtoBufHeader::clear_ip_addr() {
// @@protoc_insertion_point(one_of_clear_start:CMsgProtoBufHeader)
  switch (ip_addr_case()) {
    case kIp: {
      // No need to clear
      break;
    }
    case kIpV6: {
      _impl_.ip_addr_.ip_v6_.Destroy();
      break;
    }
    case IP_ADDR_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = IP_ADDR_NOT_SET;
}


void CMsgProtoBufHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgProtoBufHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.forward_to_sysid_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.target_job_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.debug_source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.wg_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.webui_auth_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.routing_gc_ != nullptr);
      _impl_.routing_gc_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.client_sessionid_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.client_sessionid_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.routing_appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.admin_spoofing_user_) -
        reinterpret_cast<char*>(&_impl_.routing_appid_)) + sizeof(_impl_.admin_spoofing_user_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.is_from_external_source_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.session_disposition_) -
        reinterpret_cast<char*>(&_impl_.is_from_external_source_)) + sizeof(_impl_.session_disposition_));
  }
  if (cached_has_bits & 0x3f000000u) {
    _impl_.timeout_ms_ = -1;
    _impl_.jobid_source_ = uint64_t{18446744073709551615u};
    _impl_.jobid_target_ = uint64_t{18446744073709551615u};
    _impl_.eresult_ = 2;
    _impl_.transport_error_ = 1;
    _impl_.messageid_ = uint64_t{18446744073709551615u};
  }
  clear_ip_addr();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgProtoBufHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client_sessionid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_sessionid(&has_bits);
          _impl_.client_sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 routing_appid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_routing_appid(&has_bits);
          _impl_.routing_appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 jobid_source = 10 [default = 18446744073709551615];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _Internal::set_has_jobid_source(&has_bits);
          _impl_.jobid_source_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 jobid_target = 11 [default = 18446744073709551615];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_jobid_target(&has_bits);
          _impl_.jobid_target_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string target_job_name = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_target_job_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgProtoBufHeader.target_job_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 eresult = 13 [default = 2];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgProtoBufHeader.error_message");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // uint32 ip = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _internal_set_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_account_flags = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_auth_account_flags(&has_bits);
          _impl_.auth_account_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 transport_error = 17 [default = 1];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_transport_error(&has_bits);
          _impl_.transport_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 messageid = 18 [default = 18446744073709551615];
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_messageid(&has_bits);
          _impl_.messageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 publisher_group_id = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_publisher_group_id(&has_bits);
          _impl_.publisher_group_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sysid = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_sysid(&has_bits);
          _impl_.sysid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 trace_tag = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_trace_tag(&has_bits);
          _impl_.trace_tag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 token_source = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_token_source(&has_bits);
          _impl_.token_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool admin_spoofing_user = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_admin_spoofing_user(&has_bits);
          _impl_.admin_spoofing_user_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 seq_num = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_seq_num(&has_bits);
          _impl_.seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 webapi_key_id = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_webapi_key_id(&has_bits);
          _impl_.webapi_key_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_from_external_source = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_is_from_external_source(&has_bits);
          _impl_.is_from_external_source_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 forward_to_sysid = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_forward_to_sysid(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<216>(ptr));
        } else if (static_cast<uint8_t>(tag) == 218) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_forward_to_sysid(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cm_sysid = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_cm_sysid(&has_bits);
          _impl_.cm_sysid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes ip_v6 = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          auto str = _internal_mutable_ip_v6();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 launcher_type = 31 [default = 0];
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_launcher_type(&has_bits);
          _impl_.launcher_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 realm = 32 [default = 0];
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_realm(&has_bits);
          _impl_.realm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 timeout_ms = 33 [default = -1];
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timeout_ms(&has_bits);
          _impl_.timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string debug_source = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_debug_source();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgProtoBufHeader.debug_source");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 debug_source_string_index = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_debug_source_string_index(&has_bits);
          _impl_.debug_source_string_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 token_id = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_token_id(&has_bits);
          _impl_.token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgGCRoutingProtoBufHeader routing_gc = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_routing_gc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgProtoBufHeader.ESessionDisposition session_disposition = 38 [default = k_ESessionDispositionNormal];
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgProtoBufHeader_ESessionDisposition_IsValid(val))) {
            _internal_set_session_disposition(static_cast<::CMsgProtoBufHeader_ESessionDisposition>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(38, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string wg_token = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_wg_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgProtoBufHeader.wg_token");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string webui_auth_key = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_webui_auth_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgProtoBufHeader.webui_auth_key");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgProtoBufHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgProtoBufHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional int32 client_sessionid = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_client_sessionid(), target);
  }

  // optional uint32 routing_appid = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_routing_appid(), target);
  }

  // optional fixed64 jobid_source = 10 [default = 18446744073709551615];
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(10, this->_internal_jobid_source(), target);
  }

  // optional fixed64 jobid_target = 11 [default = 18446744073709551615];
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(11, this->_internal_jobid_target(), target);
  }

  // optional string target_job_name = 12;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_target_job_name().data(), static_cast<int>(this->_internal_target_job_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgProtoBufHeader.target_job_name");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_target_job_name(), target);
  }

  // optional int32 eresult = 13 [default = 2];
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_eresult(), target);
  }

  // optional string error_message = 14;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_message().data(), static_cast<int>(this->_internal_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgProtoBufHeader.error_message");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_error_message(), target);
  }

  // uint32 ip = 15;
  if (_internal_has_ip()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_ip(), target);
  }

  // optional uint32 auth_account_flags = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_auth_account_flags(), target);
  }

  // optional int32 transport_error = 17 [default = 1];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_transport_error(), target);
  }

  // optional uint64 messageid = 18 [default = 18446744073709551615];
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(18, this->_internal_messageid(), target);
  }

  // optional uint32 publisher_group_id = 19;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_publisher_group_id(), target);
  }

  // optional uint32 sysid = 20;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_sysid(), target);
  }

  // optional uint64 trace_tag = 21;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(21, this->_internal_trace_tag(), target);
  }

  // optional uint32 token_source = 22;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_token_source(), target);
  }

  // optional bool admin_spoofing_user = 23;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(23, this->_internal_admin_spoofing_user(), target);
  }

  // optional int32 seq_num = 24;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(24, this->_internal_seq_num(), target);
  }

  // optional uint32 webapi_key_id = 25;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(25, this->_internal_webapi_key_id(), target);
  }

  // optional bool is_from_external_source = 26;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_is_from_external_source(), target);
  }

  // repeated uint32 forward_to_sysid = 27;
  for (int i = 0, n = this->_internal_forward_to_sysid_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_forward_to_sysid(i), target);
  }

  // optional uint32 cm_sysid = 28;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_cm_sysid(), target);
  }

  // bytes ip_v6 = 29;
  if (_internal_has_ip_v6()) {
    target = stream->WriteBytesMaybeAliased(
        29, this->_internal_ip_v6(), target);
  }

  // optional uint32 launcher_type = 31 [default = 0];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(31, this->_internal_launcher_type(), target);
  }

  // optional uint32 realm = 32 [default = 0];
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(32, this->_internal_realm(), target);
  }

  // optional int32 timeout_ms = 33 [default = -1];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(33, this->_internal_timeout_ms(), target);
  }

  // optional string debug_source = 34;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_debug_source().data(), static_cast<int>(this->_internal_debug_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgProtoBufHeader.debug_source");
    target = stream->WriteStringMaybeAliased(
        34, this->_internal_debug_source(), target);
  }

  // optional uint32 debug_source_string_index = 35;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(35, this->_internal_debug_source_string_index(), target);
  }

  // optional uint64 token_id = 36;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(36, this->_internal_token_id(), target);
  }

  // optional .CMsgGCRoutingProtoBufHeader routing_gc = 37;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(37, _Internal::routing_gc(this),
        _Internal::routing_gc(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgProtoBufHeader.ESessionDisposition session_disposition = 38 [default = k_ESessionDispositionNormal];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      38, this->_internal_session_disposition(), target);
  }

  // optional string wg_token = 39;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_wg_token().data(), static_cast<int>(this->_internal_wg_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgProtoBufHeader.wg_token");
    target = stream->WriteStringMaybeAliased(
        39, this->_internal_wg_token(), target);
  }

  // optional string webui_auth_key = 40;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_webui_auth_key().data(), static_cast<int>(this->_internal_webui_auth_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgProtoBufHeader.webui_auth_key");
    target = stream->WriteStringMaybeAliased(
        40, this->_internal_webui_auth_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgProtoBufHeader)
  return target;
}

size_t CMsgProtoBufHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgProtoBufHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 forward_to_sysid = 27;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.forward_to_sysid_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_forward_to_sysid_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string target_job_name = 12;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_target_job_name());
    }

    // optional string error_message = 14;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional string debug_source = 34;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_debug_source());
    }

    // optional string wg_token = 39;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_wg_token());
    }

    // optional string webui_auth_key = 40;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_webui_auth_key());
    }

    // optional .CMsgGCRoutingProtoBufHeader routing_gc = 37;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.routing_gc_);
    }

    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional int32 client_sessionid = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client_sessionid());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 routing_appid = 3;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_routing_appid());
    }

    // optional uint32 auth_account_flags = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_auth_account_flags());
    }

    // optional uint32 publisher_group_id = 19;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_publisher_group_id());
    }

    // optional uint64 trace_tag = 21;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_trace_tag());
    }

    // optional uint32 sysid = 20;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_sysid());
    }

    // optional uint32 token_source = 22;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_token_source());
    }

    // optional int32 seq_num = 24;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_seq_num());
    }

    // optional bool admin_spoofing_user = 23;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool is_from_external_source = 26;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional uint32 webapi_key_id = 25;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_webapi_key_id());
    }

    // optional uint32 cm_sysid = 28;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_cm_sysid());
    }

    // optional uint32 launcher_type = 31 [default = 0];
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_launcher_type());
    }

    // optional uint32 realm = 32 [default = 0];
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_realm());
    }

    // optional uint64 token_id = 36;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_token_id());
    }

    // optional uint32 debug_source_string_index = 35;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_debug_source_string_index());
    }

    // optional .CMsgProtoBufHeader.ESessionDisposition session_disposition = 38 [default = k_ESessionDispositionNormal];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_session_disposition());
    }

  }
  if (cached_has_bits & 0x3f000000u) {
    // optional int32 timeout_ms = 33 [default = -1];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_timeout_ms());
    }

    // optional fixed64 jobid_source = 10 [default = 18446744073709551615];
    if (cached_has_bits & 0x02000000u) {
      total_size += 1 + 8;
    }

    // optional fixed64 jobid_target = 11 [default = 18446744073709551615];
    if (cached_has_bits & 0x04000000u) {
      total_size += 1 + 8;
    }

    // optional int32 eresult = 13 [default = 2];
    if (cached_has_bits & 0x08000000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eresult());
    }

    // optional int32 transport_error = 17 [default = 1];
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_transport_error());
    }

    // optional uint64 messageid = 18 [default = 18446744073709551615];
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_messageid());
    }

  }
  switch (ip_addr_case()) {
    // uint32 ip = 15;
    case kIp: {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ip());
      break;
    }
    // bytes ip_v6 = 29;
    case kIpV6: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ip_v6());
      break;
    }
    case IP_ADDR_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgProtoBufHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgProtoBufHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgProtoBufHeader::GetClassData() const { return &_class_data_; }


void CMsgProtoBufHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgProtoBufHeader*>(&to_msg);
  auto& from = static_cast<const CMsgProtoBufHeader&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgProtoBufHeader)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.forward_to_sysid_.MergeFrom(from._impl_.forward_to_sysid_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_target_job_name(from._internal_target_job_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_debug_source(from._internal_debug_source());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_wg_token(from._internal_wg_token());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_webui_auth_key(from._internal_webui_auth_key());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_routing_gc()->::CMsgGCRoutingProtoBufHeader::MergeFrom(
          from._internal_routing_gc());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.client_sessionid_ = from._impl_.client_sessionid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.routing_appid_ = from._impl_.routing_appid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.auth_account_flags_ = from._impl_.auth_account_flags_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.publisher_group_id_ = from._impl_.publisher_group_id_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.trace_tag_ = from._impl_.trace_tag_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.sysid_ = from._impl_.sysid_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.token_source_ = from._impl_.token_source_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.seq_num_ = from._impl_.seq_num_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.admin_spoofing_user_ = from._impl_.admin_spoofing_user_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.is_from_external_source_ = from._impl_.is_from_external_source_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.webapi_key_id_ = from._impl_.webapi_key_id_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.cm_sysid_ = from._impl_.cm_sysid_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.launcher_type_ = from._impl_.launcher_type_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.realm_ = from._impl_.realm_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.token_id_ = from._impl_.token_id_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.debug_source_string_index_ = from._impl_.debug_source_string_index_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.session_disposition_ = from._impl_.session_disposition_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x3f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.timeout_ms_ = from._impl_.timeout_ms_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.jobid_source_ = from._impl_.jobid_source_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.jobid_target_ = from._impl_.jobid_target_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.eresult_ = from._impl_.eresult_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.transport_error_ = from._impl_.transport_error_;
    }
    if (cached_has_bits & 0x20000000u) {
      _this->_impl_.messageid_ = from._impl_.messageid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.ip_addr_case()) {
    case kIp: {
      _this->_internal_set_ip(from._internal_ip());
      break;
    }
    case kIpV6: {
      _this->_internal_set_ip_v6(from._internal_ip_v6());
      break;
    }
    case IP_ADDR_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgProtoBufHeader::CopyFrom(const CMsgProtoBufHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgProtoBufHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgProtoBufHeader::IsInitialized() const {
  return true;
}

void CMsgProtoBufHeader::InternalSwap(CMsgProtoBufHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.forward_to_sysid_.InternalSwap(&other->_impl_.forward_to_sysid_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.target_job_name_, lhs_arena,
      &other->_impl_.target_job_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_message_, lhs_arena,
      &other->_impl_.error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.debug_source_, lhs_arena,
      &other->_impl_.debug_source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.wg_token_, lhs_arena,
      &other->_impl_.wg_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.webui_auth_key_, lhs_arena,
      &other->_impl_.webui_auth_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgProtoBufHeader, _impl_.session_disposition_)
      + sizeof(CMsgProtoBufHeader::_impl_.session_disposition_)
      - PROTOBUF_FIELD_OFFSET(CMsgProtoBufHeader, _impl_.routing_gc_)>(
          reinterpret_cast<char*>(&_impl_.routing_gc_),
          reinterpret_cast<char*>(&other->_impl_.routing_gc_));
  swap(_impl_.timeout_ms_, other->_impl_.timeout_ms_);
  swap(_impl_.jobid_source_, other->_impl_.jobid_source_);
  swap(_impl_.jobid_target_, other->_impl_.jobid_target_);
  swap(_impl_.eresult_, other->_impl_.eresult_);
  swap(_impl_.transport_error_, other->_impl_.transport_error_);
  swap(_impl_.messageid_, other->_impl_.messageid_);
  swap(_impl_.ip_addr_, other->_impl_.ip_addr_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgProtoBufHeader::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[3]);
}

// ===================================================================

class CMsgMulti::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMulti>()._impl_._has_bits_);
  static void set_has_size_unzipped(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgMulti::CMsgMulti(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgMulti)
}
CMsgMulti::CMsgMulti(const CMsgMulti& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgMulti* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_body_){}
    , decltype(_impl_.size_unzipped_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_body()) {
    _this->_impl_.message_body_.Set(from._internal_message_body(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.size_unzipped_ = from._impl_.size_unzipped_;
  // @@protoc_insertion_point(copy_constructor:CMsgMulti)
}

inline void CMsgMulti::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_body_){}
    , decltype(_impl_.size_unzipped_){0u}
  };
  _impl_.message_body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgMulti::~CMsgMulti() {
  // @@protoc_insertion_point(destructor:CMsgMulti)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgMulti::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_body_.Destroy();
}

void CMsgMulti::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgMulti::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMulti)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_body_.ClearNonDefaultToEmpty();
  }
  _impl_.size_unzipped_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMulti::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 size_unzipped = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_size_unzipped(&has_bits);
          _impl_.size_unzipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes message_body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMulti::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMulti)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 size_unzipped = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_size_unzipped(), target);
  }

  // optional bytes message_body = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_message_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMulti)
  return target;
}

size_t CMsgMulti::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMulti)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes message_body = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_message_body());
    }

    // optional uint32 size_unzipped = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_size_unzipped());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMulti::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgMulti::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMulti::GetClassData() const { return &_class_data_; }


void CMsgMulti::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgMulti*>(&to_msg);
  auto& from = static_cast<const CMsgMulti&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgMulti)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_message_body(from._internal_message_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.size_unzipped_ = from._impl_.size_unzipped_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMulti::CopyFrom(const CMsgMulti& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMulti)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMulti::IsInitialized() const {
  return true;
}

void CMsgMulti::InternalSwap(CMsgMulti* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_body_, lhs_arena,
      &other->_impl_.message_body_, rhs_arena
  );
  swap(_impl_.size_unzipped_, other->_impl_.size_unzipped_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMulti::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[4]);
}

// ===================================================================

class CMsgProtobufWrapped::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgProtobufWrapped>()._impl_._has_bits_);
  static void set_has_message_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgProtobufWrapped::CMsgProtobufWrapped(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgProtobufWrapped)
}
CMsgProtobufWrapped::CMsgProtobufWrapped(const CMsgProtobufWrapped& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgProtobufWrapped* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_body_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message_body()) {
    _this->_impl_.message_body_.Set(from._internal_message_body(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgProtobufWrapped)
}

inline void CMsgProtobufWrapped::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.message_body_){}
  };
  _impl_.message_body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgProtobufWrapped::~CMsgProtobufWrapped() {
  // @@protoc_insertion_point(destructor:CMsgProtobufWrapped)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgProtobufWrapped::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_body_.Destroy();
}

void CMsgProtobufWrapped::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgProtobufWrapped::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgProtobufWrapped)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.message_body_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgProtobufWrapped::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes message_body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_message_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgProtobufWrapped::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgProtobufWrapped)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes message_body = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_message_body(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgProtobufWrapped)
  return target;
}

size_t CMsgProtobufWrapped::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgProtobufWrapped)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes message_body = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_message_body());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgProtobufWrapped::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgProtobufWrapped::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgProtobufWrapped::GetClassData() const { return &_class_data_; }


void CMsgProtobufWrapped::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgProtobufWrapped*>(&to_msg);
  auto& from = static_cast<const CMsgProtobufWrapped&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgProtobufWrapped)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_message_body()) {
    _this->_internal_set_message_body(from._internal_message_body());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgProtobufWrapped::CopyFrom(const CMsgProtobufWrapped& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgProtobufWrapped)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgProtobufWrapped::IsInitialized() const {
  return true;
}

void CMsgProtobufWrapped::InternalSwap(CMsgProtobufWrapped* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_body_, lhs_arena,
      &other->_impl_.message_body_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgProtobufWrapped::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[5]);
}

// ===================================================================

class CMsgAuthTicket::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAuthTicket>()._impl_._has_bits_);
  static void set_has_estate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_h_steam_pipe(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ticket_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_ticket(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_server_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ticket_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgAuthTicket::CMsgAuthTicket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAuthTicket)
}
CMsgAuthTicket::CMsgAuthTicket(const CMsgAuthTicket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAuthTicket* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ticket_){}
    , decltype(_impl_.server_secret_){}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.estate_){}
    , decltype(_impl_.h_steam_pipe_){}
    , decltype(_impl_.gameid_){}
    , decltype(_impl_.ticket_crc_){}
    , decltype(_impl_.ticket_type_){}
    , decltype(_impl_.eresult_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ticket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ticket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ticket()) {
    _this->_impl_.ticket_.Set(from._internal_ticket(), 
      _this->GetArenaForAllocation());
  }
  _impl_.server_secret_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_secret_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_secret()) {
    _this->_impl_.server_secret_.Set(from._internal_server_secret(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.eresult_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgAuthTicket)
}

inline void CMsgAuthTicket::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ticket_){}
    , decltype(_impl_.server_secret_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.estate_){0u}
    , decltype(_impl_.h_steam_pipe_){0u}
    , decltype(_impl_.gameid_){uint64_t{0u}}
    , decltype(_impl_.ticket_crc_){0u}
    , decltype(_impl_.ticket_type_){0u}
    , decltype(_impl_.eresult_){2u}
  };
  _impl_.ticket_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ticket_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_secret_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_secret_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgAuthTicket::~CMsgAuthTicket() {
  // @@protoc_insertion_point(destructor:CMsgAuthTicket)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAuthTicket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ticket_.Destroy();
  _impl_.server_secret_.Destroy();
}

void CMsgAuthTicket::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAuthTicket::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAuthTicket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.ticket_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.server_secret_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ticket_type_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.ticket_type_));
  }
  _impl_.eresult_ = 2u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAuthTicket::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 estate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_estate(&has_bits);
          _impl_.estate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eresult = 2 [default = 2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_eresult(&has_bits);
          _impl_.eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 gameid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_gameid(&has_bits);
          _impl_.gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 h_steam_pipe = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_h_steam_pipe(&has_bits);
          _impl_.h_steam_pipe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ticket_crc = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_ticket_crc(&has_bits);
          _impl_.ticket_crc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes ticket = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_ticket();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes server_secret = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_server_secret();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ticket_type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_ticket_type(&has_bits);
          _impl_.ticket_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAuthTicket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAuthTicket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 estate = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_estate(), target);
  }

  // optional uint32 eresult = 2 [default = 2];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_eresult(), target);
  }

  // optional fixed64 steamid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_steamid(), target);
  }

  // optional fixed64 gameid = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_gameid(), target);
  }

  // optional uint32 h_steam_pipe = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_h_steam_pipe(), target);
  }

  // optional uint32 ticket_crc = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_ticket_crc(), target);
  }

  // optional bytes ticket = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_ticket(), target);
  }

  // optional bytes server_secret = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_server_secret(), target);
  }

  // optional uint32 ticket_type = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_ticket_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAuthTicket)
  return target;
}

size_t CMsgAuthTicket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAuthTicket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes ticket = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ticket());
    }

    // optional bytes server_secret = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_server_secret());
    }

    // optional fixed64 steamid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 estate = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_estate());
    }

    // optional uint32 h_steam_pipe = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_h_steam_pipe());
    }

    // optional fixed64 gameid = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 8;
    }

    // optional uint32 ticket_crc = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ticket_crc());
    }

    // optional uint32 ticket_type = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_ticket_type());
    }

  }
  // optional uint32 eresult = 2 [default = 2];
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAuthTicket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAuthTicket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAuthTicket::GetClassData() const { return &_class_data_; }


void CMsgAuthTicket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAuthTicket*>(&to_msg);
  auto& from = static_cast<const CMsgAuthTicket&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAuthTicket)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_ticket(from._internal_ticket());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_server_secret(from._internal_server_secret());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.estate_ = from._impl_.estate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.h_steam_pipe_ = from._impl_.h_steam_pipe_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.gameid_ = from._impl_.gameid_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.ticket_crc_ = from._impl_.ticket_crc_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.ticket_type_ = from._impl_.ticket_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_eresult(from._internal_eresult());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAuthTicket::CopyFrom(const CMsgAuthTicket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAuthTicket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAuthTicket::IsInitialized() const {
  return true;
}

void CMsgAuthTicket::InternalSwap(CMsgAuthTicket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ticket_, lhs_arena,
      &other->_impl_.ticket_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_secret_, lhs_arena,
      &other->_impl_.server_secret_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAuthTicket, _impl_.ticket_type_)
      + sizeof(CMsgAuthTicket::_impl_.ticket_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgAuthTicket, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
  swap(_impl_.eresult_, other->_impl_.eresult_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAuthTicket::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[6]);
}

// ===================================================================

class CCDDBAppDetailCommon::_Internal {
 public:
  using HasBits = decltype(std::declval<CCDDBAppDetailCommon>()._impl_._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tool(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_demo(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_media(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_community_visible_stats(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_propagation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_has_adult_content(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_visible_in_steam_china(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_app_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_has_adult_content_sex(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_has_adult_content_violence(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

CCDDBAppDetailCommon::CCDDBAppDetailCommon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCDDBAppDetailCommon)
}
CCDDBAppDetailCommon::CCDDBAppDetailCommon(const CCDDBAppDetailCommon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCDDBAppDetailCommon* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_descriptorids_){from._impl_.content_descriptorids_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.icon_){}
    , decltype(_impl_.friendly_name_){}
    , decltype(_impl_.propagation_){}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.tool_){}
    , decltype(_impl_.demo_){}
    , decltype(_impl_.media_){}
    , decltype(_impl_.community_visible_stats_){}
    , decltype(_impl_.app_type_){}
    , decltype(_impl_.has_adult_content_){}
    , decltype(_impl_.is_visible_in_steam_china_){}
    , decltype(_impl_.has_adult_content_sex_){}
    , decltype(_impl_.has_adult_content_violence_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_icon()) {
    _this->_impl_.icon_.Set(from._internal_icon(), 
      _this->GetArenaForAllocation());
  }
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friendly_name()) {
    _this->_impl_.friendly_name_.Set(from._internal_friendly_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.propagation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.propagation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_propagation()) {
    _this->_impl_.propagation_.Set(from._internal_propagation(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.appid_, &from._impl_.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.has_adult_content_violence_) -
    reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.has_adult_content_violence_));
  // @@protoc_insertion_point(copy_constructor:CCDDBAppDetailCommon)
}

inline void CCDDBAppDetailCommon::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_descriptorids_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.icon_){}
    , decltype(_impl_.friendly_name_){}
    , decltype(_impl_.propagation_){}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.tool_){false}
    , decltype(_impl_.demo_){false}
    , decltype(_impl_.media_){false}
    , decltype(_impl_.community_visible_stats_){false}
    , decltype(_impl_.app_type_){0u}
    , decltype(_impl_.has_adult_content_){false}
    , decltype(_impl_.is_visible_in_steam_china_){false}
    , decltype(_impl_.has_adult_content_sex_){false}
    , decltype(_impl_.has_adult_content_violence_){false}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.friendly_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friendly_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.propagation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.propagation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCDDBAppDetailCommon::~CCDDBAppDetailCommon() {
  // @@protoc_insertion_point(destructor:CCDDBAppDetailCommon)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCDDBAppDetailCommon::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_descriptorids_.~RepeatedField();
  _impl_.name_.Destroy();
  _impl_.icon_.Destroy();
  _impl_.friendly_name_.Destroy();
  _impl_.propagation_.Destroy();
}

void CCDDBAppDetailCommon::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCDDBAppDetailCommon::Clear() {
// @@protoc_insertion_point(message_clear_start:CCDDBAppDetailCommon)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.content_descriptorids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.icon_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.friendly_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.propagation_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.media_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.media_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.community_visible_stats_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.has_adult_content_violence_) -
        reinterpret_cast<char*>(&_impl_.community_visible_stats_)) + sizeof(_impl_.has_adult_content_violence_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCDDBAppDetailCommon::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCDDBAppDetailCommon.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string icon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_icon();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCDDBAppDetailCommon.icon");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool tool = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tool(&has_bits);
          _impl_.tool_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool demo = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_demo(&has_bits);
          _impl_.demo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool media = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_media(&has_bits);
          _impl_.media_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool community_visible_stats = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_community_visible_stats(&has_bits);
          _impl_.community_visible_stats_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string friendly_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCDDBAppDetailCommon.friendly_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string propagation = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_propagation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCDDBAppDetailCommon.propagation");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool has_adult_content = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_has_adult_content(&has_bits);
          _impl_.has_adult_content_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_visible_in_steam_china = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_visible_in_steam_china(&has_bits);
          _impl_.is_visible_in_steam_china_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 app_type = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_app_type(&has_bits);
          _impl_.app_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_adult_content_sex = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_has_adult_content_sex(&has_bits);
          _impl_.has_adult_content_sex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_adult_content_violence = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_has_adult_content_violence(&has_bits);
          _impl_.has_adult_content_violence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 content_descriptorids = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_content_descriptorids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<136>(ptr));
        } else if (static_cast<uint8_t>(tag) == 138) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_content_descriptorids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCDDBAppDetailCommon::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCDDBAppDetailCommon)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCDDBAppDetailCommon.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string icon = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_icon().data(), static_cast<int>(this->_internal_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCDDBAppDetailCommon.icon");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_icon(), target);
  }

  // optional bool tool = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_tool(), target);
  }

  // optional bool demo = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_demo(), target);
  }

  // optional bool media = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_media(), target);
  }

  // optional bool community_visible_stats = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_community_visible_stats(), target);
  }

  // optional string friendly_name = 10;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCDDBAppDetailCommon.friendly_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_friendly_name(), target);
  }

  // optional string propagation = 11;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_propagation().data(), static_cast<int>(this->_internal_propagation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCDDBAppDetailCommon.propagation");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_propagation(), target);
  }

  // optional bool has_adult_content = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_has_adult_content(), target);
  }

  // optional bool is_visible_in_steam_china = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_visible_in_steam_china(), target);
  }

  // optional uint32 app_type = 14;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_app_type(), target);
  }

  // optional bool has_adult_content_sex = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_has_adult_content_sex(), target);
  }

  // optional bool has_adult_content_violence = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_has_adult_content_violence(), target);
  }

  // repeated uint32 content_descriptorids = 17;
  for (int i = 0, n = this->_internal_content_descriptorids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(17, this->_internal_content_descriptorids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCDDBAppDetailCommon)
  return target;
}

size_t CCDDBAppDetailCommon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCDDBAppDetailCommon)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 content_descriptorids = 17;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.content_descriptorids_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_content_descriptorids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string icon = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_icon());
    }

    // optional string friendly_name = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_name());
    }

    // optional string propagation = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_propagation());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional bool tool = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool demo = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool media = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00003f00u) {
    // optional bool community_visible_stats = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 app_type = 14;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_app_type());
    }

    // optional bool has_adult_content = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool is_visible_in_steam_china = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool has_adult_content_sex = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool has_adult_content_violence = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCDDBAppDetailCommon::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCDDBAppDetailCommon::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCDDBAppDetailCommon::GetClassData() const { return &_class_data_; }


void CCDDBAppDetailCommon::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCDDBAppDetailCommon*>(&to_msg);
  auto& from = static_cast<const CCDDBAppDetailCommon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCDDBAppDetailCommon)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.content_descriptorids_.MergeFrom(from._impl_.content_descriptorids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_icon(from._internal_icon());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_friendly_name(from._internal_friendly_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_propagation(from._internal_propagation());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.tool_ = from._impl_.tool_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.demo_ = from._impl_.demo_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.media_ = from._impl_.media_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.community_visible_stats_ = from._impl_.community_visible_stats_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.app_type_ = from._impl_.app_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.has_adult_content_ = from._impl_.has_adult_content_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.is_visible_in_steam_china_ = from._impl_.is_visible_in_steam_china_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.has_adult_content_sex_ = from._impl_.has_adult_content_sex_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.has_adult_content_violence_ = from._impl_.has_adult_content_violence_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCDDBAppDetailCommon::CopyFrom(const CCDDBAppDetailCommon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCDDBAppDetailCommon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCDDBAppDetailCommon::IsInitialized() const {
  return true;
}

void CCDDBAppDetailCommon::InternalSwap(CCDDBAppDetailCommon* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.content_descriptorids_.InternalSwap(&other->_impl_.content_descriptorids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.icon_, lhs_arena,
      &other->_impl_.icon_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.friendly_name_, lhs_arena,
      &other->_impl_.friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.propagation_, lhs_arena,
      &other->_impl_.propagation_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCDDBAppDetailCommon, _impl_.has_adult_content_violence_)
      + sizeof(CCDDBAppDetailCommon::_impl_.has_adult_content_violence_)
      - PROTOBUF_FIELD_OFFSET(CCDDBAppDetailCommon, _impl_.appid_)>(
          reinterpret_cast<char*>(&_impl_.appid_),
          reinterpret_cast<char*>(&other->_impl_.appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCDDBAppDetailCommon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[7]);
}

// ===================================================================

class CMsgAppRights::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAppRights>()._impl_._has_bits_);
  static void set_has_edit_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_publish(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_view_error_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_download(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_upload_cdkeys(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_generate_cdkeys(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_view_financials(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_manage_ceg(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_manage_signing(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_manage_cdkeys(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_edit_marketing(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_economy_support(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_economy_support_supervisor(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_manage_pricing(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_broadcast_live(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_view_marketing_traffic(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_edit_store_display_content(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

CMsgAppRights::CMsgAppRights(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgAppRights)
}
CMsgAppRights::CMsgAppRights(const CMsgAppRights& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgAppRights* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.edit_info_){}
    , decltype(_impl_.publish_){}
    , decltype(_impl_.view_error_data_){}
    , decltype(_impl_.download_){}
    , decltype(_impl_.upload_cdkeys_){}
    , decltype(_impl_.generate_cdkeys_){}
    , decltype(_impl_.view_financials_){}
    , decltype(_impl_.manage_ceg_){}
    , decltype(_impl_.manage_signing_){}
    , decltype(_impl_.manage_cdkeys_){}
    , decltype(_impl_.edit_marketing_){}
    , decltype(_impl_.economy_support_){}
    , decltype(_impl_.economy_support_supervisor_){}
    , decltype(_impl_.manage_pricing_){}
    , decltype(_impl_.broadcast_live_){}
    , decltype(_impl_.view_marketing_traffic_){}
    , decltype(_impl_.edit_store_display_content_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.edit_info_, &from._impl_.edit_info_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.edit_store_display_content_) -
    reinterpret_cast<char*>(&_impl_.edit_info_)) + sizeof(_impl_.edit_store_display_content_));
  // @@protoc_insertion_point(copy_constructor:CMsgAppRights)
}

inline void CMsgAppRights::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.edit_info_){false}
    , decltype(_impl_.publish_){false}
    , decltype(_impl_.view_error_data_){false}
    , decltype(_impl_.download_){false}
    , decltype(_impl_.upload_cdkeys_){false}
    , decltype(_impl_.generate_cdkeys_){false}
    , decltype(_impl_.view_financials_){false}
    , decltype(_impl_.manage_ceg_){false}
    , decltype(_impl_.manage_signing_){false}
    , decltype(_impl_.manage_cdkeys_){false}
    , decltype(_impl_.edit_marketing_){false}
    , decltype(_impl_.economy_support_){false}
    , decltype(_impl_.economy_support_supervisor_){false}
    , decltype(_impl_.manage_pricing_){false}
    , decltype(_impl_.broadcast_live_){false}
    , decltype(_impl_.view_marketing_traffic_){false}
    , decltype(_impl_.edit_store_display_content_){false}
  };
}

CMsgAppRights::~CMsgAppRights() {
  // @@protoc_insertion_point(destructor:CMsgAppRights)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgAppRights::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAppRights::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgAppRights::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAppRights)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.edit_info_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.manage_ceg_) -
        reinterpret_cast<char*>(&_impl_.edit_info_)) + sizeof(_impl_.manage_ceg_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.manage_signing_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.view_marketing_traffic_) -
        reinterpret_cast<char*>(&_impl_.manage_signing_)) + sizeof(_impl_.view_marketing_traffic_));
  }
  _impl_.edit_store_display_content_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAppRights::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool edit_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_edit_info(&has_bits);
          _impl_.edit_info_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool publish = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_publish(&has_bits);
          _impl_.publish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool view_error_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_view_error_data(&has_bits);
          _impl_.view_error_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool download = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_download(&has_bits);
          _impl_.download_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool upload_cdkeys = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_upload_cdkeys(&has_bits);
          _impl_.upload_cdkeys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool generate_cdkeys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_generate_cdkeys(&has_bits);
          _impl_.generate_cdkeys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool view_financials = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_view_financials(&has_bits);
          _impl_.view_financials_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool manage_ceg = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_manage_ceg(&has_bits);
          _impl_.manage_ceg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool manage_signing = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_manage_signing(&has_bits);
          _impl_.manage_signing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool manage_cdkeys = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_manage_cdkeys(&has_bits);
          _impl_.manage_cdkeys_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool edit_marketing = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_edit_marketing(&has_bits);
          _impl_.edit_marketing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool economy_support = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_economy_support(&has_bits);
          _impl_.economy_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool economy_support_supervisor = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_economy_support_supervisor(&has_bits);
          _impl_.economy_support_supervisor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool manage_pricing = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_manage_pricing(&has_bits);
          _impl_.manage_pricing_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool broadcast_live = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_broadcast_live(&has_bits);
          _impl_.broadcast_live_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool view_marketing_traffic = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_view_marketing_traffic(&has_bits);
          _impl_.view_marketing_traffic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool edit_store_display_content = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_edit_store_display_content(&has_bits);
          _impl_.edit_store_display_content_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAppRights::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAppRights)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool edit_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_edit_info(), target);
  }

  // optional bool publish = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_publish(), target);
  }

  // optional bool view_error_data = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_view_error_data(), target);
  }

  // optional bool download = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_download(), target);
  }

  // optional bool upload_cdkeys = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_upload_cdkeys(), target);
  }

  // optional bool generate_cdkeys = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_generate_cdkeys(), target);
  }

  // optional bool view_financials = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_view_financials(), target);
  }

  // optional bool manage_ceg = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_manage_ceg(), target);
  }

  // optional bool manage_signing = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_manage_signing(), target);
  }

  // optional bool manage_cdkeys = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_manage_cdkeys(), target);
  }

  // optional bool edit_marketing = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_edit_marketing(), target);
  }

  // optional bool economy_support = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_economy_support(), target);
  }

  // optional bool economy_support_supervisor = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_economy_support_supervisor(), target);
  }

  // optional bool manage_pricing = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_manage_pricing(), target);
  }

  // optional bool broadcast_live = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_broadcast_live(), target);
  }

  // optional bool view_marketing_traffic = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_view_marketing_traffic(), target);
  }

  // optional bool edit_store_display_content = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_edit_store_display_content(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAppRights)
  return target;
}

size_t CMsgAppRights::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAppRights)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool edit_info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool publish = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool view_error_data = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool download = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool upload_cdkeys = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool generate_cdkeys = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool view_financials = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool manage_ceg = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool manage_signing = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool manage_cdkeys = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool edit_marketing = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool economy_support = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool economy_support_supervisor = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool manage_pricing = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool broadcast_live = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool view_marketing_traffic = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  // optional bool edit_store_display_content = 17;
  if (cached_has_bits & 0x00010000u) {
    total_size += 2 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAppRights::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgAppRights::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAppRights::GetClassData() const { return &_class_data_; }


void CMsgAppRights::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgAppRights*>(&to_msg);
  auto& from = static_cast<const CMsgAppRights&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgAppRights)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.edit_info_ = from._impl_.edit_info_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.publish_ = from._impl_.publish_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.view_error_data_ = from._impl_.view_error_data_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.download_ = from._impl_.download_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.upload_cdkeys_ = from._impl_.upload_cdkeys_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.generate_cdkeys_ = from._impl_.generate_cdkeys_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.view_financials_ = from._impl_.view_financials_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.manage_ceg_ = from._impl_.manage_ceg_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.manage_signing_ = from._impl_.manage_signing_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.manage_cdkeys_ = from._impl_.manage_cdkeys_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.edit_marketing_ = from._impl_.edit_marketing_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.economy_support_ = from._impl_.economy_support_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.economy_support_supervisor_ = from._impl_.economy_support_supervisor_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.manage_pricing_ = from._impl_.manage_pricing_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.broadcast_live_ = from._impl_.broadcast_live_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.view_marketing_traffic_ = from._impl_.view_marketing_traffic_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00010000u) {
    _this->_internal_set_edit_store_display_content(from._internal_edit_store_display_content());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAppRights::CopyFrom(const CMsgAppRights& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAppRights)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAppRights::IsInitialized() const {
  return true;
}

void CMsgAppRights::InternalSwap(CMsgAppRights* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgAppRights, _impl_.edit_store_display_content_)
      + sizeof(CMsgAppRights::_impl_.edit_store_display_content_)
      - PROTOBUF_FIELD_OFFSET(CMsgAppRights, _impl_.edit_info_)>(
          reinterpret_cast<char*>(&_impl_.edit_info_),
          reinterpret_cast<char*>(&other->_impl_.edit_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAppRights::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[8]);
}

// ===================================================================

class CCuratorPreferences::_Internal {
 public:
  using HasBits = decltype(std::declval<CCuratorPreferences>()._impl_._has_bits_);
  static void set_has_supported_languages(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_platform_windows(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_platform_linux(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_vr_content(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_adult_content_violence(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_adult_content_sex(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_timestamp_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_website_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_website_url(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_discussion_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_show_broadcast(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CCuratorPreferences::CCuratorPreferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCuratorPreferences)
}
CCuratorPreferences::CCuratorPreferences(const CCuratorPreferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCuratorPreferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tagids_curated_){from._impl_.tagids_curated_}
    , decltype(_impl_.tagids_filtered_){from._impl_.tagids_filtered_}
    , decltype(_impl_.website_title_){}
    , decltype(_impl_.website_url_){}
    , decltype(_impl_.discussion_url_){}
    , decltype(_impl_.supported_languages_){}
    , decltype(_impl_.platform_windows_){}
    , decltype(_impl_.platform_mac_){}
    , decltype(_impl_.platform_linux_){}
    , decltype(_impl_.vr_content_){}
    , decltype(_impl_.timestamp_updated_){}
    , decltype(_impl_.adult_content_violence_){}
    , decltype(_impl_.adult_content_sex_){}
    , decltype(_impl_.show_broadcast_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.website_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.website_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_website_title()) {
    _this->_impl_.website_title_.Set(from._internal_website_title(), 
      _this->GetArenaForAllocation());
  }
  _impl_.website_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.website_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_website_url()) {
    _this->_impl_.website_url_.Set(from._internal_website_url(), 
      _this->GetArenaForAllocation());
  }
  _impl_.discussion_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.discussion_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_discussion_url()) {
    _this->_impl_.discussion_url_.Set(from._internal_discussion_url(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.supported_languages_, &from._impl_.supported_languages_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.show_broadcast_) -
    reinterpret_cast<char*>(&_impl_.supported_languages_)) + sizeof(_impl_.show_broadcast_));
  // @@protoc_insertion_point(copy_constructor:CCuratorPreferences)
}

inline void CCuratorPreferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tagids_curated_){arena}
    , decltype(_impl_.tagids_filtered_){arena}
    , decltype(_impl_.website_title_){}
    , decltype(_impl_.website_url_){}
    , decltype(_impl_.discussion_url_){}
    , decltype(_impl_.supported_languages_){0u}
    , decltype(_impl_.platform_windows_){false}
    , decltype(_impl_.platform_mac_){false}
    , decltype(_impl_.platform_linux_){false}
    , decltype(_impl_.vr_content_){false}
    , decltype(_impl_.timestamp_updated_){0u}
    , decltype(_impl_.adult_content_violence_){false}
    , decltype(_impl_.adult_content_sex_){false}
    , decltype(_impl_.show_broadcast_){false}
  };
  _impl_.website_title_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.website_title_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.website_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.website_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.discussion_url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.discussion_url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCuratorPreferences::~CCuratorPreferences() {
  // @@protoc_insertion_point(destructor:CCuratorPreferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCuratorPreferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tagids_curated_.~RepeatedField();
  _impl_.tagids_filtered_.~RepeatedField();
  _impl_.website_title_.Destroy();
  _impl_.website_url_.Destroy();
  _impl_.discussion_url_.Destroy();
}

void CCuratorPreferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCuratorPreferences::Clear() {
// @@protoc_insertion_point(message_clear_start:CCuratorPreferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tagids_curated_.Clear();
  _impl_.tagids_filtered_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.website_title_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.website_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.discussion_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.supported_languages_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.vr_content_) -
        reinterpret_cast<char*>(&_impl_.supported_languages_)) + sizeof(_impl_.vr_content_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.timestamp_updated_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.show_broadcast_) -
        reinterpret_cast<char*>(&_impl_.timestamp_updated_)) + sizeof(_impl_.show_broadcast_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCuratorPreferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 supported_languages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_supported_languages(&has_bits);
          _impl_.supported_languages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool platform_windows = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_platform_windows(&has_bits);
          _impl_.platform_windows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool platform_mac = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_platform_mac(&has_bits);
          _impl_.platform_mac_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool platform_linux = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_platform_linux(&has_bits);
          _impl_.platform_linux_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool vr_content = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_vr_content(&has_bits);
          _impl_.vr_content_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool adult_content_violence = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_adult_content_violence(&has_bits);
          _impl_.adult_content_violence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool adult_content_sex = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_adult_content_sex(&has_bits);
          _impl_.adult_content_sex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_updated = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_timestamp_updated(&has_bits);
          _impl_.timestamp_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 tagids_curated = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_tagids_curated(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<72>(ptr));
        } else if (static_cast<uint8_t>(tag) == 74) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tagids_curated(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 tagids_filtered = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_tagids_filtered(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<80>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_tagids_filtered(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string website_title = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_website_title();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCuratorPreferences.website_title");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string website_url = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_website_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCuratorPreferences.website_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string discussion_url = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_discussion_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCuratorPreferences.discussion_url");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool show_broadcast = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_show_broadcast(&has_bits);
          _impl_.show_broadcast_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCuratorPreferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCuratorPreferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 supported_languages = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_supported_languages(), target);
  }

  // optional bool platform_windows = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_platform_windows(), target);
  }

  // optional bool platform_mac = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_platform_mac(), target);
  }

  // optional bool platform_linux = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_platform_linux(), target);
  }

  // optional bool vr_content = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_vr_content(), target);
  }

  // optional bool adult_content_violence = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_adult_content_violence(), target);
  }

  // optional bool adult_content_sex = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_adult_content_sex(), target);
  }

  // optional uint32 timestamp_updated = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_timestamp_updated(), target);
  }

  // repeated uint32 tagids_curated = 9;
  for (int i = 0, n = this->_internal_tagids_curated_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_tagids_curated(i), target);
  }

  // repeated uint32 tagids_filtered = 10;
  for (int i = 0, n = this->_internal_tagids_filtered_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_tagids_filtered(i), target);
  }

  // optional string website_title = 11;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_website_title().data(), static_cast<int>(this->_internal_website_title().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCuratorPreferences.website_title");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_website_title(), target);
  }

  // optional string website_url = 12;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_website_url().data(), static_cast<int>(this->_internal_website_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCuratorPreferences.website_url");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_website_url(), target);
  }

  // optional string discussion_url = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_discussion_url().data(), static_cast<int>(this->_internal_discussion_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCuratorPreferences.discussion_url");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_discussion_url(), target);
  }

  // optional bool show_broadcast = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_show_broadcast(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCuratorPreferences)
  return target;
}

size_t CCuratorPreferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCuratorPreferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 tagids_curated = 9;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.tagids_curated_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_tagids_curated_size());
    total_size += data_size;
  }

  // repeated uint32 tagids_filtered = 10;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.tagids_filtered_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_tagids_filtered_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string website_title = 11;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_website_title());
    }

    // optional string website_url = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_website_url());
    }

    // optional string discussion_url = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_discussion_url());
    }

    // optional uint32 supported_languages = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_supported_languages());
    }

    // optional bool platform_windows = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool platform_mac = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool platform_linux = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool vr_content = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 timestamp_updated = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_updated());
    }

    // optional bool adult_content_violence = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool adult_content_sex = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool show_broadcast = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCuratorPreferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCuratorPreferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCuratorPreferences::GetClassData() const { return &_class_data_; }


void CCuratorPreferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCuratorPreferences*>(&to_msg);
  auto& from = static_cast<const CCuratorPreferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCuratorPreferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tagids_curated_.MergeFrom(from._impl_.tagids_curated_);
  _this->_impl_.tagids_filtered_.MergeFrom(from._impl_.tagids_filtered_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_website_title(from._internal_website_title());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_website_url(from._internal_website_url());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_discussion_url(from._internal_discussion_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.supported_languages_ = from._impl_.supported_languages_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.platform_windows_ = from._impl_.platform_windows_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.platform_mac_ = from._impl_.platform_mac_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.platform_linux_ = from._impl_.platform_linux_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.vr_content_ = from._impl_.vr_content_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.timestamp_updated_ = from._impl_.timestamp_updated_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.adult_content_violence_ = from._impl_.adult_content_violence_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.adult_content_sex_ = from._impl_.adult_content_sex_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.show_broadcast_ = from._impl_.show_broadcast_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCuratorPreferences::CopyFrom(const CCuratorPreferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCuratorPreferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCuratorPreferences::IsInitialized() const {
  return true;
}

void CCuratorPreferences::InternalSwap(CCuratorPreferences* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tagids_curated_.InternalSwap(&other->_impl_.tagids_curated_);
  _impl_.tagids_filtered_.InternalSwap(&other->_impl_.tagids_filtered_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.website_title_, lhs_arena,
      &other->_impl_.website_title_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.website_url_, lhs_arena,
      &other->_impl_.website_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.discussion_url_, lhs_arena,
      &other->_impl_.discussion_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCuratorPreferences, _impl_.show_broadcast_)
      + sizeof(CCuratorPreferences::_impl_.show_broadcast_)
      - PROTOBUF_FIELD_OFFSET(CCuratorPreferences, _impl_.supported_languages_)>(
          reinterpret_cast<char*>(&_impl_.supported_languages_),
          reinterpret_cast<char*>(&other->_impl_.supported_languages_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCuratorPreferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[9]);
}

// ===================================================================

class CLocalizationToken::_Internal {
 public:
  using HasBits = decltype(std::declval<CLocalizationToken>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_localized_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CLocalizationToken::CLocalizationToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CLocalizationToken)
}
CLocalizationToken::CLocalizationToken(const CLocalizationToken& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CLocalizationToken* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localized_string_){}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.localized_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.localized_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_localized_string()) {
    _this->_impl_.localized_string_.Set(from._internal_localized_string(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.language_ = from._impl_.language_;
  // @@protoc_insertion_point(copy_constructor:CLocalizationToken)
}

inline void CLocalizationToken::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.localized_string_){}
    , decltype(_impl_.language_){0u}
  };
  _impl_.localized_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.localized_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CLocalizationToken::~CLocalizationToken() {
  // @@protoc_insertion_point(destructor:CLocalizationToken)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CLocalizationToken::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.localized_string_.Destroy();
}

void CLocalizationToken::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CLocalizationToken::Clear() {
// @@protoc_insertion_point(message_clear_start:CLocalizationToken)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.localized_string_.ClearNonDefaultToEmpty();
  }
  _impl_.language_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CLocalizationToken::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string localized_string = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_localized_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CLocalizationToken.localized_string");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CLocalizationToken::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CLocalizationToken)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 language = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_language(), target);
  }

  // optional string localized_string = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_localized_string().data(), static_cast<int>(this->_internal_localized_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CLocalizationToken.localized_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_localized_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CLocalizationToken)
  return target;
}

size_t CLocalizationToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CLocalizationToken)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string localized_string = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_localized_string());
    }

    // optional uint32 language = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_language());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CLocalizationToken::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CLocalizationToken::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CLocalizationToken::GetClassData() const { return &_class_data_; }


void CLocalizationToken::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CLocalizationToken*>(&to_msg);
  auto& from = static_cast<const CLocalizationToken&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CLocalizationToken)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_localized_string(from._internal_localized_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CLocalizationToken::CopyFrom(const CLocalizationToken& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CLocalizationToken)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLocalizationToken::IsInitialized() const {
  return true;
}

void CLocalizationToken::InternalSwap(CLocalizationToken* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.localized_string_, lhs_arena,
      &other->_impl_.localized_string_, rhs_arena
  );
  swap(_impl_.language_, other->_impl_.language_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CLocalizationToken::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[10]);
}

// ===================================================================

class CClanEventUserNewsTuple::_Internal {
 public:
  using HasBits = decltype(std::declval<CClanEventUserNewsTuple>()._impl_._has_bits_);
  static void set_has_clanid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_event_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_announcement_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rtime_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rtime_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_priority_score(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_clamp_range_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_rtime32_last_modified(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CClanEventUserNewsTuple::CClanEventUserNewsTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CClanEventUserNewsTuple)
}
CClanEventUserNewsTuple::CClanEventUserNewsTuple(const CClanEventUserNewsTuple& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CClanEventUserNewsTuple* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_gid_){}
    , decltype(_impl_.clanid_){}
    , decltype(_impl_.rtime_start_){}
    , decltype(_impl_.announcement_gid_){}
    , decltype(_impl_.rtime_end_){}
    , decltype(_impl_.priority_score_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.clamp_range_slot_){}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.rtime32_last_modified_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.event_gid_, &from._impl_.event_gid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rtime32_last_modified_) -
    reinterpret_cast<char*>(&_impl_.event_gid_)) + sizeof(_impl_.rtime32_last_modified_));
  // @@protoc_insertion_point(copy_constructor:CClanEventUserNewsTuple)
}

inline void CClanEventUserNewsTuple::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.event_gid_){uint64_t{0u}}
    , decltype(_impl_.clanid_){0u}
    , decltype(_impl_.rtime_start_){0u}
    , decltype(_impl_.announcement_gid_){uint64_t{0u}}
    , decltype(_impl_.rtime_end_){0u}
    , decltype(_impl_.priority_score_){0u}
    , decltype(_impl_.type_){0u}
    , decltype(_impl_.clamp_range_slot_){0u}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.rtime32_last_modified_){0u}
  };
}

CClanEventUserNewsTuple::~CClanEventUserNewsTuple() {
  // @@protoc_insertion_point(destructor:CClanEventUserNewsTuple)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CClanEventUserNewsTuple::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CClanEventUserNewsTuple::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CClanEventUserNewsTuple::Clear() {
// @@protoc_insertion_point(message_clear_start:CClanEventUserNewsTuple)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.event_gid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clamp_range_slot_) -
        reinterpret_cast<char*>(&_impl_.event_gid_)) + sizeof(_impl_.clamp_range_slot_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.rtime32_last_modified_) -
        reinterpret_cast<char*>(&_impl_.appid_)) + sizeof(_impl_.rtime32_last_modified_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CClanEventUserNewsTuple::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 clanid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_clanid(&has_bits);
          _impl_.clanid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 event_gid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_event_gid(&has_bits);
          _impl_.event_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 announcement_gid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_announcement_gid(&has_bits);
          _impl_.announcement_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rtime_start(&has_bits);
          _impl_.rtime_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime_end = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_rtime_end(&has_bits);
          _impl_.rtime_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 priority_score = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_priority_score(&has_bits);
          _impl_.priority_score_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clamp_range_slot = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_clamp_range_slot(&has_bits);
          _impl_.clamp_range_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_last_modified = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_rtime32_last_modified(&has_bits);
          _impl_.rtime32_last_modified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CClanEventUserNewsTuple::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CClanEventUserNewsTuple)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 clanid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_clanid(), target);
  }

  // optional fixed64 event_gid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_event_gid(), target);
  }

  // optional fixed64 announcement_gid = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(3, this->_internal_announcement_gid(), target);
  }

  // optional uint32 rtime_start = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_rtime_start(), target);
  }

  // optional uint32 rtime_end = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_rtime_end(), target);
  }

  // optional uint32 priority_score = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_priority_score(), target);
  }

  // optional uint32 type = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_type(), target);
  }

  // optional uint32 clamp_range_slot = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_clamp_range_slot(), target);
  }

  // optional uint32 appid = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_appid(), target);
  }

  // optional uint32 rtime32_last_modified = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_rtime32_last_modified(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CClanEventUserNewsTuple)
  return target;
}

size_t CClanEventUserNewsTuple::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CClanEventUserNewsTuple)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 event_gid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 clanid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clanid());
    }

    // optional uint32 rtime_start = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime_start());
    }

    // optional fixed64 announcement_gid = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional uint32 rtime_end = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime_end());
    }

    // optional uint32 priority_score = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_priority_score());
    }

    // optional uint32 type = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

    // optional uint32 clamp_range_slot = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clamp_range_slot());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint32 appid = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 rtime32_last_modified = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime32_last_modified());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CClanEventUserNewsTuple::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CClanEventUserNewsTuple::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CClanEventUserNewsTuple::GetClassData() const { return &_class_data_; }


void CClanEventUserNewsTuple::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CClanEventUserNewsTuple*>(&to_msg);
  auto& from = static_cast<const CClanEventUserNewsTuple&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CClanEventUserNewsTuple)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.event_gid_ = from._impl_.event_gid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.clanid_ = from._impl_.clanid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.rtime_start_ = from._impl_.rtime_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.announcement_gid_ = from._impl_.announcement_gid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rtime_end_ = from._impl_.rtime_end_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.priority_score_ = from._impl_.priority_score_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.clamp_range_slot_ = from._impl_.clamp_range_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.rtime32_last_modified_ = from._impl_.rtime32_last_modified_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CClanEventUserNewsTuple::CopyFrom(const CClanEventUserNewsTuple& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CClanEventUserNewsTuple)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CClanEventUserNewsTuple::IsInitialized() const {
  return true;
}

void CClanEventUserNewsTuple::InternalSwap(CClanEventUserNewsTuple* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CClanEventUserNewsTuple, _impl_.rtime32_last_modified_)
      + sizeof(CClanEventUserNewsTuple::_impl_.rtime32_last_modified_)
      - PROTOBUF_FIELD_OFFSET(CClanEventUserNewsTuple, _impl_.event_gid_)>(
          reinterpret_cast<char*>(&_impl_.event_gid_),
          reinterpret_cast<char*>(&other->_impl_.event_gid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CClanEventUserNewsTuple::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[11]);
}

// ===================================================================

class CClanMatchEventByRange::_Internal {
 public:
  using HasBits = decltype(std::declval<CClanMatchEventByRange>()._impl_._has_bits_);
  static void set_has_rtime_before(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rtime_after(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_qualified(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CClanMatchEventByRange::CClanMatchEventByRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CClanMatchEventByRange)
}
CClanMatchEventByRange::CClanMatchEventByRange(const CClanMatchEventByRange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CClanMatchEventByRange* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.events_){from._impl_.events_}
    , decltype(_impl_.rtime_before_){}
    , decltype(_impl_.rtime_after_){}
    , decltype(_impl_.qualified_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.rtime_before_, &from._impl_.rtime_before_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.qualified_) -
    reinterpret_cast<char*>(&_impl_.rtime_before_)) + sizeof(_impl_.qualified_));
  // @@protoc_insertion_point(copy_constructor:CClanMatchEventByRange)
}

inline void CClanMatchEventByRange::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.events_){arena}
    , decltype(_impl_.rtime_before_){0u}
    , decltype(_impl_.rtime_after_){0u}
    , decltype(_impl_.qualified_){0u}
  };
}

CClanMatchEventByRange::~CClanMatchEventByRange() {
  // @@protoc_insertion_point(destructor:CClanMatchEventByRange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CClanMatchEventByRange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.events_.~RepeatedPtrField();
}

void CClanMatchEventByRange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CClanMatchEventByRange::Clear() {
// @@protoc_insertion_point(message_clear_start:CClanMatchEventByRange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.events_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.rtime_before_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.qualified_) -
        reinterpret_cast<char*>(&_impl_.rtime_before_)) + sizeof(_impl_.qualified_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CClanMatchEventByRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 rtime_before = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_rtime_before(&has_bits);
          _impl_.rtime_before_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime_after = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_rtime_after(&has_bits);
          _impl_.rtime_after_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 qualified = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_qualified(&has_bits);
          _impl_.qualified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CClanEventUserNewsTuple events = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CClanMatchEventByRange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CClanMatchEventByRange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 rtime_before = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_rtime_before(), target);
  }

  // optional uint32 rtime_after = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_rtime_after(), target);
  }

  // optional uint32 qualified = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_qualified(), target);
  }

  // repeated .CClanEventUserNewsTuple events = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_events_size()); i < n; i++) {
    const auto& repfield = this->_internal_events(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CClanMatchEventByRange)
  return target;
}

size_t CClanMatchEventByRange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CClanMatchEventByRange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CClanEventUserNewsTuple events = 4;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->_impl_.events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 rtime_before = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime_before());
    }

    // optional uint32 rtime_after = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime_after());
    }

    // optional uint32 qualified = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_qualified());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CClanMatchEventByRange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CClanMatchEventByRange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CClanMatchEventByRange::GetClassData() const { return &_class_data_; }


void CClanMatchEventByRange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CClanMatchEventByRange*>(&to_msg);
  auto& from = static_cast<const CClanMatchEventByRange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CClanMatchEventByRange)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.events_.MergeFrom(from._impl_.events_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rtime_before_ = from._impl_.rtime_before_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.rtime_after_ = from._impl_.rtime_after_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.qualified_ = from._impl_.qualified_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CClanMatchEventByRange::CopyFrom(const CClanMatchEventByRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CClanMatchEventByRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CClanMatchEventByRange::IsInitialized() const {
  return true;
}

void CClanMatchEventByRange::InternalSwap(CClanMatchEventByRange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.events_.InternalSwap(&other->_impl_.events_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CClanMatchEventByRange, _impl_.qualified_)
      + sizeof(CClanMatchEventByRange::_impl_.qualified_)
      - PROTOBUF_FIELD_OFFSET(CClanMatchEventByRange, _impl_.rtime_before_)>(
          reinterpret_cast<char*>(&_impl_.rtime_before_),
          reinterpret_cast<char*>(&other->_impl_.rtime_before_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CClanMatchEventByRange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[12]);
}

// ===================================================================

class CCommunity_ClanAnnouncementInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CCommunity_ClanAnnouncementInfo>()._impl_._has_bits_);
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_clanid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_posterid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_headline(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_posttime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_updatetime(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_commentcount(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_forum_topic_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_event_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_voteupcount(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_votedowncount(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_ban_check_result(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_banned(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
};

CCommunity_ClanAnnouncementInfo::CCommunity_ClanAnnouncementInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCommunity_ClanAnnouncementInfo)
}
CCommunity_ClanAnnouncementInfo::CCommunity_ClanAnnouncementInfo(const CCommunity_ClanAnnouncementInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCommunity_ClanAnnouncementInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tags_){from._impl_.tags_}
    , decltype(_impl_.headline_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.gid_){}
    , decltype(_impl_.clanid_){}
    , decltype(_impl_.posterid_){}
    , decltype(_impl_.posttime_){}
    , decltype(_impl_.updatetime_){}
    , decltype(_impl_.commentcount_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.forum_topic_id_){}
    , decltype(_impl_.event_gid_){}
    , decltype(_impl_.voteupcount_){}
    , decltype(_impl_.hidden_){}
    , decltype(_impl_.banned_){}
    , decltype(_impl_.votedowncount_){}
    , decltype(_impl_.ban_check_result_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.headline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.headline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_headline()) {
    _this->_impl_.headline_.Set(from._internal_headline(), 
      _this->GetArenaForAllocation());
  }
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_body()) {
    _this->_impl_.body_.Set(from._internal_body(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.gid_, &from._impl_.gid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ban_check_result_) -
    reinterpret_cast<char*>(&_impl_.gid_)) + sizeof(_impl_.ban_check_result_));
  // @@protoc_insertion_point(copy_constructor:CCommunity_ClanAnnouncementInfo)
}

inline void CCommunity_ClanAnnouncementInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tags_){arena}
    , decltype(_impl_.headline_){}
    , decltype(_impl_.body_){}
    , decltype(_impl_.gid_){uint64_t{0u}}
    , decltype(_impl_.clanid_){uint64_t{0u}}
    , decltype(_impl_.posterid_){uint64_t{0u}}
    , decltype(_impl_.posttime_){0u}
    , decltype(_impl_.updatetime_){0u}
    , decltype(_impl_.commentcount_){0}
    , decltype(_impl_.language_){0}
    , decltype(_impl_.forum_topic_id_){uint64_t{0u}}
    , decltype(_impl_.event_gid_){uint64_t{0u}}
    , decltype(_impl_.voteupcount_){0}
    , decltype(_impl_.hidden_){false}
    , decltype(_impl_.banned_){false}
    , decltype(_impl_.votedowncount_){0}
    , decltype(_impl_.ban_check_result_){0}
  };
  _impl_.headline_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.headline_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.body_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.body_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCommunity_ClanAnnouncementInfo::~CCommunity_ClanAnnouncementInfo() {
  // @@protoc_insertion_point(destructor:CCommunity_ClanAnnouncementInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCommunity_ClanAnnouncementInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tags_.~RepeatedPtrField();
  _impl_.headline_.Destroy();
  _impl_.body_.Destroy();
}

void CCommunity_ClanAnnouncementInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCommunity_ClanAnnouncementInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CCommunity_ClanAnnouncementInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tags_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.headline_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.body_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.gid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.commentcount_) -
        reinterpret_cast<char*>(&_impl_.gid_)) + sizeof(_impl_.commentcount_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.language_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.ban_check_result_) -
        reinterpret_cast<char*>(&_impl_.language_)) + sizeof(_impl_.ban_check_result_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCommunity_ClanAnnouncementInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gid(&has_bits);
          _impl_.gid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 clanid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_clanid(&has_bits);
          _impl_.clanid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 posterid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_posterid(&has_bits);
          _impl_.posterid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string headline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_headline();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCommunity_ClanAnnouncementInfo.headline");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 posttime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_posttime(&has_bits);
          _impl_.posttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 updatetime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_updatetime(&has_bits);
          _impl_.updatetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string body = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_body();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCommunity_ClanAnnouncementInfo.body");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 commentcount = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_commentcount(&has_bits);
          _impl_.commentcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CCommunity_ClanAnnouncementInfo.tags");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 language = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_hidden(&has_bits);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 forum_topic_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_forum_topic_id(&has_bits);
          _impl_.forum_topic_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 event_gid = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _Internal::set_has_event_gid(&has_bits);
          _impl_.event_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 voteupcount = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_voteupcount(&has_bits);
          _impl_.voteupcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 votedowncount = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_votedowncount(&has_bits);
          _impl_.votedowncount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EBanContentCheckResult ban_check_result = 16 [default = k_EBanContentCheckResult_NotScanned];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EBanContentCheckResult_IsValid(val))) {
            _internal_set_ban_check_result(static_cast<::EBanContentCheckResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool banned = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_banned(&has_bits);
          _impl_.banned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCommunity_ClanAnnouncementInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCommunity_ClanAnnouncementInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 gid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gid(), target);
  }

  // optional uint64 clanid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_clanid(), target);
  }

  // optional uint64 posterid = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_posterid(), target);
  }

  // optional string headline = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_headline().data(), static_cast<int>(this->_internal_headline().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_ClanAnnouncementInfo.headline");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_headline(), target);
  }

  // optional uint32 posttime = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_posttime(), target);
  }

  // optional uint32 updatetime = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_updatetime(), target);
  }

  // optional string body = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_body().data(), static_cast<int>(this->_internal_body().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_ClanAnnouncementInfo.body");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_body(), target);
  }

  // optional int32 commentcount = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_commentcount(), target);
  }

  // repeated string tags = 9;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCommunity_ClanAnnouncementInfo.tags");
    target = stream->WriteString(9, s, target);
  }

  // optional int32 language = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_language(), target);
  }

  // optional bool hidden = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_hidden(), target);
  }

  // optional fixed64 forum_topic_id = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(12, this->_internal_forum_topic_id(), target);
  }

  // optional fixed64 event_gid = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(13, this->_internal_event_gid(), target);
  }

  // optional int32 voteupcount = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_voteupcount(), target);
  }

  // optional int32 votedowncount = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_votedowncount(), target);
  }

  // optional .EBanContentCheckResult ban_check_result = 16 [default = k_EBanContentCheckResult_NotScanned];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_ban_check_result(), target);
  }

  // optional bool banned = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_banned(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCommunity_ClanAnnouncementInfo)
  return target;
}

size_t CCommunity_ClanAnnouncementInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCommunity_ClanAnnouncementInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tags = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.tags_.size());
  for (int i = 0, n = _impl_.tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.tags_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string headline = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_headline());
    }

    // optional string body = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_body());
    }

    // optional uint64 gid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_gid());
    }

    // optional uint64 clanid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_clanid());
    }

    // optional uint64 posterid = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_posterid());
    }

    // optional uint32 posttime = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_posttime());
    }

    // optional uint32 updatetime = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_updatetime());
    }

    // optional int32 commentcount = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_commentcount());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 language = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_language());
    }

    // optional fixed64 forum_topic_id = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional fixed64 event_gid = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 8;
    }

    // optional int32 voteupcount = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_voteupcount());
    }

    // optional bool hidden = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool banned = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional int32 votedowncount = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_votedowncount());
    }

    // optional .EBanContentCheckResult ban_check_result = 16 [default = k_EBanContentCheckResult_NotScanned];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_ban_check_result());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCommunity_ClanAnnouncementInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCommunity_ClanAnnouncementInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCommunity_ClanAnnouncementInfo::GetClassData() const { return &_class_data_; }


void CCommunity_ClanAnnouncementInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCommunity_ClanAnnouncementInfo*>(&to_msg);
  auto& from = static_cast<const CCommunity_ClanAnnouncementInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCommunity_ClanAnnouncementInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.tags_.MergeFrom(from._impl_.tags_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_headline(from._internal_headline());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_body(from._internal_body());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.clanid_ = from._impl_.clanid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.posterid_ = from._impl_.posterid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.posttime_ = from._impl_.posttime_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.updatetime_ = from._impl_.updatetime_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.commentcount_ = from._impl_.commentcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.forum_topic_id_ = from._impl_.forum_topic_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.event_gid_ = from._impl_.event_gid_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.voteupcount_ = from._impl_.voteupcount_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.banned_ = from._impl_.banned_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.votedowncount_ = from._impl_.votedowncount_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.ban_check_result_ = from._impl_.ban_check_result_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCommunity_ClanAnnouncementInfo::CopyFrom(const CCommunity_ClanAnnouncementInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCommunity_ClanAnnouncementInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCommunity_ClanAnnouncementInfo::IsInitialized() const {
  return true;
}

void CCommunity_ClanAnnouncementInfo::InternalSwap(CCommunity_ClanAnnouncementInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.tags_.InternalSwap(&other->_impl_.tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.headline_, lhs_arena,
      &other->_impl_.headline_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.body_, lhs_arena,
      &other->_impl_.body_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCommunity_ClanAnnouncementInfo, _impl_.ban_check_result_)
      + sizeof(CCommunity_ClanAnnouncementInfo::_impl_.ban_check_result_)
      - PROTOBUF_FIELD_OFFSET(CCommunity_ClanAnnouncementInfo, _impl_.gid_)>(
          reinterpret_cast<char*>(&_impl_.gid_),
          reinterpret_cast<char*>(&other->_impl_.gid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCommunity_ClanAnnouncementInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[13]);
}

// ===================================================================

class CClanEventData::_Internal {
 public:
  using HasBits = decltype(std::declval<CClanEventData>()._impl_._has_bits_);
  static void set_has_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_clan_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_event_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_server_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_password(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rtime32_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_rtime32_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_comment_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_creator_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_last_update_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_event_notes(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_jsondata(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CCommunity_ClanAnnouncementInfo& announcement_body(const CClanEventData* msg);
  static void set_has_announcement_body(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_published(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_rtime32_visibility_start(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_rtime32_visibility_end(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_broadcaster_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_follower_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_ignore_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_forum_topic_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_rtime32_last_modified(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_news_post_gid(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_rtime_mod_reviewed(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_featured_app_tagid(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_build_id(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_build_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CCommunity_ClanAnnouncementInfo&
CClanEventData::_Internal::announcement_body(const CClanEventData* msg) {
  return *msg->_impl_.announcement_body_;
}
CClanEventData::CClanEventData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CClanEventData)
}
CClanEventData::CClanEventData(const CClanEventData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CClanEventData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.referenced_appids_){from._impl_.referenced_appids_}
    , decltype(_impl_.event_name_){}
    , decltype(_impl_.server_address_){}
    , decltype(_impl_.server_password_){}
    , decltype(_impl_.event_notes_){}
    , decltype(_impl_.jsondata_){}
    , decltype(_impl_.build_branch_){}
    , decltype(_impl_.announcement_body_){nullptr}
    , decltype(_impl_.gid_){}
    , decltype(_impl_.clan_steamid_){}
    , decltype(_impl_.appid_){}
    , decltype(_impl_.rtime32_start_time_){}
    , decltype(_impl_.rtime32_end_time_){}
    , decltype(_impl_.comment_count_){}
    , decltype(_impl_.creator_steamid_){}
    , decltype(_impl_.last_update_steamid_){}
    , decltype(_impl_.published_){}
    , decltype(_impl_.hidden_){}
    , decltype(_impl_.rtime32_visibility_start_){}
    , decltype(_impl_.rtime32_visibility_end_){}
    , decltype(_impl_.broadcaster_accountid_){}
    , decltype(_impl_.follower_count_){}
    , decltype(_impl_.ignore_count_){}
    , decltype(_impl_.forum_topic_id_){}
    , decltype(_impl_.news_post_gid_){}
    , decltype(_impl_.rtime32_last_modified_){}
    , decltype(_impl_.rtime_mod_reviewed_){}
    , decltype(_impl_.featured_app_tagid_){}
    , decltype(_impl_.build_id_){}
    , decltype(_impl_.event_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.event_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_event_name()) {
    _this->_impl_.event_name_.Set(from._internal_event_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.server_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_address()) {
    _this->_impl_.server_address_.Set(from._internal_server_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.server_password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_password()) {
    _this->_impl_.server_password_.Set(from._internal_server_password(), 
      _this->GetArenaForAllocation());
  }
  _impl_.event_notes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_notes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_event_notes()) {
    _this->_impl_.event_notes_.Set(from._internal_event_notes(), 
      _this->GetArenaForAllocation());
  }
  _impl_.jsondata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.jsondata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_jsondata()) {
    _this->_impl_.jsondata_.Set(from._internal_jsondata(), 
      _this->GetArenaForAllocation());
  }
  _impl_.build_branch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_branch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_build_branch()) {
    _this->_impl_.build_branch_.Set(from._internal_build_branch(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_announcement_body()) {
    _this->_impl_.announcement_body_ = new ::CCommunity_ClanAnnouncementInfo(*from._impl_.announcement_body_);
  }
  ::memcpy(&_impl_.gid_, &from._impl_.gid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.event_type_) -
    reinterpret_cast<char*>(&_impl_.gid_)) + sizeof(_impl_.event_type_));
  // @@protoc_insertion_point(copy_constructor:CClanEventData)
}

inline void CClanEventData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.referenced_appids_){arena}
    , decltype(_impl_.event_name_){}
    , decltype(_impl_.server_address_){}
    , decltype(_impl_.server_password_){}
    , decltype(_impl_.event_notes_){}
    , decltype(_impl_.jsondata_){}
    , decltype(_impl_.build_branch_){}
    , decltype(_impl_.announcement_body_){nullptr}
    , decltype(_impl_.gid_){uint64_t{0u}}
    , decltype(_impl_.clan_steamid_){uint64_t{0u}}
    , decltype(_impl_.appid_){0u}
    , decltype(_impl_.rtime32_start_time_){0u}
    , decltype(_impl_.rtime32_end_time_){0u}
    , decltype(_impl_.comment_count_){0}
    , decltype(_impl_.creator_steamid_){uint64_t{0u}}
    , decltype(_impl_.last_update_steamid_){uint64_t{0u}}
    , decltype(_impl_.published_){false}
    , decltype(_impl_.hidden_){false}
    , decltype(_impl_.rtime32_visibility_start_){0u}
    , decltype(_impl_.rtime32_visibility_end_){0u}
    , decltype(_impl_.broadcaster_accountid_){0u}
    , decltype(_impl_.follower_count_){0u}
    , decltype(_impl_.ignore_count_){0u}
    , decltype(_impl_.forum_topic_id_){uint64_t{0u}}
    , decltype(_impl_.news_post_gid_){uint64_t{0u}}
    , decltype(_impl_.rtime32_last_modified_){0u}
    , decltype(_impl_.rtime_mod_reviewed_){0u}
    , decltype(_impl_.featured_app_tagid_){0u}
    , decltype(_impl_.build_id_){0u}
    , decltype(_impl_.event_type_){1}
  };
  _impl_.event_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.server_password_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_password_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.event_notes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.event_notes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.jsondata_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.jsondata_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.build_branch_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.build_branch_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CClanEventData::~CClanEventData() {
  // @@protoc_insertion_point(destructor:CClanEventData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CClanEventData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.referenced_appids_.~RepeatedField();
  _impl_.event_name_.Destroy();
  _impl_.server_address_.Destroy();
  _impl_.server_password_.Destroy();
  _impl_.event_notes_.Destroy();
  _impl_.jsondata_.Destroy();
  _impl_.build_branch_.Destroy();
  if (this != internal_default_instance()) delete _impl_.announcement_body_;
}

void CClanEventData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CClanEventData::Clear() {
// @@protoc_insertion_point(message_clear_start:CClanEventData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.referenced_appids_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.event_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.server_address_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.server_password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.event_notes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.jsondata_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.build_branch_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.announcement_body_ != nullptr);
      _impl_.announcement_body_->Clear();
    }
  }
  _impl_.gid_ = uint64_t{0u};
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.clan_steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.published_) -
        reinterpret_cast<char*>(&_impl_.clan_steamid_)) + sizeof(_impl_.published_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&_impl_.hidden_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.news_post_gid_) -
        reinterpret_cast<char*>(&_impl_.hidden_)) + sizeof(_impl_.news_post_gid_));
  }
  if (cached_has_bits & 0x1f000000u) {
    ::memset(&_impl_.rtime32_last_modified_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.build_id_) -
        reinterpret_cast<char*>(&_impl_.rtime32_last_modified_)) + sizeof(_impl_.build_id_));
    _impl_.event_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CClanEventData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 gid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_gid(&has_bits);
          _impl_.gid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 clan_steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_clan_steamid(&has_bits);
          _impl_.clan_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string event_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_event_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CClanEventData.event_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .EProtoClanEventType event_type = 4 [default = k_EClanOtherEvent];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EProtoClanEventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::EProtoClanEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_appid(&has_bits);
          _impl_.appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string server_address = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_server_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CClanEventData.server_address");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string server_password = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_server_password();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CClanEventData.server_password");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_start_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_rtime32_start_time(&has_bits);
          _impl_.rtime32_start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_end_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_rtime32_end_time(&has_bits);
          _impl_.rtime32_end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 comment_count = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_comment_count(&has_bits);
          _impl_.comment_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 creator_steamid = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_creator_steamid(&has_bits);
          _impl_.creator_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 last_update_steamid = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_last_update_steamid(&has_bits);
          _impl_.last_update_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string event_notes = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_event_notes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CClanEventData.event_notes");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string jsondata = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_jsondata();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CClanEventData.jsondata");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CCommunity_ClanAnnouncementInfo announcement_body = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_announcement_body(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool published = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_published(&has_bits);
          _impl_.published_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hidden = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_hidden(&has_bits);
          _impl_.hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_visibility_start = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_rtime32_visibility_start(&has_bits);
          _impl_.rtime32_visibility_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_visibility_end = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_rtime32_visibility_end(&has_bits);
          _impl_.rtime32_visibility_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 broadcaster_accountid = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_broadcaster_accountid(&has_bits);
          _impl_.broadcaster_accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 follower_count = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_follower_count(&has_bits);
          _impl_.follower_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ignore_count = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_ignore_count(&has_bits);
          _impl_.ignore_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 forum_topic_id = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _Internal::set_has_forum_topic_id(&has_bits);
          _impl_.forum_topic_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime32_last_modified = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_rtime32_last_modified(&has_bits);
          _impl_.rtime32_last_modified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 news_post_gid = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 201)) {
          _Internal::set_has_news_post_gid(&has_bits);
          _impl_.news_post_gid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rtime_mod_reviewed = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_rtime_mod_reviewed(&has_bits);
          _impl_.rtime_mod_reviewed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 featured_app_tagid = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_featured_app_tagid(&has_bits);
          _impl_.featured_app_tagid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 referenced_appids = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_referenced_appids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<224>(ptr));
        } else if (static_cast<uint8_t>(tag) == 226) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_referenced_appids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 build_id = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_build_id(&has_bits);
          _impl_.build_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string build_branch = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          auto str = _internal_mutable_build_branch();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CClanEventData.build_branch");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CClanEventData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CClanEventData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 gid = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_gid(), target);
  }

  // optional fixed64 clan_steamid = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_clan_steamid(), target);
  }

  // optional string event_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_event_name().data(), static_cast<int>(this->_internal_event_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CClanEventData.event_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_event_name(), target);
  }

  // optional .EProtoClanEventType event_type = 4 [default = k_EClanOtherEvent];
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_event_type(), target);
  }

  // optional uint32 appid = 5;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_appid(), target);
  }

  // optional string server_address = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_server_address().data(), static_cast<int>(this->_internal_server_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CClanEventData.server_address");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_server_address(), target);
  }

  // optional string server_password = 7;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_server_password().data(), static_cast<int>(this->_internal_server_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CClanEventData.server_password");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_server_password(), target);
  }

  // optional uint32 rtime32_start_time = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_rtime32_start_time(), target);
  }

  // optional uint32 rtime32_end_time = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_rtime32_end_time(), target);
  }

  // optional int32 comment_count = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_comment_count(), target);
  }

  // optional fixed64 creator_steamid = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(11, this->_internal_creator_steamid(), target);
  }

  // optional fixed64 last_update_steamid = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(12, this->_internal_last_update_steamid(), target);
  }

  // optional string event_notes = 13;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_event_notes().data(), static_cast<int>(this->_internal_event_notes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CClanEventData.event_notes");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_event_notes(), target);
  }

  // optional string jsondata = 14;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_jsondata().data(), static_cast<int>(this->_internal_jsondata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CClanEventData.jsondata");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_jsondata(), target);
  }

  // optional .CCommunity_ClanAnnouncementInfo announcement_body = 15;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::announcement_body(this),
        _Internal::announcement_body(this).GetCachedSize(), target, stream);
  }

  // optional bool published = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_published(), target);
  }

  // optional bool hidden = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_hidden(), target);
  }

  // optional uint32 rtime32_visibility_start = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_rtime32_visibility_start(), target);
  }

  // optional uint32 rtime32_visibility_end = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_rtime32_visibility_end(), target);
  }

  // optional uint32 broadcaster_accountid = 20;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(20, this->_internal_broadcaster_accountid(), target);
  }

  // optional uint32 follower_count = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(21, this->_internal_follower_count(), target);
  }

  // optional uint32 ignore_count = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(22, this->_internal_ignore_count(), target);
  }

  // optional fixed64 forum_topic_id = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(23, this->_internal_forum_topic_id(), target);
  }

  // optional uint32 rtime32_last_modified = 24;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(24, this->_internal_rtime32_last_modified(), target);
  }

  // optional fixed64 news_post_gid = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(25, this->_internal_news_post_gid(), target);
  }

  // optional uint32 rtime_mod_reviewed = 26;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(26, this->_internal_rtime_mod_reviewed(), target);
  }

  // optional uint32 featured_app_tagid = 27;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(27, this->_internal_featured_app_tagid(), target);
  }

  // repeated uint32 referenced_appids = 28;
  for (int i = 0, n = this->_internal_referenced_appids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(28, this->_internal_referenced_appids(i), target);
  }

  // optional uint32 build_id = 29;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(29, this->_internal_build_id(), target);
  }

  // optional string build_branch = 30;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_build_branch().data(), static_cast<int>(this->_internal_build_branch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CClanEventData.build_branch");
    target = stream->WriteStringMaybeAliased(
        30, this->_internal_build_branch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CClanEventData)
  return target;
}

size_t CClanEventData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CClanEventData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 referenced_appids = 28;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.referenced_appids_);
    total_size += 2 *
                  ::_pbi::FromIntSize(this->_internal_referenced_appids_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string event_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_event_name());
    }

    // optional string server_address = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_address());
    }

    // optional string server_password = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_server_password());
    }

    // optional string event_notes = 13;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_event_notes());
    }

    // optional string jsondata = 14;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_jsondata());
    }

    // optional string build_branch = 30;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_build_branch());
    }

    // optional .CCommunity_ClanAnnouncementInfo announcement_body = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.announcement_body_);
    }

    // optional fixed64 gid = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 8;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional fixed64 clan_steamid = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 5;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 rtime32_start_time = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime32_start_time());
    }

    // optional uint32 rtime32_end_time = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_rtime32_end_time());
    }

    // optional int32 comment_count = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_comment_count());
    }

    // optional fixed64 creator_steamid = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 8;
    }

    // optional fixed64 last_update_steamid = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 8;
    }

    // optional bool published = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool hidden = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional uint32 rtime32_visibility_start = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rtime32_visibility_start());
    }

    // optional uint32 rtime32_visibility_end = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rtime32_visibility_end());
    }

    // optional uint32 broadcaster_accountid = 20;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_broadcaster_accountid());
    }

    // optional uint32 follower_count = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_follower_count());
    }

    // optional uint32 ignore_count = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_ignore_count());
    }

    // optional fixed64 forum_topic_id = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 8;
    }

    // optional fixed64 news_post_gid = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 8;
    }

  }
  if (cached_has_bits & 0x1f000000u) {
    // optional uint32 rtime32_last_modified = 24;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rtime32_last_modified());
    }

    // optional uint32 rtime_mod_reviewed = 26;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_rtime_mod_reviewed());
    }

    // optional uint32 featured_app_tagid = 27;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_featured_app_tagid());
    }

    // optional uint32 build_id = 29;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_build_id());
    }

    // optional .EProtoClanEventType event_type = 4 [default = k_EClanOtherEvent];
    if (cached_has_bits & 0x10000000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CClanEventData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CClanEventData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CClanEventData::GetClassData() const { return &_class_data_; }


void CClanEventData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CClanEventData*>(&to_msg);
  auto& from = static_cast<const CClanEventData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CClanEventData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.referenced_appids_.MergeFrom(from._impl_.referenced_appids_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_event_name(from._internal_event_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_server_address(from._internal_server_address());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_server_password(from._internal_server_password());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_event_notes(from._internal_event_notes());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_jsondata(from._internal_jsondata());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_build_branch(from._internal_build_branch());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_announcement_body()->::CCommunity_ClanAnnouncementInfo::MergeFrom(
          from._internal_announcement_body());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.gid_ = from._impl_.gid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.clan_steamid_ = from._impl_.clan_steamid_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.appid_ = from._impl_.appid_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.rtime32_start_time_ = from._impl_.rtime32_start_time_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.rtime32_end_time_ = from._impl_.rtime32_end_time_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.comment_count_ = from._impl_.comment_count_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.creator_steamid_ = from._impl_.creator_steamid_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.last_update_steamid_ = from._impl_.last_update_steamid_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.published_ = from._impl_.published_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.hidden_ = from._impl_.hidden_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.rtime32_visibility_start_ = from._impl_.rtime32_visibility_start_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.rtime32_visibility_end_ = from._impl_.rtime32_visibility_end_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.broadcaster_accountid_ = from._impl_.broadcaster_accountid_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.follower_count_ = from._impl_.follower_count_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.ignore_count_ = from._impl_.ignore_count_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.forum_topic_id_ = from._impl_.forum_topic_id_;
    }
    if (cached_has_bits & 0x00800000u) {
      _this->_impl_.news_post_gid_ = from._impl_.news_post_gid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      _this->_impl_.rtime32_last_modified_ = from._impl_.rtime32_last_modified_;
    }
    if (cached_has_bits & 0x02000000u) {
      _this->_impl_.rtime_mod_reviewed_ = from._impl_.rtime_mod_reviewed_;
    }
    if (cached_has_bits & 0x04000000u) {
      _this->_impl_.featured_app_tagid_ = from._impl_.featured_app_tagid_;
    }
    if (cached_has_bits & 0x08000000u) {
      _this->_impl_.build_id_ = from._impl_.build_id_;
    }
    if (cached_has_bits & 0x10000000u) {
      _this->_impl_.event_type_ = from._impl_.event_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CClanEventData::CopyFrom(const CClanEventData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CClanEventData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CClanEventData::IsInitialized() const {
  return true;
}

void CClanEventData::InternalSwap(CClanEventData* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.referenced_appids_.InternalSwap(&other->_impl_.referenced_appids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.event_name_, lhs_arena,
      &other->_impl_.event_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_address_, lhs_arena,
      &other->_impl_.server_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.server_password_, lhs_arena,
      &other->_impl_.server_password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.event_notes_, lhs_arena,
      &other->_impl_.event_notes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.jsondata_, lhs_arena,
      &other->_impl_.jsondata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.build_branch_, lhs_arena,
      &other->_impl_.build_branch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CClanEventData, _impl_.build_id_)
      + sizeof(CClanEventData::_impl_.build_id_)
      - PROTOBUF_FIELD_OFFSET(CClanEventData, _impl_.announcement_body_)>(
          reinterpret_cast<char*>(&_impl_.announcement_body_),
          reinterpret_cast<char*>(&other->_impl_.announcement_body_));
  swap(_impl_.event_type_, other->_impl_.event_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CClanEventData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[14]);
}

// ===================================================================

class CBilling_Address::_Internal {
 public:
  using HasBits = decltype(std::declval<CBilling_Address>()._impl_._has_bits_);
  static void set_has_first_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_last_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_address2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_city(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_us_state(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_postcode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_zip_plus4(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_phone(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CBilling_Address::CBilling_Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBilling_Address)
}
CBilling_Address::CBilling_Address(const CBilling_Address& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBilling_Address* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_name_){}
    , decltype(_impl_.last_name_){}
    , decltype(_impl_.address1_){}
    , decltype(_impl_.address2_){}
    , decltype(_impl_.city_){}
    , decltype(_impl_.us_state_){}
    , decltype(_impl_.country_code_){}
    , decltype(_impl_.postcode_){}
    , decltype(_impl_.phone_){}
    , decltype(_impl_.zip_plus4_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.first_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_first_name()) {
    _this->_impl_.first_name_.Set(from._internal_first_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.last_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_last_name()) {
    _this->_impl_.last_name_.Set(from._internal_last_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address1()) {
    _this->_impl_.address1_.Set(from._internal_address1(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_address2()) {
    _this->_impl_.address2_.Set(from._internal_address2(), 
      _this->GetArenaForAllocation());
  }
  _impl_.city_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_city()) {
    _this->_impl_.city_.Set(from._internal_city(), 
      _this->GetArenaForAllocation());
  }
  _impl_.us_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.us_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_us_state()) {
    _this->_impl_.us_state_.Set(from._internal_us_state(), 
      _this->GetArenaForAllocation());
  }
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country_code()) {
    _this->_impl_.country_code_.Set(from._internal_country_code(), 
      _this->GetArenaForAllocation());
  }
  _impl_.postcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_postcode()) {
    _this->_impl_.postcode_.Set(from._internal_postcode(), 
      _this->GetArenaForAllocation());
  }
  _impl_.phone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_phone()) {
    _this->_impl_.phone_.Set(from._internal_phone(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.zip_plus4_ = from._impl_.zip_plus4_;
  // @@protoc_insertion_point(copy_constructor:CBilling_Address)
}

inline void CBilling_Address::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.first_name_){}
    , decltype(_impl_.last_name_){}
    , decltype(_impl_.address1_){}
    , decltype(_impl_.address2_){}
    , decltype(_impl_.city_){}
    , decltype(_impl_.us_state_){}
    , decltype(_impl_.country_code_){}
    , decltype(_impl_.postcode_){}
    , decltype(_impl_.phone_){}
    , decltype(_impl_.zip_plus4_){0}
  };
  _impl_.first_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.last_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address1_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address1_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address2_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address2_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.city_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.us_state_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.us_state_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.postcode_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postcode_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.phone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CBilling_Address::~CBilling_Address() {
  // @@protoc_insertion_point(destructor:CBilling_Address)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBilling_Address::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.first_name_.Destroy();
  _impl_.last_name_.Destroy();
  _impl_.address1_.Destroy();
  _impl_.address2_.Destroy();
  _impl_.city_.Destroy();
  _impl_.us_state_.Destroy();
  _impl_.country_code_.Destroy();
  _impl_.postcode_.Destroy();
  _impl_.phone_.Destroy();
}

void CBilling_Address::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBilling_Address::Clear() {
// @@protoc_insertion_point(message_clear_start:CBilling_Address)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.first_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.last_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.address1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.address2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.city_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.us_state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      _impl_.country_code_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      _impl_.postcode_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _impl_.phone_.ClearNonDefaultToEmpty();
  }
  _impl_.zip_plus4_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBilling_Address::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string first_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_first_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.first_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string last_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_last_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.last_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string address1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_address1();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.address1");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string address2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_address2();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.address2");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string city = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_city();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.city");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string us_state = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_us_state();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.us_state");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string country_code = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.country_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string postcode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_postcode();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.postcode");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 zip_plus4 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_zip_plus4(&has_bits);
          _impl_.zip_plus4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string phone = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_phone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CBilling_Address.phone");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBilling_Address::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBilling_Address)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string first_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_first_name().data(), static_cast<int>(this->_internal_first_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.first_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_first_name(), target);
  }

  // optional string last_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_last_name().data(), static_cast<int>(this->_internal_last_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.last_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_last_name(), target);
  }

  // optional string address1 = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address1().data(), static_cast<int>(this->_internal_address1().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.address1");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_address1(), target);
  }

  // optional string address2 = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address2().data(), static_cast<int>(this->_internal_address2().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.address2");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_address2(), target);
  }

  // optional string city = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_city().data(), static_cast<int>(this->_internal_city().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.city");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_city(), target);
  }

  // optional string us_state = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_us_state().data(), static_cast<int>(this->_internal_us_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.us_state");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_us_state(), target);
  }

  // optional string country_code = 7;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country_code().data(), static_cast<int>(this->_internal_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.country_code");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_country_code(), target);
  }

  // optional string postcode = 8;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_postcode().data(), static_cast<int>(this->_internal_postcode().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.postcode");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_postcode(), target);
  }

  // optional int32 zip_plus4 = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_zip_plus4(), target);
  }

  // optional string phone = 10;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_phone().data(), static_cast<int>(this->_internal_phone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CBilling_Address.phone");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_phone(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBilling_Address)
  return target;
}

size_t CBilling_Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBilling_Address)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string first_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_first_name());
    }

    // optional string last_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_last_name());
    }

    // optional string address1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address1());
    }

    // optional string address2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address2());
    }

    // optional string city = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_city());
    }

    // optional string us_state = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_us_state());
    }

    // optional string country_code = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country_code());
    }

    // optional string postcode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_postcode());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional string phone = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_phone());
    }

    // optional int32 zip_plus4 = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_zip_plus4());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBilling_Address::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBilling_Address::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBilling_Address::GetClassData() const { return &_class_data_; }


void CBilling_Address::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBilling_Address*>(&to_msg);
  auto& from = static_cast<const CBilling_Address&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBilling_Address)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_first_name(from._internal_first_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_last_name(from._internal_last_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_address1(from._internal_address1());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_address2(from._internal_address2());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_city(from._internal_city());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_us_state(from._internal_us_state());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_set_country_code(from._internal_country_code());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_set_postcode(from._internal_postcode());
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_set_phone(from._internal_phone());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.zip_plus4_ = from._impl_.zip_plus4_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBilling_Address::CopyFrom(const CBilling_Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBilling_Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBilling_Address::IsInitialized() const {
  return true;
}

void CBilling_Address::InternalSwap(CBilling_Address* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.first_name_, lhs_arena,
      &other->_impl_.first_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.last_name_, lhs_arena,
      &other->_impl_.last_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address1_, lhs_arena,
      &other->_impl_.address1_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address2_, lhs_arena,
      &other->_impl_.address2_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.city_, lhs_arena,
      &other->_impl_.city_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.us_state_, lhs_arena,
      &other->_impl_.us_state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.country_code_, lhs_arena,
      &other->_impl_.country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.postcode_, lhs_arena,
      &other->_impl_.postcode_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.phone_, lhs_arena,
      &other->_impl_.phone_, rhs_arena
  );
  swap(_impl_.zip_plus4_, other->_impl_.zip_plus4_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CBilling_Address::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[15]);
}

// ===================================================================

class CPackageReservationStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CPackageReservationStatus>()._impl_._has_bits_);
  static void set_has_packageid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reservation_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_queue_position(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_total_queue_size(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_reservation_country_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expired(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_time_expires(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_time_reserved(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CPackageReservationStatus::CPackageReservationStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CPackageReservationStatus)
}
CPackageReservationStatus::CPackageReservationStatus(const CPackageReservationStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CPackageReservationStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reservation_country_code_){}
    , decltype(_impl_.packageid_){}
    , decltype(_impl_.reservation_state_){}
    , decltype(_impl_.queue_position_){}
    , decltype(_impl_.total_queue_size_){}
    , decltype(_impl_.expired_){}
    , decltype(_impl_.time_expires_){}
    , decltype(_impl_.time_reserved_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.reservation_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reservation_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_reservation_country_code()) {
    _this->_impl_.reservation_country_code_.Set(from._internal_reservation_country_code(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.packageid_, &from._impl_.packageid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.time_reserved_) -
    reinterpret_cast<char*>(&_impl_.packageid_)) + sizeof(_impl_.time_reserved_));
  // @@protoc_insertion_point(copy_constructor:CPackageReservationStatus)
}

inline void CPackageReservationStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.reservation_country_code_){}
    , decltype(_impl_.packageid_){0u}
    , decltype(_impl_.reservation_state_){0}
    , decltype(_impl_.queue_position_){0}
    , decltype(_impl_.total_queue_size_){0}
    , decltype(_impl_.expired_){false}
    , decltype(_impl_.time_expires_){0u}
    , decltype(_impl_.time_reserved_){0u}
  };
  _impl_.reservation_country_code_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.reservation_country_code_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CPackageReservationStatus::~CPackageReservationStatus() {
  // @@protoc_insertion_point(destructor:CPackageReservationStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CPackageReservationStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reservation_country_code_.Destroy();
}

void CPackageReservationStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CPackageReservationStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CPackageReservationStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.reservation_country_code_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.packageid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.time_reserved_) -
        reinterpret_cast<char*>(&_impl_.packageid_)) + sizeof(_impl_.time_reserved_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CPackageReservationStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 packageid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_packageid(&has_bits);
          _impl_.packageid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reservation_state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_reservation_state(&has_bits);
          _impl_.reservation_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 queue_position = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_queue_position(&has_bits);
          _impl_.queue_position_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 total_queue_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_total_queue_size(&has_bits);
          _impl_.total_queue_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string reservation_country_code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_reservation_country_code();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CPackageReservationStatus.reservation_country_code");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool expired = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_expired(&has_bits);
          _impl_.expired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_expires = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_time_expires(&has_bits);
          _impl_.time_expires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_reserved = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_time_reserved(&has_bits);
          _impl_.time_reserved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CPackageReservationStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CPackageReservationStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 packageid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_packageid(), target);
  }

  // optional int32 reservation_state = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_reservation_state(), target);
  }

  // optional int32 queue_position = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_queue_position(), target);
  }

  // optional int32 total_queue_size = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_total_queue_size(), target);
  }

  // optional string reservation_country_code = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_reservation_country_code().data(), static_cast<int>(this->_internal_reservation_country_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CPackageReservationStatus.reservation_country_code");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_reservation_country_code(), target);
  }

  // optional bool expired = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_expired(), target);
  }

  // optional uint32 time_expires = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_time_expires(), target);
  }

  // optional uint32 time_reserved = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_time_reserved(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CPackageReservationStatus)
  return target;
}

size_t CPackageReservationStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CPackageReservationStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string reservation_country_code = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_reservation_country_code());
    }

    // optional uint32 packageid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_packageid());
    }

    // optional int32 reservation_state = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reservation_state());
    }

    // optional int32 queue_position = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_queue_position());
    }

    // optional int32 total_queue_size = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total_queue_size());
    }

    // optional bool expired = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional uint32 time_expires = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_expires());
    }

    // optional uint32 time_reserved = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_time_reserved());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CPackageReservationStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CPackageReservationStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CPackageReservationStatus::GetClassData() const { return &_class_data_; }


void CPackageReservationStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CPackageReservationStatus*>(&to_msg);
  auto& from = static_cast<const CPackageReservationStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CPackageReservationStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_reservation_country_code(from._internal_reservation_country_code());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.packageid_ = from._impl_.packageid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.reservation_state_ = from._impl_.reservation_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.queue_position_ = from._impl_.queue_position_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.total_queue_size_ = from._impl_.total_queue_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.expired_ = from._impl_.expired_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.time_expires_ = from._impl_.time_expires_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.time_reserved_ = from._impl_.time_reserved_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CPackageReservationStatus::CopyFrom(const CPackageReservationStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CPackageReservationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPackageReservationStatus::IsInitialized() const {
  return true;
}

void CPackageReservationStatus::InternalSwap(CPackageReservationStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.reservation_country_code_, lhs_arena,
      &other->_impl_.reservation_country_code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CPackageReservationStatus, _impl_.time_reserved_)
      + sizeof(CPackageReservationStatus::_impl_.time_reserved_)
      - PROTOBUF_FIELD_OFFSET(CPackageReservationStatus, _impl_.packageid_)>(
          reinterpret_cast<char*>(&_impl_.packageid_),
          reinterpret_cast<char*>(&other->_impl_.packageid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CPackageReservationStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[16]);
}

// ===================================================================

class CMsgKeyValuePair::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgKeyValuePair>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgKeyValuePair::CMsgKeyValuePair(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgKeyValuePair)
}
CMsgKeyValuePair::CMsgKeyValuePair(const CMsgKeyValuePair& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgKeyValuePair* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgKeyValuePair)
}

inline void CMsgKeyValuePair::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgKeyValuePair::~CMsgKeyValuePair() {
  // @@protoc_insertion_point(destructor:CMsgKeyValuePair)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgKeyValuePair::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CMsgKeyValuePair::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgKeyValuePair::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgKeyValuePair)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgKeyValuePair::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgKeyValuePair.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgKeyValuePair.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgKeyValuePair::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgKeyValuePair)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgKeyValuePair.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgKeyValuePair.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgKeyValuePair)
  return target;
}

size_t CMsgKeyValuePair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgKeyValuePair)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgKeyValuePair::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgKeyValuePair::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgKeyValuePair::GetClassData() const { return &_class_data_; }


void CMsgKeyValuePair::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgKeyValuePair*>(&to_msg);
  auto& from = static_cast<const CMsgKeyValuePair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgKeyValuePair)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgKeyValuePair::CopyFrom(const CMsgKeyValuePair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgKeyValuePair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgKeyValuePair::IsInitialized() const {
  return true;
}

void CMsgKeyValuePair::InternalSwap(CMsgKeyValuePair* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgKeyValuePair::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[17]);
}

// ===================================================================

class CMsgKeyValueSet::_Internal {
 public:
};

CMsgKeyValueSet::CMsgKeyValueSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgKeyValueSet)
}
CMsgKeyValueSet::CMsgKeyValueSet(const CMsgKeyValueSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgKeyValueSet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.pairs_){from._impl_.pairs_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgKeyValueSet)
}

inline void CMsgKeyValueSet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.pairs_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgKeyValueSet::~CMsgKeyValueSet() {
  // @@protoc_insertion_point(destructor:CMsgKeyValueSet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgKeyValueSet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pairs_.~RepeatedPtrField();
}

void CMsgKeyValueSet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgKeyValueSet::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgKeyValueSet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pairs_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgKeyValueSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgKeyValuePair pairs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pairs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgKeyValueSet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgKeyValueSet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgKeyValuePair pairs = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pairs_size()); i < n; i++) {
    const auto& repfield = this->_internal_pairs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgKeyValueSet)
  return target;
}

size_t CMsgKeyValueSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgKeyValueSet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgKeyValuePair pairs = 1;
  total_size += 1UL * this->_internal_pairs_size();
  for (const auto& msg : this->_impl_.pairs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgKeyValueSet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgKeyValueSet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgKeyValueSet::GetClassData() const { return &_class_data_; }


void CMsgKeyValueSet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgKeyValueSet*>(&to_msg);
  auto& from = static_cast<const CMsgKeyValueSet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgKeyValueSet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pairs_.MergeFrom(from._impl_.pairs_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgKeyValueSet::CopyFrom(const CMsgKeyValueSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgKeyValueSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgKeyValueSet::IsInitialized() const {
  return true;
}

void CMsgKeyValueSet::InternalSwap(CMsgKeyValueSet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.pairs_.InternalSwap(&other->_impl_.pairs_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgKeyValueSet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[18]);
}

// ===================================================================

class UserContentDescriptorPreferences_ContentDescriptor::_Internal {
 public:
  using HasBits = decltype(std::declval<UserContentDescriptorPreferences_ContentDescriptor>()._impl_._has_bits_);
  static void set_has_content_descriptorid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp_added(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

UserContentDescriptorPreferences_ContentDescriptor::UserContentDescriptorPreferences_ContentDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UserContentDescriptorPreferences.ContentDescriptor)
}
UserContentDescriptorPreferences_ContentDescriptor::UserContentDescriptorPreferences_ContentDescriptor(const UserContentDescriptorPreferences_ContentDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserContentDescriptorPreferences_ContentDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_descriptorid_){}
    , decltype(_impl_.timestamp_added_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.content_descriptorid_, &from._impl_.content_descriptorid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.timestamp_added_) -
    reinterpret_cast<char*>(&_impl_.content_descriptorid_)) + sizeof(_impl_.timestamp_added_));
  // @@protoc_insertion_point(copy_constructor:UserContentDescriptorPreferences.ContentDescriptor)
}

inline void UserContentDescriptorPreferences_ContentDescriptor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.content_descriptorid_){0u}
    , decltype(_impl_.timestamp_added_){0u}
  };
}

UserContentDescriptorPreferences_ContentDescriptor::~UserContentDescriptorPreferences_ContentDescriptor() {
  // @@protoc_insertion_point(destructor:UserContentDescriptorPreferences.ContentDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserContentDescriptorPreferences_ContentDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserContentDescriptorPreferences_ContentDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserContentDescriptorPreferences_ContentDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:UserContentDescriptorPreferences.ContentDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.content_descriptorid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.timestamp_added_) -
        reinterpret_cast<char*>(&_impl_.content_descriptorid_)) + sizeof(_impl_.timestamp_added_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserContentDescriptorPreferences_ContentDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 content_descriptorid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_content_descriptorid(&has_bits);
          _impl_.content_descriptorid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp_added = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp_added(&has_bits);
          _impl_.timestamp_added_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserContentDescriptorPreferences_ContentDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UserContentDescriptorPreferences.ContentDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 content_descriptorid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_content_descriptorid(), target);
  }

  // optional uint32 timestamp_added = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp_added(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UserContentDescriptorPreferences.ContentDescriptor)
  return target;
}

size_t UserContentDescriptorPreferences_ContentDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UserContentDescriptorPreferences.ContentDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 content_descriptorid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_content_descriptorid());
    }

    // optional uint32 timestamp_added = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp_added());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserContentDescriptorPreferences_ContentDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserContentDescriptorPreferences_ContentDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserContentDescriptorPreferences_ContentDescriptor::GetClassData() const { return &_class_data_; }


void UserContentDescriptorPreferences_ContentDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserContentDescriptorPreferences_ContentDescriptor*>(&to_msg);
  auto& from = static_cast<const UserContentDescriptorPreferences_ContentDescriptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UserContentDescriptorPreferences.ContentDescriptor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.content_descriptorid_ = from._impl_.content_descriptorid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.timestamp_added_ = from._impl_.timestamp_added_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserContentDescriptorPreferences_ContentDescriptor::CopyFrom(const UserContentDescriptorPreferences_ContentDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UserContentDescriptorPreferences.ContentDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserContentDescriptorPreferences_ContentDescriptor::IsInitialized() const {
  return true;
}

void UserContentDescriptorPreferences_ContentDescriptor::InternalSwap(UserContentDescriptorPreferences_ContentDescriptor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UserContentDescriptorPreferences_ContentDescriptor, _impl_.timestamp_added_)
      + sizeof(UserContentDescriptorPreferences_ContentDescriptor::_impl_.timestamp_added_)
      - PROTOBUF_FIELD_OFFSET(UserContentDescriptorPreferences_ContentDescriptor, _impl_.content_descriptorid_)>(
          reinterpret_cast<char*>(&_impl_.content_descriptorid_),
          reinterpret_cast<char*>(&other->_impl_.content_descriptorid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UserContentDescriptorPreferences_ContentDescriptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[19]);
}

// ===================================================================

class UserContentDescriptorPreferences::_Internal {
 public:
};

UserContentDescriptorPreferences::UserContentDescriptorPreferences(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UserContentDescriptorPreferences)
}
UserContentDescriptorPreferences::UserContentDescriptorPreferences(const UserContentDescriptorPreferences& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserContentDescriptorPreferences* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.content_descriptors_to_exclude_){from._impl_.content_descriptors_to_exclude_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:UserContentDescriptorPreferences)
}

inline void UserContentDescriptorPreferences::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.content_descriptors_to_exclude_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UserContentDescriptorPreferences::~UserContentDescriptorPreferences() {
  // @@protoc_insertion_point(destructor:UserContentDescriptorPreferences)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserContentDescriptorPreferences::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.content_descriptors_to_exclude_.~RepeatedPtrField();
}

void UserContentDescriptorPreferences::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserContentDescriptorPreferences::Clear() {
// @@protoc_insertion_point(message_clear_start:UserContentDescriptorPreferences)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.content_descriptors_to_exclude_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserContentDescriptorPreferences::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .UserContentDescriptorPreferences.ContentDescriptor content_descriptors_to_exclude = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_content_descriptors_to_exclude(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserContentDescriptorPreferences::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UserContentDescriptorPreferences)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .UserContentDescriptorPreferences.ContentDescriptor content_descriptors_to_exclude = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_content_descriptors_to_exclude_size()); i < n; i++) {
    const auto& repfield = this->_internal_content_descriptors_to_exclude(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UserContentDescriptorPreferences)
  return target;
}

size_t UserContentDescriptorPreferences::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UserContentDescriptorPreferences)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .UserContentDescriptorPreferences.ContentDescriptor content_descriptors_to_exclude = 1;
  total_size += 1UL * this->_internal_content_descriptors_to_exclude_size();
  for (const auto& msg : this->_impl_.content_descriptors_to_exclude_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserContentDescriptorPreferences::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserContentDescriptorPreferences::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserContentDescriptorPreferences::GetClassData() const { return &_class_data_; }


void UserContentDescriptorPreferences::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserContentDescriptorPreferences*>(&to_msg);
  auto& from = static_cast<const UserContentDescriptorPreferences&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UserContentDescriptorPreferences)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.content_descriptors_to_exclude_.MergeFrom(from._impl_.content_descriptors_to_exclude_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserContentDescriptorPreferences::CopyFrom(const UserContentDescriptorPreferences& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UserContentDescriptorPreferences)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserContentDescriptorPreferences::IsInitialized() const {
  return true;
}

void UserContentDescriptorPreferences::InternalSwap(UserContentDescriptorPreferences* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.content_descriptors_to_exclude_.InternalSwap(&other->_impl_.content_descriptors_to_exclude_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserContentDescriptorPreferences::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_steammessages_5fbase_2eproto_getter, &descriptor_table_steammessages_5fbase_2eproto_once,
      file_level_metadata_steammessages_5fbase_2eproto[20]);
}
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< int32_t >, 5, false>
  msgpool_soft_limit(kMsgpoolSoftLimitFieldNumber, 32, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< int32_t >, 5, false>
  msgpool_hard_limit(kMsgpoolHardLimitFieldNumber, 384, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false>
  force_php_generation(kForcePhpGenerationFieldNumber, false, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false>
  php_output_always_number(kPhpOutputAlwaysNumberFieldNumber, false, nullptr);
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false>
  allow_field_named_steam_id(kAllowFieldNamedSteamIdFieldNumber, false, nullptr);

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgIPAddress*
Arena::CreateMaybeMessage< ::CMsgIPAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgIPAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgIPAddressBucket*
Arena::CreateMaybeMessage< ::CMsgIPAddressBucket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgIPAddressBucket >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCRoutingProtoBufHeader*
Arena::CreateMaybeMessage< ::CMsgGCRoutingProtoBufHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCRoutingProtoBufHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgProtoBufHeader*
Arena::CreateMaybeMessage< ::CMsgProtoBufHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgProtoBufHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMulti*
Arena::CreateMaybeMessage< ::CMsgMulti >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMulti >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgProtobufWrapped*
Arena::CreateMaybeMessage< ::CMsgProtobufWrapped >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgProtobufWrapped >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAuthTicket*
Arena::CreateMaybeMessage< ::CMsgAuthTicket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAuthTicket >(arena);
}
template<> PROTOBUF_NOINLINE ::CCDDBAppDetailCommon*
Arena::CreateMaybeMessage< ::CCDDBAppDetailCommon >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCDDBAppDetailCommon >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAppRights*
Arena::CreateMaybeMessage< ::CMsgAppRights >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAppRights >(arena);
}
template<> PROTOBUF_NOINLINE ::CCuratorPreferences*
Arena::CreateMaybeMessage< ::CCuratorPreferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCuratorPreferences >(arena);
}
template<> PROTOBUF_NOINLINE ::CLocalizationToken*
Arena::CreateMaybeMessage< ::CLocalizationToken >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CLocalizationToken >(arena);
}
template<> PROTOBUF_NOINLINE ::CClanEventUserNewsTuple*
Arena::CreateMaybeMessage< ::CClanEventUserNewsTuple >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CClanEventUserNewsTuple >(arena);
}
template<> PROTOBUF_NOINLINE ::CClanMatchEventByRange*
Arena::CreateMaybeMessage< ::CClanMatchEventByRange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CClanMatchEventByRange >(arena);
}
template<> PROTOBUF_NOINLINE ::CCommunity_ClanAnnouncementInfo*
Arena::CreateMaybeMessage< ::CCommunity_ClanAnnouncementInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCommunity_ClanAnnouncementInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CClanEventData*
Arena::CreateMaybeMessage< ::CClanEventData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CClanEventData >(arena);
}
template<> PROTOBUF_NOINLINE ::CBilling_Address*
Arena::CreateMaybeMessage< ::CBilling_Address >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBilling_Address >(arena);
}
template<> PROTOBUF_NOINLINE ::CPackageReservationStatus*
Arena::CreateMaybeMessage< ::CPackageReservationStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CPackageReservationStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgKeyValuePair*
Arena::CreateMaybeMessage< ::CMsgKeyValuePair >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgKeyValuePair >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgKeyValueSet*
Arena::CreateMaybeMessage< ::CMsgKeyValueSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgKeyValueSet >(arena);
}
template<> PROTOBUF_NOINLINE ::UserContentDescriptorPreferences_ContentDescriptor*
Arena::CreateMaybeMessage< ::UserContentDescriptorPreferences_ContentDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UserContentDescriptorPreferences_ContentDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::UserContentDescriptorPreferences*
Arena::CreateMaybeMessage< ::UserContentDescriptorPreferences >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UserContentDescriptorPreferences >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
