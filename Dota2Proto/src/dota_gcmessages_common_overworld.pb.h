// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_common_overworld.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5foverworld_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5foverworld_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages.pb.h"
#include "dota_shared_enums.pb.h"
#include "dota_gcmessages_common.pb.h"
#include "gcsdk_gcmessages.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dota_5fgcmessages_5fcommon_5foverworld_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
class CMsgClientToGCOverworldClaimEncounterReward;
struct CMsgClientToGCOverworldClaimEncounterRewardDefaultTypeInternal;
extern CMsgClientToGCOverworldClaimEncounterRewardDefaultTypeInternal _CMsgClientToGCOverworldClaimEncounterReward_default_instance_;
class CMsgClientToGCOverworldClaimEncounterRewardResponse;
struct CMsgClientToGCOverworldClaimEncounterRewardResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldClaimEncounterRewardResponseDefaultTypeInternal _CMsgClientToGCOverworldClaimEncounterRewardResponse_default_instance_;
class CMsgClientToGCOverworldCompletePath;
struct CMsgClientToGCOverworldCompletePathDefaultTypeInternal;
extern CMsgClientToGCOverworldCompletePathDefaultTypeInternal _CMsgClientToGCOverworldCompletePath_default_instance_;
class CMsgClientToGCOverworldCompletePathResponse;
struct CMsgClientToGCOverworldCompletePathResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldCompletePathResponseDefaultTypeInternal _CMsgClientToGCOverworldCompletePathResponse_default_instance_;
class CMsgClientToGCOverworldDevClearInventory;
struct CMsgClientToGCOverworldDevClearInventoryDefaultTypeInternal;
extern CMsgClientToGCOverworldDevClearInventoryDefaultTypeInternal _CMsgClientToGCOverworldDevClearInventory_default_instance_;
class CMsgClientToGCOverworldDevClearInventoryResponse;
struct CMsgClientToGCOverworldDevClearInventoryResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldDevClearInventoryResponseDefaultTypeInternal _CMsgClientToGCOverworldDevClearInventoryResponse_default_instance_;
class CMsgClientToGCOverworldDevGrantTokens;
struct CMsgClientToGCOverworldDevGrantTokensDefaultTypeInternal;
extern CMsgClientToGCOverworldDevGrantTokensDefaultTypeInternal _CMsgClientToGCOverworldDevGrantTokens_default_instance_;
class CMsgClientToGCOverworldDevGrantTokensResponse;
struct CMsgClientToGCOverworldDevGrantTokensResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldDevGrantTokensResponseDefaultTypeInternal _CMsgClientToGCOverworldDevGrantTokensResponse_default_instance_;
class CMsgClientToGCOverworldDevResetAll;
struct CMsgClientToGCOverworldDevResetAllDefaultTypeInternal;
extern CMsgClientToGCOverworldDevResetAllDefaultTypeInternal _CMsgClientToGCOverworldDevResetAll_default_instance_;
class CMsgClientToGCOverworldDevResetAllResponse;
struct CMsgClientToGCOverworldDevResetAllResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldDevResetAllResponseDefaultTypeInternal _CMsgClientToGCOverworldDevResetAllResponse_default_instance_;
class CMsgClientToGCOverworldDevResetNode;
struct CMsgClientToGCOverworldDevResetNodeDefaultTypeInternal;
extern CMsgClientToGCOverworldDevResetNodeDefaultTypeInternal _CMsgClientToGCOverworldDevResetNode_default_instance_;
class CMsgClientToGCOverworldDevResetNodeResponse;
struct CMsgClientToGCOverworldDevResetNodeResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldDevResetNodeResponseDefaultTypeInternal _CMsgClientToGCOverworldDevResetNodeResponse_default_instance_;
class CMsgClientToGCOverworldFeedback;
struct CMsgClientToGCOverworldFeedbackDefaultTypeInternal;
extern CMsgClientToGCOverworldFeedbackDefaultTypeInternal _CMsgClientToGCOverworldFeedback_default_instance_;
class CMsgClientToGCOverworldFeedbackResponse;
struct CMsgClientToGCOverworldFeedbackResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldFeedbackResponseDefaultTypeInternal _CMsgClientToGCOverworldFeedbackResponse_default_instance_;
class CMsgClientToGCOverworldGetDynamicImage;
struct CMsgClientToGCOverworldGetDynamicImageDefaultTypeInternal;
extern CMsgClientToGCOverworldGetDynamicImageDefaultTypeInternal _CMsgClientToGCOverworldGetDynamicImage_default_instance_;
class CMsgClientToGCOverworldGetDynamicImageResponse;
struct CMsgClientToGCOverworldGetDynamicImageResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldGetDynamicImageResponseDefaultTypeInternal _CMsgClientToGCOverworldGetDynamicImageResponse_default_instance_;
class CMsgClientToGCOverworldGetDynamicImageResponse_Image;
struct CMsgClientToGCOverworldGetDynamicImageResponse_ImageDefaultTypeInternal;
extern CMsgClientToGCOverworldGetDynamicImageResponse_ImageDefaultTypeInternal _CMsgClientToGCOverworldGetDynamicImageResponse_Image_default_instance_;
class CMsgClientToGCOverworldGetUserData;
struct CMsgClientToGCOverworldGetUserDataDefaultTypeInternal;
extern CMsgClientToGCOverworldGetUserDataDefaultTypeInternal _CMsgClientToGCOverworldGetUserData_default_instance_;
class CMsgClientToGCOverworldGetUserDataResponse;
struct CMsgClientToGCOverworldGetUserDataResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldGetUserDataResponseDefaultTypeInternal _CMsgClientToGCOverworldGetUserDataResponse_default_instance_;
class CMsgClientToGCOverworldGiftTokens;
struct CMsgClientToGCOverworldGiftTokensDefaultTypeInternal;
extern CMsgClientToGCOverworldGiftTokensDefaultTypeInternal _CMsgClientToGCOverworldGiftTokens_default_instance_;
class CMsgClientToGCOverworldGiftTokensResponse;
struct CMsgClientToGCOverworldGiftTokensResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldGiftTokensResponseDefaultTypeInternal _CMsgClientToGCOverworldGiftTokensResponse_default_instance_;
class CMsgClientToGCOverworldMoveToNode;
struct CMsgClientToGCOverworldMoveToNodeDefaultTypeInternal;
extern CMsgClientToGCOverworldMoveToNodeDefaultTypeInternal _CMsgClientToGCOverworldMoveToNode_default_instance_;
class CMsgClientToGCOverworldMoveToNodeResponse;
struct CMsgClientToGCOverworldMoveToNodeResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldMoveToNodeResponseDefaultTypeInternal _CMsgClientToGCOverworldMoveToNodeResponse_default_instance_;
class CMsgClientToGCOverworldTradeTokens;
struct CMsgClientToGCOverworldTradeTokensDefaultTypeInternal;
extern CMsgClientToGCOverworldTradeTokensDefaultTypeInternal _CMsgClientToGCOverworldTradeTokens_default_instance_;
class CMsgClientToGCOverworldTradeTokensResponse;
struct CMsgClientToGCOverworldTradeTokensResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldTradeTokensResponseDefaultTypeInternal _CMsgClientToGCOverworldTradeTokensResponse_default_instance_;
class CMsgClientToGCOverworldVisitEncounter;
struct CMsgClientToGCOverworldVisitEncounterDefaultTypeInternal;
extern CMsgClientToGCOverworldVisitEncounterDefaultTypeInternal _CMsgClientToGCOverworldVisitEncounter_default_instance_;
class CMsgClientToGCOverworldVisitEncounterResponse;
struct CMsgClientToGCOverworldVisitEncounterResponseDefaultTypeInternal;
extern CMsgClientToGCOverworldVisitEncounterResponseDefaultTypeInternal _CMsgClientToGCOverworldVisitEncounterResponse_default_instance_;
class CMsgGCToClientOverworldUserDataUpdated;
struct CMsgGCToClientOverworldUserDataUpdatedDefaultTypeInternal;
extern CMsgGCToClientOverworldUserDataUpdatedDefaultTypeInternal _CMsgGCToClientOverworldUserDataUpdated_default_instance_;
class CMsgOverworldEncounterChooseHeroData;
struct CMsgOverworldEncounterChooseHeroDataDefaultTypeInternal;
extern CMsgOverworldEncounterChooseHeroDataDefaultTypeInternal _CMsgOverworldEncounterChooseHeroData_default_instance_;
class CMsgOverworldEncounterData;
struct CMsgOverworldEncounterDataDefaultTypeInternal;
extern CMsgOverworldEncounterDataDefaultTypeInternal _CMsgOverworldEncounterData_default_instance_;
class CMsgOverworldEncounterPitFighterRewardData;
struct CMsgOverworldEncounterPitFighterRewardDataDefaultTypeInternal;
extern CMsgOverworldEncounterPitFighterRewardDataDefaultTypeInternal _CMsgOverworldEncounterPitFighterRewardData_default_instance_;
class CMsgOverworldEncounterProgressData;
struct CMsgOverworldEncounterProgressDataDefaultTypeInternal;
extern CMsgOverworldEncounterProgressDataDefaultTypeInternal _CMsgOverworldEncounterProgressData_default_instance_;
class CMsgOverworldEncounterTokenQuestData;
struct CMsgOverworldEncounterTokenQuestDataDefaultTypeInternal;
extern CMsgOverworldEncounterTokenQuestDataDefaultTypeInternal _CMsgOverworldEncounterTokenQuestData_default_instance_;
class CMsgOverworldEncounterTokenQuestData_Quest;
struct CMsgOverworldEncounterTokenQuestData_QuestDefaultTypeInternal;
extern CMsgOverworldEncounterTokenQuestData_QuestDefaultTypeInternal _CMsgOverworldEncounterTokenQuestData_Quest_default_instance_;
class CMsgOverworldEncounterTokenTreasureData;
struct CMsgOverworldEncounterTokenTreasureDataDefaultTypeInternal;
extern CMsgOverworldEncounterTokenTreasureDataDefaultTypeInternal _CMsgOverworldEncounterTokenTreasureData_default_instance_;
class CMsgOverworldEncounterTokenTreasureData_RewardOption;
struct CMsgOverworldEncounterTokenTreasureData_RewardOptionDefaultTypeInternal;
extern CMsgOverworldEncounterTokenTreasureData_RewardOptionDefaultTypeInternal _CMsgOverworldEncounterTokenTreasureData_RewardOption_default_instance_;
class CMsgOverworldHeroList;
struct CMsgOverworldHeroListDefaultTypeInternal;
extern CMsgOverworldHeroListDefaultTypeInternal _CMsgOverworldHeroList_default_instance_;
class CMsgOverworldMatchRewards;
struct CMsgOverworldMatchRewardsDefaultTypeInternal;
extern CMsgOverworldMatchRewardsDefaultTypeInternal _CMsgOverworldMatchRewards_default_instance_;
class CMsgOverworldMatchRewards_Player;
struct CMsgOverworldMatchRewards_PlayerDefaultTypeInternal;
extern CMsgOverworldMatchRewards_PlayerDefaultTypeInternal _CMsgOverworldMatchRewards_Player_default_instance_;
class CMsgOverworldNode;
struct CMsgOverworldNodeDefaultTypeInternal;
extern CMsgOverworldNodeDefaultTypeInternal _CMsgOverworldNode_default_instance_;
class CMsgOverworldPath;
struct CMsgOverworldPathDefaultTypeInternal;
extern CMsgOverworldPathDefaultTypeInternal _CMsgOverworldPath_default_instance_;
class CMsgOverworldTokenCount;
struct CMsgOverworldTokenCountDefaultTypeInternal;
extern CMsgOverworldTokenCountDefaultTypeInternal _CMsgOverworldTokenCount_default_instance_;
class CMsgOverworldTokenQuantity;
struct CMsgOverworldTokenQuantityDefaultTypeInternal;
extern CMsgOverworldTokenQuantityDefaultTypeInternal _CMsgOverworldTokenQuantity_default_instance_;
class CMsgOverworldUserData;
struct CMsgOverworldUserDataDefaultTypeInternal;
extern CMsgOverworldUserDataDefaultTypeInternal _CMsgOverworldUserData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgClientToGCOverworldClaimEncounterReward* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldClaimEncounterReward>(Arena*);
template<> ::CMsgClientToGCOverworldClaimEncounterRewardResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldClaimEncounterRewardResponse>(Arena*);
template<> ::CMsgClientToGCOverworldCompletePath* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldCompletePath>(Arena*);
template<> ::CMsgClientToGCOverworldCompletePathResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldCompletePathResponse>(Arena*);
template<> ::CMsgClientToGCOverworldDevClearInventory* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevClearInventory>(Arena*);
template<> ::CMsgClientToGCOverworldDevClearInventoryResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevClearInventoryResponse>(Arena*);
template<> ::CMsgClientToGCOverworldDevGrantTokens* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevGrantTokens>(Arena*);
template<> ::CMsgClientToGCOverworldDevGrantTokensResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevGrantTokensResponse>(Arena*);
template<> ::CMsgClientToGCOverworldDevResetAll* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevResetAll>(Arena*);
template<> ::CMsgClientToGCOverworldDevResetAllResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevResetAllResponse>(Arena*);
template<> ::CMsgClientToGCOverworldDevResetNode* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevResetNode>(Arena*);
template<> ::CMsgClientToGCOverworldDevResetNodeResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldDevResetNodeResponse>(Arena*);
template<> ::CMsgClientToGCOverworldFeedback* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldFeedback>(Arena*);
template<> ::CMsgClientToGCOverworldFeedbackResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldFeedbackResponse>(Arena*);
template<> ::CMsgClientToGCOverworldGetDynamicImage* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGetDynamicImage>(Arena*);
template<> ::CMsgClientToGCOverworldGetDynamicImageResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGetDynamicImageResponse>(Arena*);
template<> ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGetDynamicImageResponse_Image>(Arena*);
template<> ::CMsgClientToGCOverworldGetUserData* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGetUserData>(Arena*);
template<> ::CMsgClientToGCOverworldGetUserDataResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGetUserDataResponse>(Arena*);
template<> ::CMsgClientToGCOverworldGiftTokens* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGiftTokens>(Arena*);
template<> ::CMsgClientToGCOverworldGiftTokensResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldGiftTokensResponse>(Arena*);
template<> ::CMsgClientToGCOverworldMoveToNode* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldMoveToNode>(Arena*);
template<> ::CMsgClientToGCOverworldMoveToNodeResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldMoveToNodeResponse>(Arena*);
template<> ::CMsgClientToGCOverworldTradeTokens* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldTradeTokens>(Arena*);
template<> ::CMsgClientToGCOverworldTradeTokensResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldTradeTokensResponse>(Arena*);
template<> ::CMsgClientToGCOverworldVisitEncounter* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldVisitEncounter>(Arena*);
template<> ::CMsgClientToGCOverworldVisitEncounterResponse* Arena::CreateMaybeMessage<::CMsgClientToGCOverworldVisitEncounterResponse>(Arena*);
template<> ::CMsgGCToClientOverworldUserDataUpdated* Arena::CreateMaybeMessage<::CMsgGCToClientOverworldUserDataUpdated>(Arena*);
template<> ::CMsgOverworldEncounterChooseHeroData* Arena::CreateMaybeMessage<::CMsgOverworldEncounterChooseHeroData>(Arena*);
template<> ::CMsgOverworldEncounterData* Arena::CreateMaybeMessage<::CMsgOverworldEncounterData>(Arena*);
template<> ::CMsgOverworldEncounterPitFighterRewardData* Arena::CreateMaybeMessage<::CMsgOverworldEncounterPitFighterRewardData>(Arena*);
template<> ::CMsgOverworldEncounterProgressData* Arena::CreateMaybeMessage<::CMsgOverworldEncounterProgressData>(Arena*);
template<> ::CMsgOverworldEncounterTokenQuestData* Arena::CreateMaybeMessage<::CMsgOverworldEncounterTokenQuestData>(Arena*);
template<> ::CMsgOverworldEncounterTokenQuestData_Quest* Arena::CreateMaybeMessage<::CMsgOverworldEncounterTokenQuestData_Quest>(Arena*);
template<> ::CMsgOverworldEncounterTokenTreasureData* Arena::CreateMaybeMessage<::CMsgOverworldEncounterTokenTreasureData>(Arena*);
template<> ::CMsgOverworldEncounterTokenTreasureData_RewardOption* Arena::CreateMaybeMessage<::CMsgOverworldEncounterTokenTreasureData_RewardOption>(Arena*);
template<> ::CMsgOverworldHeroList* Arena::CreateMaybeMessage<::CMsgOverworldHeroList>(Arena*);
template<> ::CMsgOverworldMatchRewards* Arena::CreateMaybeMessage<::CMsgOverworldMatchRewards>(Arena*);
template<> ::CMsgOverworldMatchRewards_Player* Arena::CreateMaybeMessage<::CMsgOverworldMatchRewards_Player>(Arena*);
template<> ::CMsgOverworldNode* Arena::CreateMaybeMessage<::CMsgOverworldNode>(Arena*);
template<> ::CMsgOverworldPath* Arena::CreateMaybeMessage<::CMsgOverworldPath>(Arena*);
template<> ::CMsgOverworldTokenCount* Arena::CreateMaybeMessage<::CMsgOverworldTokenCount>(Arena*);
template<> ::CMsgOverworldTokenQuantity* Arena::CreateMaybeMessage<::CMsgOverworldTokenQuantity>(Arena*);
template<> ::CMsgOverworldUserData* Arena::CreateMaybeMessage<::CMsgOverworldUserData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CMsgClientToGCOverworldGetUserDataResponse_EResponse : int {
  CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eInvalidOverworld = 5
};
bool CMsgClientToGCOverworldGetUserDataResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eInvalidOverworld;
constexpr int CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldGetUserDataResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldGetUserDataResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldGetUserDataResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldGetUserDataResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldGetUserDataResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldGetUserDataResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldGetUserDataResponse_EResponse>(
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldCompletePathResponse_EResponse : int {
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInvalidOverworld = 5,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInvalidPath = 6,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eNotEnoughTokens = 7,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_ePathIsLocked = 8,
  CMsgClientToGCOverworldCompletePathResponse_EResponse_k_ePathAlreadyUnlocked = 9
};
bool CMsgClientToGCOverworldCompletePathResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldCompletePathResponse_EResponse_k_ePathAlreadyUnlocked;
constexpr int CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldCompletePathResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldCompletePathResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldCompletePathResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldCompletePathResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldCompletePathResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldCompletePathResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldCompletePathResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldCompletePathResponse_EResponse>(
    CMsgClientToGCOverworldCompletePathResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse : int {
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidOverworld = 5,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidNode = 6,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNodeLocked = 7,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eRewardAlreadyClaimed = 8,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNodeNotEncounter = 9,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eEncounterMissingRewards = 10,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidEncounterRewardStyle = 11,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidEncounterData = 12,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNotEnoughTokensForReward = 13,
  CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNotEnoughResourceForReward = 14
};
bool CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNotEnoughResourceForReward;
constexpr int CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse>(
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldVisitEncounterResponse_EResponse : int {
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInvalidOverworld = 5,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInvalidNode = 6,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eNodeLocked = 7,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eNodeNotEncounter = 8,
  CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eAlreadyVisited = 9
};
bool CMsgClientToGCOverworldVisitEncounterResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eAlreadyVisited;
constexpr int CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldVisitEncounterResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldVisitEncounterResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldVisitEncounterResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldVisitEncounterResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldVisitEncounterResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldVisitEncounterResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldVisitEncounterResponse_EResponse>(
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldMoveToNodeResponse_EResponse : int {
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInvalidOverworld = 5,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInvalidNode = 6,
  CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eNodeLocked = 7
};
bool CMsgClientToGCOverworldMoveToNodeResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eNodeLocked;
constexpr int CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldMoveToNodeResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldMoveToNodeResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldMoveToNodeResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldMoveToNodeResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldMoveToNodeResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldMoveToNodeResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldMoveToNodeResponse_EResponse>(
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldTradeTokensResponse_EResponse : int {
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eNodeLocked = 6,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidOverworld = 7,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidOffer = 8,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eNotEnoughTokens = 9,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidNode = 10,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidEncounter = 11,
  CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eRewardDoesNotMatchRecipe = 12
};
bool CMsgClientToGCOverworldTradeTokensResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eRewardDoesNotMatchRecipe;
constexpr int CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldTradeTokensResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldTradeTokensResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldTradeTokensResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldTradeTokensResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldTradeTokensResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldTradeTokensResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldTradeTokensResponse_EResponse>(
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldGiftTokensResponse_EResponse : int {
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNodeLocked = 6,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInvalidOverworld = 7,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInvalidGift = 8,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotEnoughTokens = 9,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInvalidRecipient = 10,
  CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotEnoughPeriodicResource = 11
};
bool CMsgClientToGCOverworldGiftTokensResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotEnoughPeriodicResource;
constexpr int CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldGiftTokensResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldGiftTokensResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldGiftTokensResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldGiftTokensResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldGiftTokensResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldGiftTokensResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldGiftTokensResponse_EResponse>(
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldDevResetAllResponse_EResponse : int {
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eInvalidOverworld = 6
};
bool CMsgClientToGCOverworldDevResetAllResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eInvalidOverworld;
constexpr int CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevResetAllResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldDevResetAllResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldDevResetAllResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldDevResetAllResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldDevResetAllResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldDevResetAllResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldDevResetAllResponse_EResponse>(
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldDevResetNodeResponse_EResponse : int {
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInvalidOverworld = 6,
  CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInvalidNode = 7
};
bool CMsgClientToGCOverworldDevResetNodeResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInvalidNode;
constexpr int CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevResetNodeResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldDevResetNodeResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldDevResetNodeResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldDevResetNodeResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldDevResetNodeResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldDevResetNodeResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldDevResetNodeResponse_EResponse>(
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldDevGrantTokensResponse_EResponse : int {
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eInvalidOverworld = 6
};
bool CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eInvalidOverworld;
constexpr int CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldDevGrantTokensResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldDevGrantTokensResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldDevGrantTokensResponse_EResponse>(
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldDevClearInventoryResponse_EResponse : int {
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eInvalidOverworld = 6
};
bool CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eInvalidOverworld;
constexpr int CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldDevClearInventoryResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldDevClearInventoryResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldDevClearInventoryResponse_EResponse>(
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldFeedbackResponse_EResponse : int {
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eInternalError = 0,
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eSuccess = 1,
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eTooBusy = 2,
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eDisabled = 3,
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eTimeout = 4,
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eNotAllowed = 5,
  CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eInvalidOverworld = 6
};
bool CMsgClientToGCOverworldFeedbackResponse_EResponse_IsValid(int value);
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_MIN = CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eInternalError;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_MAX = CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eInvalidOverworld;
constexpr int CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_ARRAYSIZE = CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldFeedbackResponse_EResponse_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldFeedbackResponse_EResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldFeedbackResponse_EResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldFeedbackResponse_EResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldFeedbackResponse_EResponse_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldFeedbackResponse_EResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldFeedbackResponse_EResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldFeedbackResponse_EResponse>(
    CMsgClientToGCOverworldFeedbackResponse_EResponse_descriptor(), name, value);
}
enum CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat : int {
  CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_eUnknown = 0,
  CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_ePNG = 1,
  CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_eData = 2
};
bool CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_IsValid(int value);
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_MIN = CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_eUnknown;
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_MAX = CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_eData;
constexpr int CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_ARRAYSIZE = CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_descriptor();
template<typename T>
inline const std::string& CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_descriptor(), enum_t_value);
}
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat>(
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_descriptor(), name, value);
}
enum EOverworldNodeState : int {
  k_eOverworldNodeState_Invalid = 0,
  k_eOverworldNodeState_Locked = 1,
  k_eOverworldNodeState_Unlocked = 2
};
bool EOverworldNodeState_IsValid(int value);
constexpr EOverworldNodeState EOverworldNodeState_MIN = k_eOverworldNodeState_Invalid;
constexpr EOverworldNodeState EOverworldNodeState_MAX = k_eOverworldNodeState_Unlocked;
constexpr int EOverworldNodeState_ARRAYSIZE = EOverworldNodeState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverworldNodeState_descriptor();
template<typename T>
inline const std::string& EOverworldNodeState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EOverworldNodeState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EOverworldNodeState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EOverworldNodeState_descriptor(), enum_t_value);
}
inline bool EOverworldNodeState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EOverworldNodeState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EOverworldNodeState>(
    EOverworldNodeState_descriptor(), name, value);
}
enum EOverworldAuditAction : int {
  k_eOverworldAuditAction_Invalid = 0,
  k_eOverworldAuditAction_DevModifyTokens = 1,
  k_eOverworldAuditAction_DevClearInventory = 2,
  k_eOverworldAuditAction_DevGrantTokens = 3,
  k_eOverworldAuditAction_CompletePath = 4,
  k_eOverworldAuditAction_ClaimEncounterReward = 5,
  k_eOverworldAuditAction_DevResetNode = 6,
  k_eOverworldAuditAction_DevResetPath = 7,
  k_eOverworldAuditAction_MatchRewardsFull = 8,
  k_eOverworldAuditAction_MatchRewardsHalf = 9,
  k_eOverworldAuditAction_EventActionTokenGrant = 10,
  k_eOverworldAuditAction_TokenTraderLost = 11,
  k_eOverworldAuditAction_TokenTraderGained = 12,
  k_eOverworldAuditAction_EncounterRewardTokenCost = 13,
  k_eOverworldAuditAction_EncounterRewardTokenReward = 14,
  k_eOverworldAuditAction_SupportGrantTokens = 16,
  k_eOverworldAuditAction_TokenGiftSent = 17
};
bool EOverworldAuditAction_IsValid(int value);
constexpr EOverworldAuditAction EOverworldAuditAction_MIN = k_eOverworldAuditAction_Invalid;
constexpr EOverworldAuditAction EOverworldAuditAction_MAX = k_eOverworldAuditAction_TokenGiftSent;
constexpr int EOverworldAuditAction_ARRAYSIZE = EOverworldAuditAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverworldAuditAction_descriptor();
template<typename T>
inline const std::string& EOverworldAuditAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EOverworldAuditAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EOverworldAuditAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EOverworldAuditAction_descriptor(), enum_t_value);
}
inline bool EOverworldAuditAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EOverworldAuditAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EOverworldAuditAction>(
    EOverworldAuditAction_descriptor(), name, value);
}
// ===================================================================

class CMsgOverworldTokenCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldTokenCount) */ {
 public:
  inline CMsgOverworldTokenCount() : CMsgOverworldTokenCount(nullptr) {}
  ~CMsgOverworldTokenCount() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldTokenCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldTokenCount(const CMsgOverworldTokenCount& from);
  CMsgOverworldTokenCount(CMsgOverworldTokenCount&& from) noexcept
    : CMsgOverworldTokenCount() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldTokenCount& operator=(const CMsgOverworldTokenCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldTokenCount& operator=(CMsgOverworldTokenCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldTokenCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldTokenCount* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldTokenCount*>(
               &_CMsgOverworldTokenCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgOverworldTokenCount& a, CMsgOverworldTokenCount& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldTokenCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldTokenCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldTokenCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldTokenCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldTokenCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldTokenCount& from) {
    CMsgOverworldTokenCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldTokenCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldTokenCount";
  }
  protected:
  explicit CMsgOverworldTokenCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kTokenCountFieldNumber = 2,
  };
  // optional uint32 token_id = 1;
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint32_t token_id() const;
  void set_token_id(uint32_t value);
  private:
  uint32_t _internal_token_id() const;
  void _internal_set_token_id(uint32_t value);
  public:

  // optional uint32 token_count = 2;
  bool has_token_count() const;
  private:
  bool _internal_has_token_count() const;
  public:
  void clear_token_count();
  uint32_t token_count() const;
  void set_token_count(uint32_t value);
  private:
  uint32_t _internal_token_count() const;
  void _internal_set_token_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldTokenCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t token_id_;
    uint32_t token_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldTokenQuantity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldTokenQuantity) */ {
 public:
  inline CMsgOverworldTokenQuantity() : CMsgOverworldTokenQuantity(nullptr) {}
  ~CMsgOverworldTokenQuantity() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldTokenQuantity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldTokenQuantity(const CMsgOverworldTokenQuantity& from);
  CMsgOverworldTokenQuantity(CMsgOverworldTokenQuantity&& from) noexcept
    : CMsgOverworldTokenQuantity() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldTokenQuantity& operator=(const CMsgOverworldTokenQuantity& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldTokenQuantity& operator=(CMsgOverworldTokenQuantity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldTokenQuantity& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldTokenQuantity* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldTokenQuantity*>(
               &_CMsgOverworldTokenQuantity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgOverworldTokenQuantity& a, CMsgOverworldTokenQuantity& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldTokenQuantity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldTokenQuantity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldTokenQuantity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldTokenQuantity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldTokenQuantity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldTokenQuantity& from) {
    CMsgOverworldTokenQuantity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldTokenQuantity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldTokenQuantity";
  }
  protected:
  explicit CMsgOverworldTokenQuantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenCountsFieldNumber = 1,
  };
  // repeated .CMsgOverworldTokenCount token_counts = 1;
  int token_counts_size() const;
  private:
  int _internal_token_counts_size() const;
  public:
  void clear_token_counts();
  ::CMsgOverworldTokenCount* mutable_token_counts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldTokenCount >*
      mutable_token_counts();
  private:
  const ::CMsgOverworldTokenCount& _internal_token_counts(int index) const;
  ::CMsgOverworldTokenCount* _internal_add_token_counts();
  public:
  const ::CMsgOverworldTokenCount& token_counts(int index) const;
  ::CMsgOverworldTokenCount* add_token_counts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldTokenCount >&
      token_counts() const;

  // @@protoc_insertion_point(class_scope:CMsgOverworldTokenQuantity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldTokenCount > token_counts_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterTokenTreasureData_RewardOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterTokenTreasureData.RewardOption) */ {
 public:
  inline CMsgOverworldEncounterTokenTreasureData_RewardOption() : CMsgOverworldEncounterTokenTreasureData_RewardOption(nullptr) {}
  ~CMsgOverworldEncounterTokenTreasureData_RewardOption() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenTreasureData_RewardOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterTokenTreasureData_RewardOption(const CMsgOverworldEncounterTokenTreasureData_RewardOption& from);
  CMsgOverworldEncounterTokenTreasureData_RewardOption(CMsgOverworldEncounterTokenTreasureData_RewardOption&& from) noexcept
    : CMsgOverworldEncounterTokenTreasureData_RewardOption() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterTokenTreasureData_RewardOption& operator=(const CMsgOverworldEncounterTokenTreasureData_RewardOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterTokenTreasureData_RewardOption& operator=(CMsgOverworldEncounterTokenTreasureData_RewardOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterTokenTreasureData_RewardOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterTokenTreasureData_RewardOption* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterTokenTreasureData_RewardOption*>(
               &_CMsgOverworldEncounterTokenTreasureData_RewardOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMsgOverworldEncounterTokenTreasureData_RewardOption& a, CMsgOverworldEncounterTokenTreasureData_RewardOption& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterTokenTreasureData_RewardOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterTokenTreasureData_RewardOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterTokenTreasureData_RewardOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterTokenTreasureData_RewardOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterTokenTreasureData_RewardOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterTokenTreasureData_RewardOption& from) {
    CMsgOverworldEncounterTokenTreasureData_RewardOption::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterTokenTreasureData_RewardOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterTokenTreasureData.RewardOption";
  }
  protected:
  explicit CMsgOverworldEncounterTokenTreasureData_RewardOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenCostFieldNumber = 2,
    kTokenRewardFieldNumber = 3,
    kRewardDataFieldNumber = 1,
  };
  // optional .CMsgOverworldTokenQuantity token_cost = 2;
  bool has_token_cost() const;
  private:
  bool _internal_has_token_cost() const;
  public:
  void clear_token_cost();
  const ::CMsgOverworldTokenQuantity& token_cost() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_cost();
  ::CMsgOverworldTokenQuantity* mutable_token_cost();
  void set_allocated_token_cost(::CMsgOverworldTokenQuantity* token_cost);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_cost() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_cost();
  public:
  void unsafe_arena_set_allocated_token_cost(
      ::CMsgOverworldTokenQuantity* token_cost);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_cost();

  // optional .CMsgOverworldTokenQuantity token_reward = 3;
  bool has_token_reward() const;
  private:
  bool _internal_has_token_reward() const;
  public:
  void clear_token_reward();
  const ::CMsgOverworldTokenQuantity& token_reward() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_reward();
  ::CMsgOverworldTokenQuantity* mutable_token_reward();
  void set_allocated_token_reward(::CMsgOverworldTokenQuantity* token_reward);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_reward() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_reward();
  public:
  void unsafe_arena_set_allocated_token_reward(
      ::CMsgOverworldTokenQuantity* token_reward);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_reward();

  // optional uint32 reward_data = 1;
  bool has_reward_data() const;
  private:
  bool _internal_has_reward_data() const;
  public:
  void clear_reward_data();
  uint32_t reward_data() const;
  void set_reward_data(uint32_t value);
  private:
  uint32_t _internal_reward_data() const;
  void _internal_set_reward_data(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterTokenTreasureData.RewardOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* token_cost_;
    ::CMsgOverworldTokenQuantity* token_reward_;
    uint32_t reward_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterTokenTreasureData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterTokenTreasureData) */ {
 public:
  inline CMsgOverworldEncounterTokenTreasureData() : CMsgOverworldEncounterTokenTreasureData(nullptr) {}
  ~CMsgOverworldEncounterTokenTreasureData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenTreasureData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterTokenTreasureData(const CMsgOverworldEncounterTokenTreasureData& from);
  CMsgOverworldEncounterTokenTreasureData(CMsgOverworldEncounterTokenTreasureData&& from) noexcept
    : CMsgOverworldEncounterTokenTreasureData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterTokenTreasureData& operator=(const CMsgOverworldEncounterTokenTreasureData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterTokenTreasureData& operator=(CMsgOverworldEncounterTokenTreasureData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterTokenTreasureData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterTokenTreasureData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterTokenTreasureData*>(
               &_CMsgOverworldEncounterTokenTreasureData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsgOverworldEncounterTokenTreasureData& a, CMsgOverworldEncounterTokenTreasureData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterTokenTreasureData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterTokenTreasureData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterTokenTreasureData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterTokenTreasureData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterTokenTreasureData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterTokenTreasureData& from) {
    CMsgOverworldEncounterTokenTreasureData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterTokenTreasureData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterTokenTreasureData";
  }
  protected:
  explicit CMsgOverworldEncounterTokenTreasureData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgOverworldEncounterTokenTreasureData_RewardOption RewardOption;

  // accessors -------------------------------------------------------

  enum : int {
    kRewardOptionsFieldNumber = 1,
  };
  // repeated .CMsgOverworldEncounterTokenTreasureData.RewardOption reward_options = 1;
  int reward_options_size() const;
  private:
  int _internal_reward_options_size() const;
  public:
  void clear_reward_options();
  ::CMsgOverworldEncounterTokenTreasureData_RewardOption* mutable_reward_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenTreasureData_RewardOption >*
      mutable_reward_options();
  private:
  const ::CMsgOverworldEncounterTokenTreasureData_RewardOption& _internal_reward_options(int index) const;
  ::CMsgOverworldEncounterTokenTreasureData_RewardOption* _internal_add_reward_options();
  public:
  const ::CMsgOverworldEncounterTokenTreasureData_RewardOption& reward_options(int index) const;
  ::CMsgOverworldEncounterTokenTreasureData_RewardOption* add_reward_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenTreasureData_RewardOption >&
      reward_options() const;

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterTokenTreasureData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenTreasureData_RewardOption > reward_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterTokenQuestData_Quest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterTokenQuestData.Quest) */ {
 public:
  inline CMsgOverworldEncounterTokenQuestData_Quest() : CMsgOverworldEncounterTokenQuestData_Quest(nullptr) {}
  ~CMsgOverworldEncounterTokenQuestData_Quest() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenQuestData_Quest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterTokenQuestData_Quest(const CMsgOverworldEncounterTokenQuestData_Quest& from);
  CMsgOverworldEncounterTokenQuestData_Quest(CMsgOverworldEncounterTokenQuestData_Quest&& from) noexcept
    : CMsgOverworldEncounterTokenQuestData_Quest() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterTokenQuestData_Quest& operator=(const CMsgOverworldEncounterTokenQuestData_Quest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterTokenQuestData_Quest& operator=(CMsgOverworldEncounterTokenQuestData_Quest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterTokenQuestData_Quest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterTokenQuestData_Quest* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterTokenQuestData_Quest*>(
               &_CMsgOverworldEncounterTokenQuestData_Quest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsgOverworldEncounterTokenQuestData_Quest& a, CMsgOverworldEncounterTokenQuestData_Quest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterTokenQuestData_Quest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterTokenQuestData_Quest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterTokenQuestData_Quest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterTokenQuestData_Quest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterTokenQuestData_Quest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterTokenQuestData_Quest& from) {
    CMsgOverworldEncounterTokenQuestData_Quest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterTokenQuestData_Quest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterTokenQuestData.Quest";
  }
  protected:
  explicit CMsgOverworldEncounterTokenQuestData_Quest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenCostFieldNumber = 2,
    kTokenRewardFieldNumber = 3,
    kRewardDataFieldNumber = 1,
  };
  // optional .CMsgOverworldTokenQuantity token_cost = 2;
  bool has_token_cost() const;
  private:
  bool _internal_has_token_cost() const;
  public:
  void clear_token_cost();
  const ::CMsgOverworldTokenQuantity& token_cost() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_cost();
  ::CMsgOverworldTokenQuantity* mutable_token_cost();
  void set_allocated_token_cost(::CMsgOverworldTokenQuantity* token_cost);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_cost() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_cost();
  public:
  void unsafe_arena_set_allocated_token_cost(
      ::CMsgOverworldTokenQuantity* token_cost);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_cost();

  // optional .CMsgOverworldTokenQuantity token_reward = 3;
  bool has_token_reward() const;
  private:
  bool _internal_has_token_reward() const;
  public:
  void clear_token_reward();
  const ::CMsgOverworldTokenQuantity& token_reward() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_reward();
  ::CMsgOverworldTokenQuantity* mutable_token_reward();
  void set_allocated_token_reward(::CMsgOverworldTokenQuantity* token_reward);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_reward() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_reward();
  public:
  void unsafe_arena_set_allocated_token_reward(
      ::CMsgOverworldTokenQuantity* token_reward);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_reward();

  // optional uint32 reward_data = 1;
  bool has_reward_data() const;
  private:
  bool _internal_has_reward_data() const;
  public:
  void clear_reward_data();
  uint32_t reward_data() const;
  void set_reward_data(uint32_t value);
  private:
  uint32_t _internal_reward_data() const;
  void _internal_set_reward_data(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterTokenQuestData.Quest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* token_cost_;
    ::CMsgOverworldTokenQuantity* token_reward_;
    uint32_t reward_data_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterTokenQuestData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterTokenQuestData) */ {
 public:
  inline CMsgOverworldEncounterTokenQuestData() : CMsgOverworldEncounterTokenQuestData(nullptr) {}
  ~CMsgOverworldEncounterTokenQuestData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenQuestData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterTokenQuestData(const CMsgOverworldEncounterTokenQuestData& from);
  CMsgOverworldEncounterTokenQuestData(CMsgOverworldEncounterTokenQuestData&& from) noexcept
    : CMsgOverworldEncounterTokenQuestData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterTokenQuestData& operator=(const CMsgOverworldEncounterTokenQuestData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterTokenQuestData& operator=(CMsgOverworldEncounterTokenQuestData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterTokenQuestData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterTokenQuestData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterTokenQuestData*>(
               &_CMsgOverworldEncounterTokenQuestData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgOverworldEncounterTokenQuestData& a, CMsgOverworldEncounterTokenQuestData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterTokenQuestData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterTokenQuestData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterTokenQuestData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterTokenQuestData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterTokenQuestData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterTokenQuestData& from) {
    CMsgOverworldEncounterTokenQuestData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterTokenQuestData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterTokenQuestData";
  }
  protected:
  explicit CMsgOverworldEncounterTokenQuestData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgOverworldEncounterTokenQuestData_Quest Quest;

  // accessors -------------------------------------------------------

  enum : int {
    kQuestsFieldNumber = 1,
  };
  // repeated .CMsgOverworldEncounterTokenQuestData.Quest quests = 1;
  int quests_size() const;
  private:
  int _internal_quests_size() const;
  public:
  void clear_quests();
  ::CMsgOverworldEncounterTokenQuestData_Quest* mutable_quests(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenQuestData_Quest >*
      mutable_quests();
  private:
  const ::CMsgOverworldEncounterTokenQuestData_Quest& _internal_quests(int index) const;
  ::CMsgOverworldEncounterTokenQuestData_Quest* _internal_add_quests();
  public:
  const ::CMsgOverworldEncounterTokenQuestData_Quest& quests(int index) const;
  ::CMsgOverworldEncounterTokenQuestData_Quest* add_quests();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenQuestData_Quest >&
      quests() const;

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterTokenQuestData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenQuestData_Quest > quests_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldHeroList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldHeroList) */ {
 public:
  inline CMsgOverworldHeroList() : CMsgOverworldHeroList(nullptr) {}
  ~CMsgOverworldHeroList() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldHeroList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldHeroList(const CMsgOverworldHeroList& from);
  CMsgOverworldHeroList(CMsgOverworldHeroList&& from) noexcept
    : CMsgOverworldHeroList() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldHeroList& operator=(const CMsgOverworldHeroList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldHeroList& operator=(CMsgOverworldHeroList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldHeroList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldHeroList* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldHeroList*>(
               &_CMsgOverworldHeroList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgOverworldHeroList& a, CMsgOverworldHeroList& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldHeroList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldHeroList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldHeroList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldHeroList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldHeroList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldHeroList& from) {
    CMsgOverworldHeroList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldHeroList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldHeroList";
  }
  protected:
  explicit CMsgOverworldHeroList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeroIdsFieldNumber = 1,
  };
  // repeated int32 hero_ids = 1;
  int hero_ids_size() const;
  private:
  int _internal_hero_ids_size() const;
  public:
  void clear_hero_ids();
  private:
  int32_t _internal_hero_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_hero_ids() const;
  void _internal_add_hero_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_hero_ids();
  public:
  int32_t hero_ids(int index) const;
  void set_hero_ids(int index, int32_t value);
  void add_hero_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      hero_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_hero_ids();

  // @@protoc_insertion_point(class_scope:CMsgOverworldHeroList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > hero_ids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterChooseHeroData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterChooseHeroData) */ {
 public:
  inline CMsgOverworldEncounterChooseHeroData() : CMsgOverworldEncounterChooseHeroData(nullptr) {}
  ~CMsgOverworldEncounterChooseHeroData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterChooseHeroData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterChooseHeroData(const CMsgOverworldEncounterChooseHeroData& from);
  CMsgOverworldEncounterChooseHeroData(CMsgOverworldEncounterChooseHeroData&& from) noexcept
    : CMsgOverworldEncounterChooseHeroData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterChooseHeroData& operator=(const CMsgOverworldEncounterChooseHeroData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterChooseHeroData& operator=(CMsgOverworldEncounterChooseHeroData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterChooseHeroData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterChooseHeroData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterChooseHeroData*>(
               &_CMsgOverworldEncounterChooseHeroData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgOverworldEncounterChooseHeroData& a, CMsgOverworldEncounterChooseHeroData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterChooseHeroData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterChooseHeroData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterChooseHeroData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterChooseHeroData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterChooseHeroData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterChooseHeroData& from) {
    CMsgOverworldEncounterChooseHeroData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterChooseHeroData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterChooseHeroData";
  }
  protected:
  explicit CMsgOverworldEncounterChooseHeroData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeroListFieldNumber = 1,
    kAdditiveFieldNumber = 2,
  };
  // optional .CMsgOverworldHeroList hero_list = 1;
  bool has_hero_list() const;
  private:
  bool _internal_has_hero_list() const;
  public:
  void clear_hero_list();
  const ::CMsgOverworldHeroList& hero_list() const;
  PROTOBUF_NODISCARD ::CMsgOverworldHeroList* release_hero_list();
  ::CMsgOverworldHeroList* mutable_hero_list();
  void set_allocated_hero_list(::CMsgOverworldHeroList* hero_list);
  private:
  const ::CMsgOverworldHeroList& _internal_hero_list() const;
  ::CMsgOverworldHeroList* _internal_mutable_hero_list();
  public:
  void unsafe_arena_set_allocated_hero_list(
      ::CMsgOverworldHeroList* hero_list);
  ::CMsgOverworldHeroList* unsafe_arena_release_hero_list();

  // optional bool additive = 2;
  bool has_additive() const;
  private:
  bool _internal_has_additive() const;
  public:
  void clear_additive();
  bool additive() const;
  void set_additive(bool value);
  private:
  bool _internal_additive() const;
  void _internal_set_additive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterChooseHeroData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldHeroList* hero_list_;
    bool additive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterProgressData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterProgressData) */ {
 public:
  inline CMsgOverworldEncounterProgressData() : CMsgOverworldEncounterProgressData(nullptr) {}
  ~CMsgOverworldEncounterProgressData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterProgressData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterProgressData(const CMsgOverworldEncounterProgressData& from);
  CMsgOverworldEncounterProgressData(CMsgOverworldEncounterProgressData&& from) noexcept
    : CMsgOverworldEncounterProgressData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterProgressData& operator=(const CMsgOverworldEncounterProgressData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterProgressData& operator=(CMsgOverworldEncounterProgressData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterProgressData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterProgressData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterProgressData*>(
               &_CMsgOverworldEncounterProgressData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgOverworldEncounterProgressData& a, CMsgOverworldEncounterProgressData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterProgressData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterProgressData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterProgressData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterProgressData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterProgressData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterProgressData& from) {
    CMsgOverworldEncounterProgressData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterProgressData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterProgressData";
  }
  protected:
  explicit CMsgOverworldEncounterProgressData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChoiceFieldNumber = 1,
    kProgressFieldNumber = 2,
    kMaxProgressFieldNumber = 3,
    kVisitedFieldNumber = 4,
  };
  // optional int32 choice = 1;
  bool has_choice() const;
  private:
  bool _internal_has_choice() const;
  public:
  void clear_choice();
  int32_t choice() const;
  void set_choice(int32_t value);
  private:
  int32_t _internal_choice() const;
  void _internal_set_choice(int32_t value);
  public:

  // optional int32 progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  int32_t progress() const;
  void set_progress(int32_t value);
  private:
  int32_t _internal_progress() const;
  void _internal_set_progress(int32_t value);
  public:

  // optional int32 max_progress = 3;
  bool has_max_progress() const;
  private:
  bool _internal_has_max_progress() const;
  public:
  void clear_max_progress();
  int32_t max_progress() const;
  void set_max_progress(int32_t value);
  private:
  int32_t _internal_max_progress() const;
  void _internal_set_max_progress(int32_t value);
  public:

  // optional bool visited = 4;
  bool has_visited() const;
  private:
  bool _internal_has_visited() const;
  public:
  void clear_visited();
  bool visited() const;
  void set_visited(bool value);
  private:
  bool _internal_visited() const;
  void _internal_set_visited(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterProgressData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t choice_;
    int32_t progress_;
    int32_t max_progress_;
    bool visited_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterData) */ {
 public:
  inline CMsgOverworldEncounterData() : CMsgOverworldEncounterData(nullptr) {}
  ~CMsgOverworldEncounterData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterData(const CMsgOverworldEncounterData& from);
  CMsgOverworldEncounterData(CMsgOverworldEncounterData&& from) noexcept
    : CMsgOverworldEncounterData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterData& operator=(const CMsgOverworldEncounterData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterData& operator=(CMsgOverworldEncounterData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterData*>(
               &_CMsgOverworldEncounterData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgOverworldEncounterData& a, CMsgOverworldEncounterData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterData& from) {
    CMsgOverworldEncounterData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterData";
  }
  protected:
  explicit CMsgOverworldEncounterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraEncounterDataFieldNumber = 1,
  };
  // repeated .CExtraMsgBlock extra_encounter_data = 1;
  int extra_encounter_data_size() const;
  private:
  int _internal_extra_encounter_data_size() const;
  public:
  void clear_extra_encounter_data();
  ::CExtraMsgBlock* mutable_extra_encounter_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CExtraMsgBlock >*
      mutable_extra_encounter_data();
  private:
  const ::CExtraMsgBlock& _internal_extra_encounter_data(int index) const;
  ::CExtraMsgBlock* _internal_add_extra_encounter_data();
  public:
  const ::CExtraMsgBlock& extra_encounter_data(int index) const;
  ::CExtraMsgBlock* add_extra_encounter_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CExtraMsgBlock >&
      extra_encounter_data() const;

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CExtraMsgBlock > extra_encounter_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldNode) */ {
 public:
  inline CMsgOverworldNode() : CMsgOverworldNode(nullptr) {}
  ~CMsgOverworldNode() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldNode(const CMsgOverworldNode& from);
  CMsgOverworldNode(CMsgOverworldNode&& from) noexcept
    : CMsgOverworldNode() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldNode& operator=(const CMsgOverworldNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldNode& operator=(CMsgOverworldNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldNode* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldNode*>(
               &_CMsgOverworldNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgOverworldNode& a, CMsgOverworldNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldNode& from) {
    CMsgOverworldNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldNode";
  }
  protected:
  explicit CMsgOverworldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeEncounterDataFieldNumber = 3,
    kNodeIdFieldNumber = 1,
    kNodeStateFieldNumber = 2,
  };
  // optional .CMsgOverworldEncounterData node_encounter_data = 3;
  bool has_node_encounter_data() const;
  private:
  bool _internal_has_node_encounter_data() const;
  public:
  void clear_node_encounter_data();
  const ::CMsgOverworldEncounterData& node_encounter_data() const;
  PROTOBUF_NODISCARD ::CMsgOverworldEncounterData* release_node_encounter_data();
  ::CMsgOverworldEncounterData* mutable_node_encounter_data();
  void set_allocated_node_encounter_data(::CMsgOverworldEncounterData* node_encounter_data);
  private:
  const ::CMsgOverworldEncounterData& _internal_node_encounter_data() const;
  ::CMsgOverworldEncounterData* _internal_mutable_node_encounter_data();
  public:
  void unsafe_arena_set_allocated_node_encounter_data(
      ::CMsgOverworldEncounterData* node_encounter_data);
  ::CMsgOverworldEncounterData* unsafe_arena_release_node_encounter_data();

  // optional uint32 node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // optional .EOverworldNodeState node_state = 2 [default = k_eOverworldNodeState_Invalid];
  bool has_node_state() const;
  private:
  bool _internal_has_node_state() const;
  public:
  void clear_node_state();
  ::EOverworldNodeState node_state() const;
  void set_node_state(::EOverworldNodeState value);
  private:
  ::EOverworldNodeState _internal_node_state() const;
  void _internal_set_node_state(::EOverworldNodeState value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldEncounterData* node_encounter_data_;
    uint32_t node_id_;
    int node_state_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldPath) */ {
 public:
  inline CMsgOverworldPath() : CMsgOverworldPath(nullptr) {}
  ~CMsgOverworldPath() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldPath(const CMsgOverworldPath& from);
  CMsgOverworldPath(CMsgOverworldPath&& from) noexcept
    : CMsgOverworldPath() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldPath& operator=(const CMsgOverworldPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldPath& operator=(CMsgOverworldPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldPath* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldPath*>(
               &_CMsgOverworldPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgOverworldPath& a, CMsgOverworldPath& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldPath& from) {
    CMsgOverworldPath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldPath";
  }
  protected:
  explicit CMsgOverworldPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathCostFieldNumber = 2,
    kPathIdFieldNumber = 1,
  };
  // optional .CMsgOverworldTokenQuantity path_cost = 2;
  bool has_path_cost() const;
  private:
  bool _internal_has_path_cost() const;
  public:
  void clear_path_cost();
  const ::CMsgOverworldTokenQuantity& path_cost() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_path_cost();
  ::CMsgOverworldTokenQuantity* mutable_path_cost();
  void set_allocated_path_cost(::CMsgOverworldTokenQuantity* path_cost);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_path_cost() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_path_cost();
  public:
  void unsafe_arena_set_allocated_path_cost(
      ::CMsgOverworldTokenQuantity* path_cost);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_path_cost();

  // optional uint32 path_id = 1;
  bool has_path_id() const;
  private:
  bool _internal_has_path_id() const;
  public:
  void clear_path_id();
  uint32_t path_id() const;
  void set_path_id(uint32_t value);
  private:
  uint32_t _internal_path_id() const;
  void _internal_set_path_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* path_cost_;
    uint32_t path_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldUserData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldUserData) */ {
 public:
  inline CMsgOverworldUserData() : CMsgOverworldUserData(nullptr) {}
  ~CMsgOverworldUserData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldUserData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldUserData(const CMsgOverworldUserData& from);
  CMsgOverworldUserData(CMsgOverworldUserData&& from) noexcept
    : CMsgOverworldUserData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldUserData& operator=(const CMsgOverworldUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldUserData& operator=(CMsgOverworldUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldUserData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldUserData*>(
               &_CMsgOverworldUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgOverworldUserData& a, CMsgOverworldUserData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldUserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldUserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldUserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldUserData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldUserData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldUserData& from) {
    CMsgOverworldUserData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldUserData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldUserData";
  }
  protected:
  explicit CMsgOverworldUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldNodesFieldNumber = 2,
    kOverworldPathsFieldNumber = 3,
    kTokenInventoryFieldNumber = 1,
    kCurrentNodeIdFieldNumber = 4,
  };
  // repeated .CMsgOverworldNode overworld_nodes = 2;
  int overworld_nodes_size() const;
  private:
  int _internal_overworld_nodes_size() const;
  public:
  void clear_overworld_nodes();
  ::CMsgOverworldNode* mutable_overworld_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldNode >*
      mutable_overworld_nodes();
  private:
  const ::CMsgOverworldNode& _internal_overworld_nodes(int index) const;
  ::CMsgOverworldNode* _internal_add_overworld_nodes();
  public:
  const ::CMsgOverworldNode& overworld_nodes(int index) const;
  ::CMsgOverworldNode* add_overworld_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldNode >&
      overworld_nodes() const;

  // repeated .CMsgOverworldPath overworld_paths = 3;
  int overworld_paths_size() const;
  private:
  int _internal_overworld_paths_size() const;
  public:
  void clear_overworld_paths();
  ::CMsgOverworldPath* mutable_overworld_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldPath >*
      mutable_overworld_paths();
  private:
  const ::CMsgOverworldPath& _internal_overworld_paths(int index) const;
  ::CMsgOverworldPath* _internal_add_overworld_paths();
  public:
  const ::CMsgOverworldPath& overworld_paths(int index) const;
  ::CMsgOverworldPath* add_overworld_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldPath >&
      overworld_paths() const;

  // optional .CMsgOverworldTokenQuantity token_inventory = 1;
  bool has_token_inventory() const;
  private:
  bool _internal_has_token_inventory() const;
  public:
  void clear_token_inventory();
  const ::CMsgOverworldTokenQuantity& token_inventory() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_inventory();
  ::CMsgOverworldTokenQuantity* mutable_token_inventory();
  void set_allocated_token_inventory(::CMsgOverworldTokenQuantity* token_inventory);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_inventory() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_inventory();
  public:
  void unsafe_arena_set_allocated_token_inventory(
      ::CMsgOverworldTokenQuantity* token_inventory);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_inventory();

  // optional uint32 current_node_id = 4;
  bool has_current_node_id() const;
  private:
  bool _internal_has_current_node_id() const;
  public:
  void clear_current_node_id();
  uint32_t current_node_id() const;
  void set_current_node_id(uint32_t value);
  private:
  uint32_t _internal_current_node_id() const;
  void _internal_set_current_node_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldUserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldNode > overworld_nodes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldPath > overworld_paths_;
    ::CMsgOverworldTokenQuantity* token_inventory_;
    uint32_t current_node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldMatchRewards_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldMatchRewards.Player) */ {
 public:
  inline CMsgOverworldMatchRewards_Player() : CMsgOverworldMatchRewards_Player(nullptr) {}
  ~CMsgOverworldMatchRewards_Player() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldMatchRewards_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldMatchRewards_Player(const CMsgOverworldMatchRewards_Player& from);
  CMsgOverworldMatchRewards_Player(CMsgOverworldMatchRewards_Player&& from) noexcept
    : CMsgOverworldMatchRewards_Player() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldMatchRewards_Player& operator=(const CMsgOverworldMatchRewards_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldMatchRewards_Player& operator=(CMsgOverworldMatchRewards_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldMatchRewards_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldMatchRewards_Player* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldMatchRewards_Player*>(
               &_CMsgOverworldMatchRewards_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgOverworldMatchRewards_Player& a, CMsgOverworldMatchRewards_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldMatchRewards_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldMatchRewards_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldMatchRewards_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldMatchRewards_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldMatchRewards_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldMatchRewards_Player& from) {
    CMsgOverworldMatchRewards_Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldMatchRewards_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldMatchRewards.Player";
  }
  protected:
  explicit CMsgOverworldMatchRewards_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 2,
    kPlayerSlotFieldNumber = 1,
    kOverworldIdFieldNumber = 3,
  };
  // optional .CMsgOverworldTokenQuantity tokens = 2;
  bool has_tokens() const;
  private:
  bool _internal_has_tokens() const;
  public:
  void clear_tokens();
  const ::CMsgOverworldTokenQuantity& tokens() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_tokens();
  ::CMsgOverworldTokenQuantity* mutable_tokens();
  void set_allocated_tokens(::CMsgOverworldTokenQuantity* tokens);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_tokens() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_tokens();
  public:
  void unsafe_arena_set_allocated_tokens(
      ::CMsgOverworldTokenQuantity* tokens);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_tokens();

  // optional uint32 player_slot = 1;
  bool has_player_slot() const;
  private:
  bool _internal_has_player_slot() const;
  public:
  void clear_player_slot();
  uint32_t player_slot() const;
  void set_player_slot(uint32_t value);
  private:
  uint32_t _internal_player_slot() const;
  void _internal_set_player_slot(uint32_t value);
  public:

  // optional uint32 overworld_id = 3;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldMatchRewards.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* tokens_;
    uint32_t player_slot_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldMatchRewards final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldMatchRewards) */ {
 public:
  inline CMsgOverworldMatchRewards() : CMsgOverworldMatchRewards(nullptr) {}
  ~CMsgOverworldMatchRewards() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldMatchRewards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldMatchRewards(const CMsgOverworldMatchRewards& from);
  CMsgOverworldMatchRewards(CMsgOverworldMatchRewards&& from) noexcept
    : CMsgOverworldMatchRewards() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldMatchRewards& operator=(const CMsgOverworldMatchRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldMatchRewards& operator=(CMsgOverworldMatchRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldMatchRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldMatchRewards* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldMatchRewards*>(
               &_CMsgOverworldMatchRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgOverworldMatchRewards& a, CMsgOverworldMatchRewards& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldMatchRewards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldMatchRewards* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldMatchRewards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldMatchRewards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldMatchRewards& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldMatchRewards& from) {
    CMsgOverworldMatchRewards::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldMatchRewards* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldMatchRewards";
  }
  protected:
  explicit CMsgOverworldMatchRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgOverworldMatchRewards_Player Player;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .CMsgOverworldMatchRewards.Player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::CMsgOverworldMatchRewards_Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldMatchRewards_Player >*
      mutable_players();
  private:
  const ::CMsgOverworldMatchRewards_Player& _internal_players(int index) const;
  ::CMsgOverworldMatchRewards_Player* _internal_add_players();
  public:
  const ::CMsgOverworldMatchRewards_Player& players(int index) const;
  ::CMsgOverworldMatchRewards_Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldMatchRewards_Player >&
      players() const;

  // @@protoc_insertion_point(class_scope:CMsgOverworldMatchRewards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldMatchRewards_Player > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGetUserData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGetUserData) */ {
 public:
  inline CMsgClientToGCOverworldGetUserData() : CMsgClientToGCOverworldGetUserData(nullptr) {}
  ~CMsgClientToGCOverworldGetUserData() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetUserData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGetUserData(const CMsgClientToGCOverworldGetUserData& from);
  CMsgClientToGCOverworldGetUserData(CMsgClientToGCOverworldGetUserData&& from) noexcept
    : CMsgClientToGCOverworldGetUserData() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGetUserData& operator=(const CMsgClientToGCOverworldGetUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGetUserData& operator=(CMsgClientToGCOverworldGetUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGetUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGetUserData* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGetUserData*>(
               &_CMsgClientToGCOverworldGetUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CMsgClientToGCOverworldGetUserData& a, CMsgClientToGCOverworldGetUserData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGetUserData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGetUserData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGetUserData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGetUserData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGetUserData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGetUserData& from) {
    CMsgClientToGCOverworldGetUserData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGetUserData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGetUserData";
  }
  protected:
  explicit CMsgClientToGCOverworldGetUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGetUserData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGetUserDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGetUserDataResponse) */ {
 public:
  inline CMsgClientToGCOverworldGetUserDataResponse() : CMsgClientToGCOverworldGetUserDataResponse(nullptr) {}
  ~CMsgClientToGCOverworldGetUserDataResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetUserDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGetUserDataResponse(const CMsgClientToGCOverworldGetUserDataResponse& from);
  CMsgClientToGCOverworldGetUserDataResponse(CMsgClientToGCOverworldGetUserDataResponse&& from) noexcept
    : CMsgClientToGCOverworldGetUserDataResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGetUserDataResponse& operator=(const CMsgClientToGCOverworldGetUserDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGetUserDataResponse& operator=(CMsgClientToGCOverworldGetUserDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGetUserDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGetUserDataResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGetUserDataResponse*>(
               &_CMsgClientToGCOverworldGetUserDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CMsgClientToGCOverworldGetUserDataResponse& a, CMsgClientToGCOverworldGetUserDataResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGetUserDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGetUserDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGetUserDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGetUserDataResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGetUserDataResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGetUserDataResponse& from) {
    CMsgClientToGCOverworldGetUserDataResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGetUserDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGetUserDataResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldGetUserDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldGetUserDataResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_k_eInvalidOverworld;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldGetUserDataResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldGetUserDataResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldGetUserDataResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldGetUserDataResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldGetUserDataResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // optional .CMsgOverworldUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::CMsgOverworldUserData& user_data() const;
  PROTOBUF_NODISCARD ::CMsgOverworldUserData* release_user_data();
  ::CMsgOverworldUserData* mutable_user_data();
  void set_allocated_user_data(::CMsgOverworldUserData* user_data);
  private:
  const ::CMsgOverworldUserData& _internal_user_data() const;
  ::CMsgOverworldUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::CMsgOverworldUserData* user_data);
  ::CMsgOverworldUserData* unsafe_arena_release_user_data();

  // optional .CMsgClientToGCOverworldGetUserDataResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldGetUserDataResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldGetUserDataResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldGetUserDataResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldGetUserDataResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGetUserDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldUserData* user_data_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgGCToClientOverworldUserDataUpdated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGCToClientOverworldUserDataUpdated) */ {
 public:
  inline CMsgGCToClientOverworldUserDataUpdated() : CMsgGCToClientOverworldUserDataUpdated(nullptr) {}
  ~CMsgGCToClientOverworldUserDataUpdated() override;
  explicit PROTOBUF_CONSTEXPR CMsgGCToClientOverworldUserDataUpdated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGCToClientOverworldUserDataUpdated(const CMsgGCToClientOverworldUserDataUpdated& from);
  CMsgGCToClientOverworldUserDataUpdated(CMsgGCToClientOverworldUserDataUpdated&& from) noexcept
    : CMsgGCToClientOverworldUserDataUpdated() {
    *this = ::std::move(from);
  }

  inline CMsgGCToClientOverworldUserDataUpdated& operator=(const CMsgGCToClientOverworldUserDataUpdated& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGCToClientOverworldUserDataUpdated& operator=(CMsgGCToClientOverworldUserDataUpdated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGCToClientOverworldUserDataUpdated& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGCToClientOverworldUserDataUpdated* internal_default_instance() {
    return reinterpret_cast<const CMsgGCToClientOverworldUserDataUpdated*>(
               &_CMsgGCToClientOverworldUserDataUpdated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CMsgGCToClientOverworldUserDataUpdated& a, CMsgGCToClientOverworldUserDataUpdated& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGCToClientOverworldUserDataUpdated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGCToClientOverworldUserDataUpdated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGCToClientOverworldUserDataUpdated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGCToClientOverworldUserDataUpdated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGCToClientOverworldUserDataUpdated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgGCToClientOverworldUserDataUpdated& from) {
    CMsgGCToClientOverworldUserDataUpdated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGCToClientOverworldUserDataUpdated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGCToClientOverworldUserDataUpdated";
  }
  protected:
  explicit CMsgGCToClientOverworldUserDataUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserDataFieldNumber = 2,
    kOverworldIdFieldNumber = 1,
  };
  // optional .CMsgOverworldUserData user_data = 2;
  bool has_user_data() const;
  private:
  bool _internal_has_user_data() const;
  public:
  void clear_user_data();
  const ::CMsgOverworldUserData& user_data() const;
  PROTOBUF_NODISCARD ::CMsgOverworldUserData* release_user_data();
  ::CMsgOverworldUserData* mutable_user_data();
  void set_allocated_user_data(::CMsgOverworldUserData* user_data);
  private:
  const ::CMsgOverworldUserData& _internal_user_data() const;
  ::CMsgOverworldUserData* _internal_mutable_user_data();
  public:
  void unsafe_arena_set_allocated_user_data(
      ::CMsgOverworldUserData* user_data);
  ::CMsgOverworldUserData* unsafe_arena_release_user_data();

  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGCToClientOverworldUserDataUpdated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldUserData* user_data_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldCompletePath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldCompletePath) */ {
 public:
  inline CMsgClientToGCOverworldCompletePath() : CMsgClientToGCOverworldCompletePath(nullptr) {}
  ~CMsgClientToGCOverworldCompletePath() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldCompletePath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldCompletePath(const CMsgClientToGCOverworldCompletePath& from);
  CMsgClientToGCOverworldCompletePath(CMsgClientToGCOverworldCompletePath&& from) noexcept
    : CMsgClientToGCOverworldCompletePath() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldCompletePath& operator=(const CMsgClientToGCOverworldCompletePath& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldCompletePath& operator=(CMsgClientToGCOverworldCompletePath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldCompletePath& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldCompletePath* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldCompletePath*>(
               &_CMsgClientToGCOverworldCompletePath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CMsgClientToGCOverworldCompletePath& a, CMsgClientToGCOverworldCompletePath& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldCompletePath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldCompletePath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldCompletePath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldCompletePath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldCompletePath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldCompletePath& from) {
    CMsgClientToGCOverworldCompletePath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldCompletePath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldCompletePath";
  }
  protected:
  explicit CMsgClientToGCOverworldCompletePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
    kPathIdFieldNumber = 2,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 path_id = 2;
  bool has_path_id() const;
  private:
  bool _internal_has_path_id() const;
  public:
  void clear_path_id();
  uint32_t path_id() const;
  void set_path_id(uint32_t value);
  private:
  uint32_t _internal_path_id() const;
  void _internal_set_path_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldCompletePath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
    uint32_t path_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldCompletePathResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldCompletePathResponse) */ {
 public:
  inline CMsgClientToGCOverworldCompletePathResponse() : CMsgClientToGCOverworldCompletePathResponse(nullptr) {}
  ~CMsgClientToGCOverworldCompletePathResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldCompletePathResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldCompletePathResponse(const CMsgClientToGCOverworldCompletePathResponse& from);
  CMsgClientToGCOverworldCompletePathResponse(CMsgClientToGCOverworldCompletePathResponse&& from) noexcept
    : CMsgClientToGCOverworldCompletePathResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldCompletePathResponse& operator=(const CMsgClientToGCOverworldCompletePathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldCompletePathResponse& operator=(CMsgClientToGCOverworldCompletePathResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldCompletePathResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldCompletePathResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldCompletePathResponse*>(
               &_CMsgClientToGCOverworldCompletePathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CMsgClientToGCOverworldCompletePathResponse& a, CMsgClientToGCOverworldCompletePathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldCompletePathResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldCompletePathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldCompletePathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldCompletePathResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldCompletePathResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldCompletePathResponse& from) {
    CMsgClientToGCOverworldCompletePathResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldCompletePathResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldCompletePathResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldCompletePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldCompletePathResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidPath =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eInvalidPath;
  static constexpr EResponse k_eNotEnoughTokens =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_eNotEnoughTokens;
  static constexpr EResponse k_ePathIsLocked =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_ePathIsLocked;
  static constexpr EResponse k_ePathAlreadyUnlocked =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_k_ePathAlreadyUnlocked;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldCompletePathResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldCompletePathResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldCompletePathResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldCompletePathResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldCompletePathResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClaimResponseFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
  bool has_claim_response() const;
  private:
  bool _internal_has_claim_response() const;
  public:
  void clear_claim_response();
  const ::CMsgDOTAClaimEventActionResponse& claim_response() const;
  PROTOBUF_NODISCARD ::CMsgDOTAClaimEventActionResponse* release_claim_response();
  ::CMsgDOTAClaimEventActionResponse* mutable_claim_response();
  void set_allocated_claim_response(::CMsgDOTAClaimEventActionResponse* claim_response);
  private:
  const ::CMsgDOTAClaimEventActionResponse& _internal_claim_response() const;
  ::CMsgDOTAClaimEventActionResponse* _internal_mutable_claim_response();
  public:
  void unsafe_arena_set_allocated_claim_response(
      ::CMsgDOTAClaimEventActionResponse* claim_response);
  ::CMsgDOTAClaimEventActionResponse* unsafe_arena_release_claim_response();

  // optional .CMsgClientToGCOverworldCompletePathResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldCompletePathResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldCompletePathResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldCompletePathResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldCompletePathResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldCompletePathResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgDOTAClaimEventActionResponse* claim_response_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgOverworldEncounterPitFighterRewardData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgOverworldEncounterPitFighterRewardData) */ {
 public:
  inline CMsgOverworldEncounterPitFighterRewardData() : CMsgOverworldEncounterPitFighterRewardData(nullptr) {}
  ~CMsgOverworldEncounterPitFighterRewardData() override;
  explicit PROTOBUF_CONSTEXPR CMsgOverworldEncounterPitFighterRewardData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgOverworldEncounterPitFighterRewardData(const CMsgOverworldEncounterPitFighterRewardData& from);
  CMsgOverworldEncounterPitFighterRewardData(CMsgOverworldEncounterPitFighterRewardData&& from) noexcept
    : CMsgOverworldEncounterPitFighterRewardData() {
    *this = ::std::move(from);
  }

  inline CMsgOverworldEncounterPitFighterRewardData& operator=(const CMsgOverworldEncounterPitFighterRewardData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgOverworldEncounterPitFighterRewardData& operator=(CMsgOverworldEncounterPitFighterRewardData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgOverworldEncounterPitFighterRewardData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgOverworldEncounterPitFighterRewardData* internal_default_instance() {
    return reinterpret_cast<const CMsgOverworldEncounterPitFighterRewardData*>(
               &_CMsgOverworldEncounterPitFighterRewardData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CMsgOverworldEncounterPitFighterRewardData& a, CMsgOverworldEncounterPitFighterRewardData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgOverworldEncounterPitFighterRewardData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgOverworldEncounterPitFighterRewardData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgOverworldEncounterPitFighterRewardData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgOverworldEncounterPitFighterRewardData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgOverworldEncounterPitFighterRewardData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgOverworldEncounterPitFighterRewardData& from) {
    CMsgOverworldEncounterPitFighterRewardData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgOverworldEncounterPitFighterRewardData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgOverworldEncounterPitFighterRewardData";
  }
  protected:
  explicit CMsgOverworldEncounterPitFighterRewardData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kChoiceFieldNumber = 2,
  };
  // optional uint32 token_id = 1;
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint32_t token_id() const;
  void set_token_id(uint32_t value);
  private:
  uint32_t _internal_token_id() const;
  void _internal_set_token_id(uint32_t value);
  public:

  // optional uint32 choice = 2;
  bool has_choice() const;
  private:
  bool _internal_has_choice() const;
  public:
  void clear_choice();
  uint32_t choice() const;
  void set_choice(uint32_t value);
  private:
  uint32_t _internal_choice() const;
  void _internal_set_choice(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgOverworldEncounterPitFighterRewardData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t token_id_;
    uint32_t choice_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldClaimEncounterReward final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldClaimEncounterReward) */ {
 public:
  inline CMsgClientToGCOverworldClaimEncounterReward() : CMsgClientToGCOverworldClaimEncounterReward(nullptr) {}
  ~CMsgClientToGCOverworldClaimEncounterReward() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldClaimEncounterReward(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldClaimEncounterReward(const CMsgClientToGCOverworldClaimEncounterReward& from);
  CMsgClientToGCOverworldClaimEncounterReward(CMsgClientToGCOverworldClaimEncounterReward&& from) noexcept
    : CMsgClientToGCOverworldClaimEncounterReward() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldClaimEncounterReward& operator=(const CMsgClientToGCOverworldClaimEncounterReward& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldClaimEncounterReward& operator=(CMsgClientToGCOverworldClaimEncounterReward&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldClaimEncounterReward& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldClaimEncounterReward* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldClaimEncounterReward*>(
               &_CMsgClientToGCOverworldClaimEncounterReward_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CMsgClientToGCOverworldClaimEncounterReward& a, CMsgClientToGCOverworldClaimEncounterReward& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldClaimEncounterReward* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldClaimEncounterReward* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldClaimEncounterReward* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldClaimEncounterReward>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldClaimEncounterReward& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldClaimEncounterReward& from) {
    CMsgClientToGCOverworldClaimEncounterReward::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldClaimEncounterReward* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldClaimEncounterReward";
  }
  protected:
  explicit CMsgClientToGCOverworldClaimEncounterReward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraRewardDataFieldNumber = 5,
    kOverworldIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kRewardDataFieldNumber = 3,
    kPeriodicResourceIdFieldNumber = 4,
  };
  // optional .CMsgOverworldEncounterData extra_reward_data = 5;
  bool has_extra_reward_data() const;
  private:
  bool _internal_has_extra_reward_data() const;
  public:
  void clear_extra_reward_data();
  const ::CMsgOverworldEncounterData& extra_reward_data() const;
  PROTOBUF_NODISCARD ::CMsgOverworldEncounterData* release_extra_reward_data();
  ::CMsgOverworldEncounterData* mutable_extra_reward_data();
  void set_allocated_extra_reward_data(::CMsgOverworldEncounterData* extra_reward_data);
  private:
  const ::CMsgOverworldEncounterData& _internal_extra_reward_data() const;
  ::CMsgOverworldEncounterData* _internal_mutable_extra_reward_data();
  public:
  void unsafe_arena_set_allocated_extra_reward_data(
      ::CMsgOverworldEncounterData* extra_reward_data);
  ::CMsgOverworldEncounterData* unsafe_arena_release_extra_reward_data();

  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // optional uint32 reward_data = 3;
  bool has_reward_data() const;
  private:
  bool _internal_has_reward_data() const;
  public:
  void clear_reward_data();
  uint32_t reward_data() const;
  void set_reward_data(uint32_t value);
  private:
  uint32_t _internal_reward_data() const;
  void _internal_set_reward_data(uint32_t value);
  public:

  // optional uint32 periodic_resource_id = 4;
  bool has_periodic_resource_id() const;
  private:
  bool _internal_has_periodic_resource_id() const;
  public:
  void clear_periodic_resource_id();
  uint32_t periodic_resource_id() const;
  void set_periodic_resource_id(uint32_t value);
  private:
  uint32_t _internal_periodic_resource_id() const;
  void _internal_set_periodic_resource_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldClaimEncounterReward)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldEncounterData* extra_reward_data_;
    uint32_t overworld_id_;
    uint32_t node_id_;
    uint32_t reward_data_;
    uint32_t periodic_resource_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldClaimEncounterRewardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldClaimEncounterRewardResponse) */ {
 public:
  inline CMsgClientToGCOverworldClaimEncounterRewardResponse() : CMsgClientToGCOverworldClaimEncounterRewardResponse(nullptr) {}
  ~CMsgClientToGCOverworldClaimEncounterRewardResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldClaimEncounterRewardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldClaimEncounterRewardResponse(const CMsgClientToGCOverworldClaimEncounterRewardResponse& from);
  CMsgClientToGCOverworldClaimEncounterRewardResponse(CMsgClientToGCOverworldClaimEncounterRewardResponse&& from) noexcept
    : CMsgClientToGCOverworldClaimEncounterRewardResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldClaimEncounterRewardResponse& operator=(const CMsgClientToGCOverworldClaimEncounterRewardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldClaimEncounterRewardResponse& operator=(CMsgClientToGCOverworldClaimEncounterRewardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldClaimEncounterRewardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldClaimEncounterRewardResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldClaimEncounterRewardResponse*>(
               &_CMsgClientToGCOverworldClaimEncounterRewardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CMsgClientToGCOverworldClaimEncounterRewardResponse& a, CMsgClientToGCOverworldClaimEncounterRewardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldClaimEncounterRewardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldClaimEncounterRewardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldClaimEncounterRewardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldClaimEncounterRewardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldClaimEncounterRewardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldClaimEncounterRewardResponse& from) {
    CMsgClientToGCOverworldClaimEncounterRewardResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldClaimEncounterRewardResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldClaimEncounterRewardResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldClaimEncounterRewardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidNode =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidNode;
  static constexpr EResponse k_eNodeLocked =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNodeLocked;
  static constexpr EResponse k_eRewardAlreadyClaimed =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eRewardAlreadyClaimed;
  static constexpr EResponse k_eNodeNotEncounter =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNodeNotEncounter;
  static constexpr EResponse k_eEncounterMissingRewards =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eEncounterMissingRewards;
  static constexpr EResponse k_eInvalidEncounterRewardStyle =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidEncounterRewardStyle;
  static constexpr EResponse k_eInvalidEncounterData =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eInvalidEncounterData;
  static constexpr EResponse k_eNotEnoughTokensForReward =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNotEnoughTokensForReward;
  static constexpr EResponse k_eNotEnoughResourceForReward =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_k_eNotEnoughResourceForReward;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClaimResponseFieldNumber = 2,
    kTokensReceivedFieldNumber = 3,
    kResponseFieldNumber = 1,
  };
  // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
  bool has_claim_response() const;
  private:
  bool _internal_has_claim_response() const;
  public:
  void clear_claim_response();
  const ::CMsgDOTAClaimEventActionResponse& claim_response() const;
  PROTOBUF_NODISCARD ::CMsgDOTAClaimEventActionResponse* release_claim_response();
  ::CMsgDOTAClaimEventActionResponse* mutable_claim_response();
  void set_allocated_claim_response(::CMsgDOTAClaimEventActionResponse* claim_response);
  private:
  const ::CMsgDOTAClaimEventActionResponse& _internal_claim_response() const;
  ::CMsgDOTAClaimEventActionResponse* _internal_mutable_claim_response();
  public:
  void unsafe_arena_set_allocated_claim_response(
      ::CMsgDOTAClaimEventActionResponse* claim_response);
  ::CMsgDOTAClaimEventActionResponse* unsafe_arena_release_claim_response();

  // optional .CMsgOverworldTokenQuantity tokens_received = 3;
  bool has_tokens_received() const;
  private:
  bool _internal_has_tokens_received() const;
  public:
  void clear_tokens_received();
  const ::CMsgOverworldTokenQuantity& tokens_received() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_tokens_received();
  ::CMsgOverworldTokenQuantity* mutable_tokens_received();
  void set_allocated_tokens_received(::CMsgOverworldTokenQuantity* tokens_received);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_tokens_received() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_tokens_received();
  public:
  void unsafe_arena_set_allocated_tokens_received(
      ::CMsgOverworldTokenQuantity* tokens_received);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_tokens_received();

  // optional .CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldClaimEncounterRewardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgDOTAClaimEventActionResponse* claim_response_;
    ::CMsgOverworldTokenQuantity* tokens_received_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldVisitEncounter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldVisitEncounter) */ {
 public:
  inline CMsgClientToGCOverworldVisitEncounter() : CMsgClientToGCOverworldVisitEncounter(nullptr) {}
  ~CMsgClientToGCOverworldVisitEncounter() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldVisitEncounter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldVisitEncounter(const CMsgClientToGCOverworldVisitEncounter& from);
  CMsgClientToGCOverworldVisitEncounter(CMsgClientToGCOverworldVisitEncounter&& from) noexcept
    : CMsgClientToGCOverworldVisitEncounter() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldVisitEncounter& operator=(const CMsgClientToGCOverworldVisitEncounter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldVisitEncounter& operator=(CMsgClientToGCOverworldVisitEncounter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldVisitEncounter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldVisitEncounter* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldVisitEncounter*>(
               &_CMsgClientToGCOverworldVisitEncounter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CMsgClientToGCOverworldVisitEncounter& a, CMsgClientToGCOverworldVisitEncounter& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldVisitEncounter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldVisitEncounter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldVisitEncounter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldVisitEncounter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldVisitEncounter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldVisitEncounter& from) {
    CMsgClientToGCOverworldVisitEncounter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldVisitEncounter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldVisitEncounter";
  }
  protected:
  explicit CMsgClientToGCOverworldVisitEncounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldVisitEncounter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
    uint32_t node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldVisitEncounterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldVisitEncounterResponse) */ {
 public:
  inline CMsgClientToGCOverworldVisitEncounterResponse() : CMsgClientToGCOverworldVisitEncounterResponse(nullptr) {}
  ~CMsgClientToGCOverworldVisitEncounterResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldVisitEncounterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldVisitEncounterResponse(const CMsgClientToGCOverworldVisitEncounterResponse& from);
  CMsgClientToGCOverworldVisitEncounterResponse(CMsgClientToGCOverworldVisitEncounterResponse&& from) noexcept
    : CMsgClientToGCOverworldVisitEncounterResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldVisitEncounterResponse& operator=(const CMsgClientToGCOverworldVisitEncounterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldVisitEncounterResponse& operator=(CMsgClientToGCOverworldVisitEncounterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldVisitEncounterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldVisitEncounterResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldVisitEncounterResponse*>(
               &_CMsgClientToGCOverworldVisitEncounterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CMsgClientToGCOverworldVisitEncounterResponse& a, CMsgClientToGCOverworldVisitEncounterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldVisitEncounterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldVisitEncounterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldVisitEncounterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldVisitEncounterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldVisitEncounterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldVisitEncounterResponse& from) {
    CMsgClientToGCOverworldVisitEncounterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldVisitEncounterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldVisitEncounterResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldVisitEncounterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldVisitEncounterResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidNode =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eInvalidNode;
  static constexpr EResponse k_eNodeLocked =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eNodeLocked;
  static constexpr EResponse k_eNodeNotEncounter =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eNodeNotEncounter;
  static constexpr EResponse k_eAlreadyVisited =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_k_eAlreadyVisited;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldVisitEncounterResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldVisitEncounterResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldVisitEncounterResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldVisitEncounterResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldVisitEncounterResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldVisitEncounterResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldVisitEncounterResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldVisitEncounterResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldVisitEncounterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldMoveToNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldMoveToNode) */ {
 public:
  inline CMsgClientToGCOverworldMoveToNode() : CMsgClientToGCOverworldMoveToNode(nullptr) {}
  ~CMsgClientToGCOverworldMoveToNode() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldMoveToNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldMoveToNode(const CMsgClientToGCOverworldMoveToNode& from);
  CMsgClientToGCOverworldMoveToNode(CMsgClientToGCOverworldMoveToNode&& from) noexcept
    : CMsgClientToGCOverworldMoveToNode() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldMoveToNode& operator=(const CMsgClientToGCOverworldMoveToNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldMoveToNode& operator=(CMsgClientToGCOverworldMoveToNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldMoveToNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldMoveToNode* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldMoveToNode*>(
               &_CMsgClientToGCOverworldMoveToNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CMsgClientToGCOverworldMoveToNode& a, CMsgClientToGCOverworldMoveToNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldMoveToNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldMoveToNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldMoveToNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldMoveToNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldMoveToNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldMoveToNode& from) {
    CMsgClientToGCOverworldMoveToNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldMoveToNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldMoveToNode";
  }
  protected:
  explicit CMsgClientToGCOverworldMoveToNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldMoveToNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
    uint32_t node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldMoveToNodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldMoveToNodeResponse) */ {
 public:
  inline CMsgClientToGCOverworldMoveToNodeResponse() : CMsgClientToGCOverworldMoveToNodeResponse(nullptr) {}
  ~CMsgClientToGCOverworldMoveToNodeResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldMoveToNodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldMoveToNodeResponse(const CMsgClientToGCOverworldMoveToNodeResponse& from);
  CMsgClientToGCOverworldMoveToNodeResponse(CMsgClientToGCOverworldMoveToNodeResponse&& from) noexcept
    : CMsgClientToGCOverworldMoveToNodeResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldMoveToNodeResponse& operator=(const CMsgClientToGCOverworldMoveToNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldMoveToNodeResponse& operator=(CMsgClientToGCOverworldMoveToNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldMoveToNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldMoveToNodeResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldMoveToNodeResponse*>(
               &_CMsgClientToGCOverworldMoveToNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CMsgClientToGCOverworldMoveToNodeResponse& a, CMsgClientToGCOverworldMoveToNodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldMoveToNodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldMoveToNodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldMoveToNodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldMoveToNodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldMoveToNodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldMoveToNodeResponse& from) {
    CMsgClientToGCOverworldMoveToNodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldMoveToNodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldMoveToNodeResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldMoveToNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldMoveToNodeResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidNode =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eInvalidNode;
  static constexpr EResponse k_eNodeLocked =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_k_eNodeLocked;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldMoveToNodeResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldMoveToNodeResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldMoveToNodeResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldMoveToNodeResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldMoveToNodeResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldMoveToNodeResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldMoveToNodeResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldMoveToNodeResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldMoveToNodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldTradeTokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldTradeTokens) */ {
 public:
  inline CMsgClientToGCOverworldTradeTokens() : CMsgClientToGCOverworldTradeTokens(nullptr) {}
  ~CMsgClientToGCOverworldTradeTokens() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldTradeTokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldTradeTokens(const CMsgClientToGCOverworldTradeTokens& from);
  CMsgClientToGCOverworldTradeTokens(CMsgClientToGCOverworldTradeTokens&& from) noexcept
    : CMsgClientToGCOverworldTradeTokens() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldTradeTokens& operator=(const CMsgClientToGCOverworldTradeTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldTradeTokens& operator=(CMsgClientToGCOverworldTradeTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldTradeTokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldTradeTokens* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldTradeTokens*>(
               &_CMsgClientToGCOverworldTradeTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CMsgClientToGCOverworldTradeTokens& a, CMsgClientToGCOverworldTradeTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldTradeTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldTradeTokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldTradeTokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldTradeTokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldTradeTokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldTradeTokens& from) {
    CMsgClientToGCOverworldTradeTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldTradeTokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldTradeTokens";
  }
  protected:
  explicit CMsgClientToGCOverworldTradeTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenOfferFieldNumber = 2,
    kTokenRequestFieldNumber = 3,
    kOverworldIdFieldNumber = 1,
    kRecipeFieldNumber = 4,
    kEncounterIdFieldNumber = 5,
  };
  // optional .CMsgOverworldTokenQuantity token_offer = 2;
  bool has_token_offer() const;
  private:
  bool _internal_has_token_offer() const;
  public:
  void clear_token_offer();
  const ::CMsgOverworldTokenQuantity& token_offer() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_offer();
  ::CMsgOverworldTokenQuantity* mutable_token_offer();
  void set_allocated_token_offer(::CMsgOverworldTokenQuantity* token_offer);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_offer() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_offer();
  public:
  void unsafe_arena_set_allocated_token_offer(
      ::CMsgOverworldTokenQuantity* token_offer);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_offer();

  // optional .CMsgOverworldTokenQuantity token_request = 3;
  bool has_token_request() const;
  private:
  bool _internal_has_token_request() const;
  public:
  void clear_token_request();
  const ::CMsgOverworldTokenQuantity& token_request() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_request();
  ::CMsgOverworldTokenQuantity* mutable_token_request();
  void set_allocated_token_request(::CMsgOverworldTokenQuantity* token_request);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_request() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_request();
  public:
  void unsafe_arena_set_allocated_token_request(
      ::CMsgOverworldTokenQuantity* token_request);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_request();

  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 recipe = 4;
  bool has_recipe() const;
  private:
  bool _internal_has_recipe() const;
  public:
  void clear_recipe();
  uint32_t recipe() const;
  void set_recipe(uint32_t value);
  private:
  uint32_t _internal_recipe() const;
  void _internal_set_recipe(uint32_t value);
  public:

  // optional uint32 encounter_id = 5;
  bool has_encounter_id() const;
  private:
  bool _internal_has_encounter_id() const;
  public:
  void clear_encounter_id();
  uint32_t encounter_id() const;
  void set_encounter_id(uint32_t value);
  private:
  uint32_t _internal_encounter_id() const;
  void _internal_set_encounter_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldTradeTokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* token_offer_;
    ::CMsgOverworldTokenQuantity* token_request_;
    uint32_t overworld_id_;
    uint32_t recipe_;
    uint32_t encounter_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldTradeTokensResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldTradeTokensResponse) */ {
 public:
  inline CMsgClientToGCOverworldTradeTokensResponse() : CMsgClientToGCOverworldTradeTokensResponse(nullptr) {}
  ~CMsgClientToGCOverworldTradeTokensResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldTradeTokensResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldTradeTokensResponse(const CMsgClientToGCOverworldTradeTokensResponse& from);
  CMsgClientToGCOverworldTradeTokensResponse(CMsgClientToGCOverworldTradeTokensResponse&& from) noexcept
    : CMsgClientToGCOverworldTradeTokensResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldTradeTokensResponse& operator=(const CMsgClientToGCOverworldTradeTokensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldTradeTokensResponse& operator=(CMsgClientToGCOverworldTradeTokensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldTradeTokensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldTradeTokensResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldTradeTokensResponse*>(
               &_CMsgClientToGCOverworldTradeTokensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CMsgClientToGCOverworldTradeTokensResponse& a, CMsgClientToGCOverworldTradeTokensResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldTradeTokensResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldTradeTokensResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldTradeTokensResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldTradeTokensResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldTradeTokensResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldTradeTokensResponse& from) {
    CMsgClientToGCOverworldTradeTokensResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldTradeTokensResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldTradeTokensResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldTradeTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldTradeTokensResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eNodeLocked =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eNodeLocked;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidOffer =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidOffer;
  static constexpr EResponse k_eNotEnoughTokens =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eNotEnoughTokens;
  static constexpr EResponse k_eInvalidNode =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidNode;
  static constexpr EResponse k_eInvalidEncounter =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eInvalidEncounter;
  static constexpr EResponse k_eRewardDoesNotMatchRecipe =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_k_eRewardDoesNotMatchRecipe;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldTradeTokensResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldTradeTokensResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldTradeTokensResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldTradeTokensResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldTradeTokensResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTokensReceivedFieldNumber = 2,
    kResponseFieldNumber = 1,
  };
  // optional .CMsgOverworldTokenQuantity tokens_received = 2;
  bool has_tokens_received() const;
  private:
  bool _internal_has_tokens_received() const;
  public:
  void clear_tokens_received();
  const ::CMsgOverworldTokenQuantity& tokens_received() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_tokens_received();
  ::CMsgOverworldTokenQuantity* mutable_tokens_received();
  void set_allocated_tokens_received(::CMsgOverworldTokenQuantity* tokens_received);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_tokens_received() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_tokens_received();
  public:
  void unsafe_arena_set_allocated_tokens_received(
      ::CMsgOverworldTokenQuantity* tokens_received);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_tokens_received();

  // optional .CMsgClientToGCOverworldTradeTokensResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldTradeTokensResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldTradeTokensResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldTradeTokensResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldTradeTokensResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldTradeTokensResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* tokens_received_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGiftTokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGiftTokens) */ {
 public:
  inline CMsgClientToGCOverworldGiftTokens() : CMsgClientToGCOverworldGiftTokens(nullptr) {}
  ~CMsgClientToGCOverworldGiftTokens() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGiftTokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGiftTokens(const CMsgClientToGCOverworldGiftTokens& from);
  CMsgClientToGCOverworldGiftTokens(CMsgClientToGCOverworldGiftTokens&& from) noexcept
    : CMsgClientToGCOverworldGiftTokens() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGiftTokens& operator=(const CMsgClientToGCOverworldGiftTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGiftTokens& operator=(CMsgClientToGCOverworldGiftTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGiftTokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGiftTokens* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGiftTokens*>(
               &_CMsgClientToGCOverworldGiftTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CMsgClientToGCOverworldGiftTokens& a, CMsgClientToGCOverworldGiftTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGiftTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGiftTokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGiftTokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGiftTokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGiftTokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGiftTokens& from) {
    CMsgClientToGCOverworldGiftTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGiftTokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGiftTokens";
  }
  protected:
  explicit CMsgClientToGCOverworldGiftTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenGiftFieldNumber = 2,
    kOverworldIdFieldNumber = 1,
    kRecipientAccountIdFieldNumber = 3,
    kPeriodicResourceIdFieldNumber = 4,
  };
  // optional .CMsgOverworldTokenCount token_gift = 2;
  bool has_token_gift() const;
  private:
  bool _internal_has_token_gift() const;
  public:
  void clear_token_gift();
  const ::CMsgOverworldTokenCount& token_gift() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenCount* release_token_gift();
  ::CMsgOverworldTokenCount* mutable_token_gift();
  void set_allocated_token_gift(::CMsgOverworldTokenCount* token_gift);
  private:
  const ::CMsgOverworldTokenCount& _internal_token_gift() const;
  ::CMsgOverworldTokenCount* _internal_mutable_token_gift();
  public:
  void unsafe_arena_set_allocated_token_gift(
      ::CMsgOverworldTokenCount* token_gift);
  ::CMsgOverworldTokenCount* unsafe_arena_release_token_gift();

  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 recipient_account_id = 3;
  bool has_recipient_account_id() const;
  private:
  bool _internal_has_recipient_account_id() const;
  public:
  void clear_recipient_account_id();
  uint32_t recipient_account_id() const;
  void set_recipient_account_id(uint32_t value);
  private:
  uint32_t _internal_recipient_account_id() const;
  void _internal_set_recipient_account_id(uint32_t value);
  public:

  // optional uint32 periodic_resource_id = 4;
  bool has_periodic_resource_id() const;
  private:
  bool _internal_has_periodic_resource_id() const;
  public:
  void clear_periodic_resource_id();
  uint32_t periodic_resource_id() const;
  void set_periodic_resource_id(uint32_t value);
  private:
  uint32_t _internal_periodic_resource_id() const;
  void _internal_set_periodic_resource_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGiftTokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenCount* token_gift_;
    uint32_t overworld_id_;
    uint32_t recipient_account_id_;
    uint32_t periodic_resource_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGiftTokensResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGiftTokensResponse) */ {
 public:
  inline CMsgClientToGCOverworldGiftTokensResponse() : CMsgClientToGCOverworldGiftTokensResponse(nullptr) {}
  ~CMsgClientToGCOverworldGiftTokensResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGiftTokensResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGiftTokensResponse(const CMsgClientToGCOverworldGiftTokensResponse& from);
  CMsgClientToGCOverworldGiftTokensResponse(CMsgClientToGCOverworldGiftTokensResponse&& from) noexcept
    : CMsgClientToGCOverworldGiftTokensResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGiftTokensResponse& operator=(const CMsgClientToGCOverworldGiftTokensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGiftTokensResponse& operator=(CMsgClientToGCOverworldGiftTokensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGiftTokensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGiftTokensResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGiftTokensResponse*>(
               &_CMsgClientToGCOverworldGiftTokensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CMsgClientToGCOverworldGiftTokensResponse& a, CMsgClientToGCOverworldGiftTokensResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGiftTokensResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGiftTokensResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGiftTokensResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGiftTokensResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGiftTokensResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGiftTokensResponse& from) {
    CMsgClientToGCOverworldGiftTokensResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGiftTokensResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGiftTokensResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldGiftTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldGiftTokensResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eNodeLocked =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNodeLocked;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidGift =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInvalidGift;
  static constexpr EResponse k_eNotEnoughTokens =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotEnoughTokens;
  static constexpr EResponse k_eInvalidRecipient =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eInvalidRecipient;
  static constexpr EResponse k_eNotEnoughPeriodicResource =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_k_eNotEnoughPeriodicResource;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldGiftTokensResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldGiftTokensResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldGiftTokensResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldGiftTokensResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldGiftTokensResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldGiftTokensResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldGiftTokensResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldGiftTokensResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldGiftTokensResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldGiftTokensResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGiftTokensResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevResetAll final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevResetAll) */ {
 public:
  inline CMsgClientToGCOverworldDevResetAll() : CMsgClientToGCOverworldDevResetAll(nullptr) {}
  ~CMsgClientToGCOverworldDevResetAll() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetAll(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevResetAll(const CMsgClientToGCOverworldDevResetAll& from);
  CMsgClientToGCOverworldDevResetAll(CMsgClientToGCOverworldDevResetAll&& from) noexcept
    : CMsgClientToGCOverworldDevResetAll() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevResetAll& operator=(const CMsgClientToGCOverworldDevResetAll& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevResetAll& operator=(CMsgClientToGCOverworldDevResetAll&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevResetAll& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevResetAll* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevResetAll*>(
               &_CMsgClientToGCOverworldDevResetAll_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CMsgClientToGCOverworldDevResetAll& a, CMsgClientToGCOverworldDevResetAll& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevResetAll* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevResetAll* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevResetAll* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevResetAll>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevResetAll& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevResetAll& from) {
    CMsgClientToGCOverworldDevResetAll::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevResetAll* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevResetAll";
  }
  protected:
  explicit CMsgClientToGCOverworldDevResetAll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevResetAll)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevResetAllResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevResetAllResponse) */ {
 public:
  inline CMsgClientToGCOverworldDevResetAllResponse() : CMsgClientToGCOverworldDevResetAllResponse(nullptr) {}
  ~CMsgClientToGCOverworldDevResetAllResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetAllResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevResetAllResponse(const CMsgClientToGCOverworldDevResetAllResponse& from);
  CMsgClientToGCOverworldDevResetAllResponse(CMsgClientToGCOverworldDevResetAllResponse&& from) noexcept
    : CMsgClientToGCOverworldDevResetAllResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevResetAllResponse& operator=(const CMsgClientToGCOverworldDevResetAllResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevResetAllResponse& operator=(CMsgClientToGCOverworldDevResetAllResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevResetAllResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevResetAllResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevResetAllResponse*>(
               &_CMsgClientToGCOverworldDevResetAllResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CMsgClientToGCOverworldDevResetAllResponse& a, CMsgClientToGCOverworldDevResetAllResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevResetAllResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevResetAllResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevResetAllResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevResetAllResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevResetAllResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevResetAllResponse& from) {
    CMsgClientToGCOverworldDevResetAllResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevResetAllResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevResetAllResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldDevResetAllResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldDevResetAllResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_k_eInvalidOverworld;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldDevResetAllResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldDevResetAllResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldDevResetAllResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldDevResetAllResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldDevResetAllResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldDevResetAllResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldDevResetAllResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldDevResetAllResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldDevResetAllResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldDevResetAllResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevResetAllResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevResetNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevResetNode) */ {
 public:
  inline CMsgClientToGCOverworldDevResetNode() : CMsgClientToGCOverworldDevResetNode(nullptr) {}
  ~CMsgClientToGCOverworldDevResetNode() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevResetNode(const CMsgClientToGCOverworldDevResetNode& from);
  CMsgClientToGCOverworldDevResetNode(CMsgClientToGCOverworldDevResetNode&& from) noexcept
    : CMsgClientToGCOverworldDevResetNode() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevResetNode& operator=(const CMsgClientToGCOverworldDevResetNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevResetNode& operator=(CMsgClientToGCOverworldDevResetNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevResetNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevResetNode* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevResetNode*>(
               &_CMsgClientToGCOverworldDevResetNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CMsgClientToGCOverworldDevResetNode& a, CMsgClientToGCOverworldDevResetNode& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevResetNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevResetNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevResetNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevResetNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevResetNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevResetNode& from) {
    CMsgClientToGCOverworldDevResetNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevResetNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevResetNode";
  }
  protected:
  explicit CMsgClientToGCOverworldDevResetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // optional uint32 node_id = 2;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  uint32_t node_id() const;
  void set_node_id(uint32_t value);
  private:
  uint32_t _internal_node_id() const;
  void _internal_set_node_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevResetNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
    uint32_t node_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevResetNodeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevResetNodeResponse) */ {
 public:
  inline CMsgClientToGCOverworldDevResetNodeResponse() : CMsgClientToGCOverworldDevResetNodeResponse(nullptr) {}
  ~CMsgClientToGCOverworldDevResetNodeResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetNodeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevResetNodeResponse(const CMsgClientToGCOverworldDevResetNodeResponse& from);
  CMsgClientToGCOverworldDevResetNodeResponse(CMsgClientToGCOverworldDevResetNodeResponse&& from) noexcept
    : CMsgClientToGCOverworldDevResetNodeResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevResetNodeResponse& operator=(const CMsgClientToGCOverworldDevResetNodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevResetNodeResponse& operator=(CMsgClientToGCOverworldDevResetNodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevResetNodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevResetNodeResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevResetNodeResponse*>(
               &_CMsgClientToGCOverworldDevResetNodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CMsgClientToGCOverworldDevResetNodeResponse& a, CMsgClientToGCOverworldDevResetNodeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevResetNodeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevResetNodeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevResetNodeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevResetNodeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevResetNodeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevResetNodeResponse& from) {
    CMsgClientToGCOverworldDevResetNodeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevResetNodeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevResetNodeResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldDevResetNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldDevResetNodeResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInvalidOverworld;
  static constexpr EResponse k_eInvalidNode =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_k_eInvalidNode;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldDevResetNodeResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldDevResetNodeResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldDevResetNodeResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldDevResetNodeResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldDevResetNodeResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldDevResetNodeResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldDevResetNodeResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldDevResetNodeResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevResetNodeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevGrantTokens final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevGrantTokens) */ {
 public:
  inline CMsgClientToGCOverworldDevGrantTokens() : CMsgClientToGCOverworldDevGrantTokens(nullptr) {}
  ~CMsgClientToGCOverworldDevGrantTokens() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevGrantTokens(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevGrantTokens(const CMsgClientToGCOverworldDevGrantTokens& from);
  CMsgClientToGCOverworldDevGrantTokens(CMsgClientToGCOverworldDevGrantTokens&& from) noexcept
    : CMsgClientToGCOverworldDevGrantTokens() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevGrantTokens& operator=(const CMsgClientToGCOverworldDevGrantTokens& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevGrantTokens& operator=(CMsgClientToGCOverworldDevGrantTokens&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevGrantTokens& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevGrantTokens* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevGrantTokens*>(
               &_CMsgClientToGCOverworldDevGrantTokens_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CMsgClientToGCOverworldDevGrantTokens& a, CMsgClientToGCOverworldDevGrantTokens& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevGrantTokens* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevGrantTokens* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevGrantTokens* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevGrantTokens>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevGrantTokens& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevGrantTokens& from) {
    CMsgClientToGCOverworldDevGrantTokens::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevGrantTokens* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevGrantTokens";
  }
  protected:
  explicit CMsgClientToGCOverworldDevGrantTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenQuantityFieldNumber = 2,
    kOverworldIdFieldNumber = 1,
  };
  // optional .CMsgOverworldTokenQuantity token_quantity = 2;
  bool has_token_quantity() const;
  private:
  bool _internal_has_token_quantity() const;
  public:
  void clear_token_quantity();
  const ::CMsgOverworldTokenQuantity& token_quantity() const;
  PROTOBUF_NODISCARD ::CMsgOverworldTokenQuantity* release_token_quantity();
  ::CMsgOverworldTokenQuantity* mutable_token_quantity();
  void set_allocated_token_quantity(::CMsgOverworldTokenQuantity* token_quantity);
  private:
  const ::CMsgOverworldTokenQuantity& _internal_token_quantity() const;
  ::CMsgOverworldTokenQuantity* _internal_mutable_token_quantity();
  public:
  void unsafe_arena_set_allocated_token_quantity(
      ::CMsgOverworldTokenQuantity* token_quantity);
  ::CMsgOverworldTokenQuantity* unsafe_arena_release_token_quantity();

  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevGrantTokens)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::CMsgOverworldTokenQuantity* token_quantity_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevGrantTokensResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevGrantTokensResponse) */ {
 public:
  inline CMsgClientToGCOverworldDevGrantTokensResponse() : CMsgClientToGCOverworldDevGrantTokensResponse(nullptr) {}
  ~CMsgClientToGCOverworldDevGrantTokensResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevGrantTokensResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevGrantTokensResponse(const CMsgClientToGCOverworldDevGrantTokensResponse& from);
  CMsgClientToGCOverworldDevGrantTokensResponse(CMsgClientToGCOverworldDevGrantTokensResponse&& from) noexcept
    : CMsgClientToGCOverworldDevGrantTokensResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevGrantTokensResponse& operator=(const CMsgClientToGCOverworldDevGrantTokensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevGrantTokensResponse& operator=(CMsgClientToGCOverworldDevGrantTokensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevGrantTokensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevGrantTokensResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevGrantTokensResponse*>(
               &_CMsgClientToGCOverworldDevGrantTokensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CMsgClientToGCOverworldDevGrantTokensResponse& a, CMsgClientToGCOverworldDevGrantTokensResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevGrantTokensResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevGrantTokensResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevGrantTokensResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevGrantTokensResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevGrantTokensResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevGrantTokensResponse& from) {
    CMsgClientToGCOverworldDevGrantTokensResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevGrantTokensResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevGrantTokensResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldDevGrantTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldDevGrantTokensResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_k_eInvalidOverworld;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldDevGrantTokensResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevGrantTokensResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevClearInventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevClearInventory) */ {
 public:
  inline CMsgClientToGCOverworldDevClearInventory() : CMsgClientToGCOverworldDevClearInventory(nullptr) {}
  ~CMsgClientToGCOverworldDevClearInventory() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevClearInventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevClearInventory(const CMsgClientToGCOverworldDevClearInventory& from);
  CMsgClientToGCOverworldDevClearInventory(CMsgClientToGCOverworldDevClearInventory&& from) noexcept
    : CMsgClientToGCOverworldDevClearInventory() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevClearInventory& operator=(const CMsgClientToGCOverworldDevClearInventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevClearInventory& operator=(CMsgClientToGCOverworldDevClearInventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevClearInventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevClearInventory* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevClearInventory*>(
               &_CMsgClientToGCOverworldDevClearInventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CMsgClientToGCOverworldDevClearInventory& a, CMsgClientToGCOverworldDevClearInventory& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevClearInventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevClearInventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevClearInventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevClearInventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevClearInventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevClearInventory& from) {
    CMsgClientToGCOverworldDevClearInventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevClearInventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevClearInventory";
  }
  protected:
  explicit CMsgClientToGCOverworldDevClearInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverworldIdFieldNumber = 1,
  };
  // optional uint32 overworld_id = 1;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevClearInventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldDevClearInventoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldDevClearInventoryResponse) */ {
 public:
  inline CMsgClientToGCOverworldDevClearInventoryResponse() : CMsgClientToGCOverworldDevClearInventoryResponse(nullptr) {}
  ~CMsgClientToGCOverworldDevClearInventoryResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevClearInventoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldDevClearInventoryResponse(const CMsgClientToGCOverworldDevClearInventoryResponse& from);
  CMsgClientToGCOverworldDevClearInventoryResponse(CMsgClientToGCOverworldDevClearInventoryResponse&& from) noexcept
    : CMsgClientToGCOverworldDevClearInventoryResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldDevClearInventoryResponse& operator=(const CMsgClientToGCOverworldDevClearInventoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldDevClearInventoryResponse& operator=(CMsgClientToGCOverworldDevClearInventoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldDevClearInventoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldDevClearInventoryResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldDevClearInventoryResponse*>(
               &_CMsgClientToGCOverworldDevClearInventoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CMsgClientToGCOverworldDevClearInventoryResponse& a, CMsgClientToGCOverworldDevClearInventoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldDevClearInventoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldDevClearInventoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldDevClearInventoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldDevClearInventoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldDevClearInventoryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldDevClearInventoryResponse& from) {
    CMsgClientToGCOverworldDevClearInventoryResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldDevClearInventoryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldDevClearInventoryResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldDevClearInventoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldDevClearInventoryResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_k_eInvalidOverworld;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldDevClearInventoryResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldDevClearInventoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldFeedback final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldFeedback) */ {
 public:
  inline CMsgClientToGCOverworldFeedback() : CMsgClientToGCOverworldFeedback(nullptr) {}
  ~CMsgClientToGCOverworldFeedback() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldFeedback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldFeedback(const CMsgClientToGCOverworldFeedback& from);
  CMsgClientToGCOverworldFeedback(CMsgClientToGCOverworldFeedback&& from) noexcept
    : CMsgClientToGCOverworldFeedback() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldFeedback& operator=(const CMsgClientToGCOverworldFeedback& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldFeedback& operator=(CMsgClientToGCOverworldFeedback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldFeedback& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldFeedback* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldFeedback*>(
               &_CMsgClientToGCOverworldFeedback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CMsgClientToGCOverworldFeedback& a, CMsgClientToGCOverworldFeedback& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldFeedback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldFeedback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldFeedback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldFeedback>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldFeedback& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldFeedback& from) {
    CMsgClientToGCOverworldFeedback::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldFeedback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldFeedback";
  }
  protected:
  explicit CMsgClientToGCOverworldFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackFieldNumber = 3,
    kLanguageFieldNumber = 1,
    kOverworldIdFieldNumber = 2,
  };
  // optional string feedback = 3;
  bool has_feedback() const;
  private:
  bool _internal_has_feedback() const;
  public:
  void clear_feedback();
  const std::string& feedback() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback();
  PROTOBUF_NODISCARD std::string* release_feedback();
  void set_allocated_feedback(std::string* feedback);
  private:
  const std::string& _internal_feedback() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback(const std::string& value);
  std::string* _internal_mutable_feedback();
  public:

  // optional uint32 language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  uint32_t language() const;
  void set_language(uint32_t value);
  private:
  uint32_t _internal_language() const;
  void _internal_set_language(uint32_t value);
  public:

  // optional uint32 overworld_id = 2;
  bool has_overworld_id() const;
  private:
  bool _internal_has_overworld_id() const;
  public:
  void clear_overworld_id();
  uint32_t overworld_id() const;
  void set_overworld_id(uint32_t value);
  private:
  uint32_t _internal_overworld_id() const;
  void _internal_set_overworld_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldFeedback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_;
    uint32_t language_;
    uint32_t overworld_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldFeedbackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldFeedbackResponse) */ {
 public:
  inline CMsgClientToGCOverworldFeedbackResponse() : CMsgClientToGCOverworldFeedbackResponse(nullptr) {}
  ~CMsgClientToGCOverworldFeedbackResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldFeedbackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldFeedbackResponse(const CMsgClientToGCOverworldFeedbackResponse& from);
  CMsgClientToGCOverworldFeedbackResponse(CMsgClientToGCOverworldFeedbackResponse&& from) noexcept
    : CMsgClientToGCOverworldFeedbackResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldFeedbackResponse& operator=(const CMsgClientToGCOverworldFeedbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldFeedbackResponse& operator=(CMsgClientToGCOverworldFeedbackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldFeedbackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldFeedbackResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldFeedbackResponse*>(
               &_CMsgClientToGCOverworldFeedbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CMsgClientToGCOverworldFeedbackResponse& a, CMsgClientToGCOverworldFeedbackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldFeedbackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldFeedbackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldFeedbackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldFeedbackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldFeedbackResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldFeedbackResponse& from) {
    CMsgClientToGCOverworldFeedbackResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldFeedbackResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldFeedbackResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldFeedbackResponse_EResponse EResponse;
  static constexpr EResponse k_eInternalError =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eInternalError;
  static constexpr EResponse k_eSuccess =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eSuccess;
  static constexpr EResponse k_eTooBusy =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eTooBusy;
  static constexpr EResponse k_eDisabled =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eDisabled;
  static constexpr EResponse k_eTimeout =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eTimeout;
  static constexpr EResponse k_eNotAllowed =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eNotAllowed;
  static constexpr EResponse k_eInvalidOverworld =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_k_eInvalidOverworld;
  static inline bool EResponse_IsValid(int value) {
    return CMsgClientToGCOverworldFeedbackResponse_EResponse_IsValid(value);
  }
  static constexpr EResponse EResponse_MIN =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_MIN;
  static constexpr EResponse EResponse_MAX =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_MAX;
  static constexpr int EResponse_ARRAYSIZE =
    CMsgClientToGCOverworldFeedbackResponse_EResponse_EResponse_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EResponse_descriptor() {
    return CMsgClientToGCOverworldFeedbackResponse_EResponse_descriptor();
  }
  template<typename T>
  static inline const std::string& EResponse_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EResponse>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EResponse_Name.");
    return CMsgClientToGCOverworldFeedbackResponse_EResponse_Name(enum_t_value);
  }
  static inline bool EResponse_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EResponse* value) {
    return CMsgClientToGCOverworldFeedbackResponse_EResponse_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
  };
  // optional .CMsgClientToGCOverworldFeedbackResponse.EResponse response = 1 [default = k_eInternalError];
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  ::CMsgClientToGCOverworldFeedbackResponse_EResponse response() const;
  void set_response(::CMsgClientToGCOverworldFeedbackResponse_EResponse value);
  private:
  ::CMsgClientToGCOverworldFeedbackResponse_EResponse _internal_response() const;
  void _internal_set_response(::CMsgClientToGCOverworldFeedbackResponse_EResponse value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldFeedbackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int response_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGetDynamicImage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGetDynamicImage) */ {
 public:
  inline CMsgClientToGCOverworldGetDynamicImage() : CMsgClientToGCOverworldGetDynamicImage(nullptr) {}
  ~CMsgClientToGCOverworldGetDynamicImage() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGetDynamicImage(const CMsgClientToGCOverworldGetDynamicImage& from);
  CMsgClientToGCOverworldGetDynamicImage(CMsgClientToGCOverworldGetDynamicImage&& from) noexcept
    : CMsgClientToGCOverworldGetDynamicImage() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGetDynamicImage& operator=(const CMsgClientToGCOverworldGetDynamicImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGetDynamicImage& operator=(CMsgClientToGCOverworldGetDynamicImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGetDynamicImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGetDynamicImage* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGetDynamicImage*>(
               &_CMsgClientToGCOverworldGetDynamicImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CMsgClientToGCOverworldGetDynamicImage& a, CMsgClientToGCOverworldGetDynamicImage& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGetDynamicImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGetDynamicImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGetDynamicImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGetDynamicImage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGetDynamicImage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGetDynamicImage& from) {
    CMsgClientToGCOverworldGetDynamicImage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGetDynamicImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGetDynamicImage";
  }
  protected:
  explicit CMsgClientToGCOverworldGetDynamicImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMagicFieldNumber = 1,
    kImageIdFieldNumber = 2,
    kLanguageFieldNumber = 3,
  };
  // optional uint32 magic = 1;
  bool has_magic() const;
  private:
  bool _internal_has_magic() const;
  public:
  void clear_magic();
  uint32_t magic() const;
  void set_magic(uint32_t value);
  private:
  uint32_t _internal_magic() const;
  void _internal_set_magic(uint32_t value);
  public:

  // optional uint32 image_id = 2;
  bool has_image_id() const;
  private:
  bool _internal_has_image_id() const;
  public:
  void clear_image_id();
  uint32_t image_id() const;
  void set_image_id(uint32_t value);
  private:
  uint32_t _internal_image_id() const;
  void _internal_set_image_id(uint32_t value);
  public:

  // optional uint32 language = 3;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  uint32_t language() const;
  void set_language(uint32_t value);
  private:
  uint32_t _internal_language() const;
  void _internal_set_language(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGetDynamicImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t magic_;
    uint32_t image_id_;
    uint32_t language_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGetDynamicImageResponse_Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGetDynamicImageResponse.Image) */ {
 public:
  inline CMsgClientToGCOverworldGetDynamicImageResponse_Image() : CMsgClientToGCOverworldGetDynamicImageResponse_Image(nullptr) {}
  ~CMsgClientToGCOverworldGetDynamicImageResponse_Image() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageResponse_Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGetDynamicImageResponse_Image(const CMsgClientToGCOverworldGetDynamicImageResponse_Image& from);
  CMsgClientToGCOverworldGetDynamicImageResponse_Image(CMsgClientToGCOverworldGetDynamicImageResponse_Image&& from) noexcept
    : CMsgClientToGCOverworldGetDynamicImageResponse_Image() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGetDynamicImageResponse_Image& operator=(const CMsgClientToGCOverworldGetDynamicImageResponse_Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGetDynamicImageResponse_Image& operator=(CMsgClientToGCOverworldGetDynamicImageResponse_Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGetDynamicImageResponse_Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGetDynamicImageResponse_Image* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGetDynamicImageResponse_Image*>(
               &_CMsgClientToGCOverworldGetDynamicImageResponse_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CMsgClientToGCOverworldGetDynamicImageResponse_Image& a, CMsgClientToGCOverworldGetDynamicImageResponse_Image& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGetDynamicImageResponse_Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGetDynamicImageResponse_Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGetDynamicImageResponse_Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGetDynamicImageResponse_Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGetDynamicImageResponse_Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGetDynamicImageResponse_Image& from) {
    CMsgClientToGCOverworldGetDynamicImageResponse_Image::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGetDynamicImageResponse_Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGetDynamicImageResponse.Image";
  }
  protected:
  explicit CMsgClientToGCOverworldGetDynamicImageResponse_Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageBytesFieldNumber = 4,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kFormatFieldNumber = 3,
  };
  // optional bytes image_bytes = 4;
  bool has_image_bytes() const;
  private:
  bool _internal_has_image_bytes() const;
  public:
  void clear_image_bytes();
  const std::string& image_bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_bytes();
  PROTOBUF_NODISCARD std::string* release_image_bytes();
  void set_allocated_image_bytes(std::string* image_bytes);
  private:
  const std::string& _internal_image_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_bytes(const std::string& value);
  std::string* _internal_mutable_image_bytes();
  public:

  // optional uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional .CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat format = 3 [default = k_eUnknown];
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat format() const;
  void set_format(::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat value);
  private:
  ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat _internal_format() const;
  void _internal_set_format(::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_bytes_;
    uint32_t width_;
    uint32_t height_;
    int format_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientToGCOverworldGetDynamicImageResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientToGCOverworldGetDynamicImageResponse) */ {
 public:
  inline CMsgClientToGCOverworldGetDynamicImageResponse() : CMsgClientToGCOverworldGetDynamicImageResponse(nullptr) {}
  ~CMsgClientToGCOverworldGetDynamicImageResponse() override;
  explicit PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientToGCOverworldGetDynamicImageResponse(const CMsgClientToGCOverworldGetDynamicImageResponse& from);
  CMsgClientToGCOverworldGetDynamicImageResponse(CMsgClientToGCOverworldGetDynamicImageResponse&& from) noexcept
    : CMsgClientToGCOverworldGetDynamicImageResponse() {
    *this = ::std::move(from);
  }

  inline CMsgClientToGCOverworldGetDynamicImageResponse& operator=(const CMsgClientToGCOverworldGetDynamicImageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientToGCOverworldGetDynamicImageResponse& operator=(CMsgClientToGCOverworldGetDynamicImageResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientToGCOverworldGetDynamicImageResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientToGCOverworldGetDynamicImageResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgClientToGCOverworldGetDynamicImageResponse*>(
               &_CMsgClientToGCOverworldGetDynamicImageResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CMsgClientToGCOverworldGetDynamicImageResponse& a, CMsgClientToGCOverworldGetDynamicImageResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientToGCOverworldGetDynamicImageResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientToGCOverworldGetDynamicImageResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientToGCOverworldGetDynamicImageResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientToGCOverworldGetDynamicImageResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientToGCOverworldGetDynamicImageResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CMsgClientToGCOverworldGetDynamicImageResponse& from) {
    CMsgClientToGCOverworldGetDynamicImageResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientToGCOverworldGetDynamicImageResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientToGCOverworldGetDynamicImageResponse";
  }
  protected:
  explicit CMsgClientToGCOverworldGetDynamicImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgClientToGCOverworldGetDynamicImageResponse_Image Image;

  typedef CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat EDynamicImageFormat;
  static constexpr EDynamicImageFormat k_eUnknown =
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_eUnknown;
  static constexpr EDynamicImageFormat k_ePNG =
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_ePNG;
  static constexpr EDynamicImageFormat k_eData =
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_k_eData;
  static inline bool EDynamicImageFormat_IsValid(int value) {
    return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_IsValid(value);
  }
  static constexpr EDynamicImageFormat EDynamicImageFormat_MIN =
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_MIN;
  static constexpr EDynamicImageFormat EDynamicImageFormat_MAX =
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_MAX;
  static constexpr int EDynamicImageFormat_ARRAYSIZE =
    CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_EDynamicImageFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EDynamicImageFormat_descriptor() {
    return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& EDynamicImageFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EDynamicImageFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EDynamicImageFormat_Name.");
    return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_Name(enum_t_value);
  }
  static inline bool EDynamicImageFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EDynamicImageFormat* value) {
    return CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 2,
    kImageIdFieldNumber = 1,
  };
  // repeated .CMsgClientToGCOverworldGetDynamicImageResponse.Image images = 2;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image >*
      mutable_images();
  private:
  const ::CMsgClientToGCOverworldGetDynamicImageResponse_Image& _internal_images(int index) const;
  ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* _internal_add_images();
  public:
  const ::CMsgClientToGCOverworldGetDynamicImageResponse_Image& images(int index) const;
  ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image >&
      images() const;

  // optional uint32 image_id = 1;
  bool has_image_id() const;
  private:
  bool _internal_has_image_id() const;
  public:
  void clear_image_id();
  uint32_t image_id() const;
  void set_image_id(uint32_t value);
  private:
  uint32_t _internal_image_id() const;
  void _internal_set_image_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientToGCOverworldGetDynamicImageResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image > images_;
    uint32_t image_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgOverworldTokenCount

// optional uint32 token_id = 1;
inline bool CMsgOverworldTokenCount::_internal_has_token_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgOverworldTokenCount::has_token_id() const {
  return _internal_has_token_id();
}
inline void CMsgOverworldTokenCount::clear_token_id() {
  _impl_.token_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgOverworldTokenCount::_internal_token_id() const {
  return _impl_.token_id_;
}
inline uint32_t CMsgOverworldTokenCount::token_id() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldTokenCount.token_id)
  return _internal_token_id();
}
inline void CMsgOverworldTokenCount::_internal_set_token_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_id_ = value;
}
inline void CMsgOverworldTokenCount::set_token_id(uint32_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldTokenCount.token_id)
}

// optional uint32 token_count = 2;
inline bool CMsgOverworldTokenCount::_internal_has_token_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldTokenCount::has_token_count() const {
  return _internal_has_token_count();
}
inline void CMsgOverworldTokenCount::clear_token_count() {
  _impl_.token_count_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgOverworldTokenCount::_internal_token_count() const {
  return _impl_.token_count_;
}
inline uint32_t CMsgOverworldTokenCount::token_count() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldTokenCount.token_count)
  return _internal_token_count();
}
inline void CMsgOverworldTokenCount::_internal_set_token_count(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.token_count_ = value;
}
inline void CMsgOverworldTokenCount::set_token_count(uint32_t value) {
  _internal_set_token_count(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldTokenCount.token_count)
}

// -------------------------------------------------------------------

// CMsgOverworldTokenQuantity

// repeated .CMsgOverworldTokenCount token_counts = 1;
inline int CMsgOverworldTokenQuantity::_internal_token_counts_size() const {
  return _impl_.token_counts_.size();
}
inline int CMsgOverworldTokenQuantity::token_counts_size() const {
  return _internal_token_counts_size();
}
inline void CMsgOverworldTokenQuantity::clear_token_counts() {
  _impl_.token_counts_.Clear();
}
inline ::CMsgOverworldTokenCount* CMsgOverworldTokenQuantity::mutable_token_counts(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldTokenQuantity.token_counts)
  return _impl_.token_counts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldTokenCount >*
CMsgOverworldTokenQuantity::mutable_token_counts() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldTokenQuantity.token_counts)
  return &_impl_.token_counts_;
}
inline const ::CMsgOverworldTokenCount& CMsgOverworldTokenQuantity::_internal_token_counts(int index) const {
  return _impl_.token_counts_.Get(index);
}
inline const ::CMsgOverworldTokenCount& CMsgOverworldTokenQuantity::token_counts(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldTokenQuantity.token_counts)
  return _internal_token_counts(index);
}
inline ::CMsgOverworldTokenCount* CMsgOverworldTokenQuantity::_internal_add_token_counts() {
  return _impl_.token_counts_.Add();
}
inline ::CMsgOverworldTokenCount* CMsgOverworldTokenQuantity::add_token_counts() {
  ::CMsgOverworldTokenCount* _add = _internal_add_token_counts();
  // @@protoc_insertion_point(field_add:CMsgOverworldTokenQuantity.token_counts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldTokenCount >&
CMsgOverworldTokenQuantity::token_counts() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldTokenQuantity.token_counts)
  return _impl_.token_counts_;
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterTokenTreasureData_RewardOption

// optional uint32 reward_data = 1;
inline bool CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_has_reward_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterTokenTreasureData_RewardOption::has_reward_data() const {
  return _internal_has_reward_data();
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::clear_reward_data() {
  _impl_.reward_data_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_reward_data() const {
  return _impl_.reward_data_;
}
inline uint32_t CMsgOverworldEncounterTokenTreasureData_RewardOption::reward_data() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenTreasureData.RewardOption.reward_data)
  return _internal_reward_data();
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_set_reward_data(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reward_data_ = value;
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::set_reward_data(uint32_t value) {
  _internal_set_reward_data(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterTokenTreasureData.RewardOption.reward_data)
}

// optional .CMsgOverworldTokenQuantity token_cost = 2;
inline bool CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_has_token_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_cost_ != nullptr);
  return value;
}
inline bool CMsgOverworldEncounterTokenTreasureData_RewardOption::has_token_cost() const {
  return _internal_has_token_cost();
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::clear_token_cost() {
  if (_impl_.token_cost_ != nullptr) _impl_.token_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_token_cost() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenTreasureData_RewardOption::token_cost() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_cost)
  return _internal_token_cost();
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::unsafe_arena_set_allocated_token_cost(
    ::CMsgOverworldTokenQuantity* token_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_cost_);
  }
  _impl_.token_cost_ = token_cost;
  if (token_cost) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_cost)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::release_token_cost() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_cost_;
  _impl_.token_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::unsafe_arena_release_token_cost() {
  // @@protoc_insertion_point(field_release:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_cost)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_cost_;
  _impl_.token_cost_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_mutable_token_cost() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_cost_ = p;
  }
  return _impl_.token_cost_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::mutable_token_cost() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_cost();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_cost)
  return _msg;
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::set_allocated_token_cost(::CMsgOverworldTokenQuantity* token_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_cost_;
  }
  if (token_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_cost);
    if (message_arena != submessage_arena) {
      token_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_cost, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_cost_ = token_cost;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_cost)
}

// optional .CMsgOverworldTokenQuantity token_reward = 3;
inline bool CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_has_token_reward() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_reward_ != nullptr);
  return value;
}
inline bool CMsgOverworldEncounterTokenTreasureData_RewardOption::has_token_reward() const {
  return _internal_has_token_reward();
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::clear_token_reward() {
  if (_impl_.token_reward_ != nullptr) _impl_.token_reward_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_token_reward() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_reward_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenTreasureData_RewardOption::token_reward() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_reward)
  return _internal_token_reward();
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::unsafe_arena_set_allocated_token_reward(
    ::CMsgOverworldTokenQuantity* token_reward) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_reward_);
  }
  _impl_.token_reward_ = token_reward;
  if (token_reward) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_reward)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::release_token_reward() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_reward_;
  _impl_.token_reward_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::unsafe_arena_release_token_reward() {
  // @@protoc_insertion_point(field_release:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_reward)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_reward_;
  _impl_.token_reward_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::_internal_mutable_token_reward() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.token_reward_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_reward_ = p;
  }
  return _impl_.token_reward_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenTreasureData_RewardOption::mutable_token_reward() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_reward();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_reward)
  return _msg;
}
inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::set_allocated_token_reward(::CMsgOverworldTokenQuantity* token_reward) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_reward_;
  }
  if (token_reward) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_reward);
    if (message_arena != submessage_arena) {
      token_reward = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_reward, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.token_reward_ = token_reward;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldEncounterTokenTreasureData.RewardOption.token_reward)
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterTokenTreasureData

// repeated .CMsgOverworldEncounterTokenTreasureData.RewardOption reward_options = 1;
inline int CMsgOverworldEncounterTokenTreasureData::_internal_reward_options_size() const {
  return _impl_.reward_options_.size();
}
inline int CMsgOverworldEncounterTokenTreasureData::reward_options_size() const {
  return _internal_reward_options_size();
}
inline void CMsgOverworldEncounterTokenTreasureData::clear_reward_options() {
  _impl_.reward_options_.Clear();
}
inline ::CMsgOverworldEncounterTokenTreasureData_RewardOption* CMsgOverworldEncounterTokenTreasureData::mutable_reward_options(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterTokenTreasureData.reward_options)
  return _impl_.reward_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenTreasureData_RewardOption >*
CMsgOverworldEncounterTokenTreasureData::mutable_reward_options() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldEncounterTokenTreasureData.reward_options)
  return &_impl_.reward_options_;
}
inline const ::CMsgOverworldEncounterTokenTreasureData_RewardOption& CMsgOverworldEncounterTokenTreasureData::_internal_reward_options(int index) const {
  return _impl_.reward_options_.Get(index);
}
inline const ::CMsgOverworldEncounterTokenTreasureData_RewardOption& CMsgOverworldEncounterTokenTreasureData::reward_options(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenTreasureData.reward_options)
  return _internal_reward_options(index);
}
inline ::CMsgOverworldEncounterTokenTreasureData_RewardOption* CMsgOverworldEncounterTokenTreasureData::_internal_add_reward_options() {
  return _impl_.reward_options_.Add();
}
inline ::CMsgOverworldEncounterTokenTreasureData_RewardOption* CMsgOverworldEncounterTokenTreasureData::add_reward_options() {
  ::CMsgOverworldEncounterTokenTreasureData_RewardOption* _add = _internal_add_reward_options();
  // @@protoc_insertion_point(field_add:CMsgOverworldEncounterTokenTreasureData.reward_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenTreasureData_RewardOption >&
CMsgOverworldEncounterTokenTreasureData::reward_options() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldEncounterTokenTreasureData.reward_options)
  return _impl_.reward_options_;
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterTokenQuestData_Quest

// optional uint32 reward_data = 1;
inline bool CMsgOverworldEncounterTokenQuestData_Quest::_internal_has_reward_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterTokenQuestData_Quest::has_reward_data() const {
  return _internal_has_reward_data();
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::clear_reward_data() {
  _impl_.reward_data_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgOverworldEncounterTokenQuestData_Quest::_internal_reward_data() const {
  return _impl_.reward_data_;
}
inline uint32_t CMsgOverworldEncounterTokenQuestData_Quest::reward_data() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenQuestData.Quest.reward_data)
  return _internal_reward_data();
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::_internal_set_reward_data(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.reward_data_ = value;
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::set_reward_data(uint32_t value) {
  _internal_set_reward_data(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterTokenQuestData.Quest.reward_data)
}

// optional .CMsgOverworldTokenQuantity token_cost = 2;
inline bool CMsgOverworldEncounterTokenQuestData_Quest::_internal_has_token_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_cost_ != nullptr);
  return value;
}
inline bool CMsgOverworldEncounterTokenQuestData_Quest::has_token_cost() const {
  return _internal_has_token_cost();
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::clear_token_cost() {
  if (_impl_.token_cost_ != nullptr) _impl_.token_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenQuestData_Quest::_internal_token_cost() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenQuestData_Quest::token_cost() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenQuestData.Quest.token_cost)
  return _internal_token_cost();
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::unsafe_arena_set_allocated_token_cost(
    ::CMsgOverworldTokenQuantity* token_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_cost_);
  }
  _impl_.token_cost_ = token_cost;
  if (token_cost) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldEncounterTokenQuestData.Quest.token_cost)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::release_token_cost() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_cost_;
  _impl_.token_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::unsafe_arena_release_token_cost() {
  // @@protoc_insertion_point(field_release:CMsgOverworldEncounterTokenQuestData.Quest.token_cost)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_cost_;
  _impl_.token_cost_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::_internal_mutable_token_cost() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_cost_ = p;
  }
  return _impl_.token_cost_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::mutable_token_cost() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_cost();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterTokenQuestData.Quest.token_cost)
  return _msg;
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::set_allocated_token_cost(::CMsgOverworldTokenQuantity* token_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_cost_;
  }
  if (token_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_cost);
    if (message_arena != submessage_arena) {
      token_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_cost, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_cost_ = token_cost;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldEncounterTokenQuestData.Quest.token_cost)
}

// optional .CMsgOverworldTokenQuantity token_reward = 3;
inline bool CMsgOverworldEncounterTokenQuestData_Quest::_internal_has_token_reward() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_reward_ != nullptr);
  return value;
}
inline bool CMsgOverworldEncounterTokenQuestData_Quest::has_token_reward() const {
  return _internal_has_token_reward();
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::clear_token_reward() {
  if (_impl_.token_reward_ != nullptr) _impl_.token_reward_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenQuestData_Quest::_internal_token_reward() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_reward_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldEncounterTokenQuestData_Quest::token_reward() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenQuestData.Quest.token_reward)
  return _internal_token_reward();
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::unsafe_arena_set_allocated_token_reward(
    ::CMsgOverworldTokenQuantity* token_reward) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_reward_);
  }
  _impl_.token_reward_ = token_reward;
  if (token_reward) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldEncounterTokenQuestData.Quest.token_reward)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::release_token_reward() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_reward_;
  _impl_.token_reward_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::unsafe_arena_release_token_reward() {
  // @@protoc_insertion_point(field_release:CMsgOverworldEncounterTokenQuestData.Quest.token_reward)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_reward_;
  _impl_.token_reward_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::_internal_mutable_token_reward() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.token_reward_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_reward_ = p;
  }
  return _impl_.token_reward_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldEncounterTokenQuestData_Quest::mutable_token_reward() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_reward();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterTokenQuestData.Quest.token_reward)
  return _msg;
}
inline void CMsgOverworldEncounterTokenQuestData_Quest::set_allocated_token_reward(::CMsgOverworldTokenQuantity* token_reward) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_reward_;
  }
  if (token_reward) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_reward);
    if (message_arena != submessage_arena) {
      token_reward = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_reward, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.token_reward_ = token_reward;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldEncounterTokenQuestData.Quest.token_reward)
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterTokenQuestData

// repeated .CMsgOverworldEncounterTokenQuestData.Quest quests = 1;
inline int CMsgOverworldEncounterTokenQuestData::_internal_quests_size() const {
  return _impl_.quests_.size();
}
inline int CMsgOverworldEncounterTokenQuestData::quests_size() const {
  return _internal_quests_size();
}
inline void CMsgOverworldEncounterTokenQuestData::clear_quests() {
  _impl_.quests_.Clear();
}
inline ::CMsgOverworldEncounterTokenQuestData_Quest* CMsgOverworldEncounterTokenQuestData::mutable_quests(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterTokenQuestData.quests)
  return _impl_.quests_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenQuestData_Quest >*
CMsgOverworldEncounterTokenQuestData::mutable_quests() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldEncounterTokenQuestData.quests)
  return &_impl_.quests_;
}
inline const ::CMsgOverworldEncounterTokenQuestData_Quest& CMsgOverworldEncounterTokenQuestData::_internal_quests(int index) const {
  return _impl_.quests_.Get(index);
}
inline const ::CMsgOverworldEncounterTokenQuestData_Quest& CMsgOverworldEncounterTokenQuestData::quests(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterTokenQuestData.quests)
  return _internal_quests(index);
}
inline ::CMsgOverworldEncounterTokenQuestData_Quest* CMsgOverworldEncounterTokenQuestData::_internal_add_quests() {
  return _impl_.quests_.Add();
}
inline ::CMsgOverworldEncounterTokenQuestData_Quest* CMsgOverworldEncounterTokenQuestData::add_quests() {
  ::CMsgOverworldEncounterTokenQuestData_Quest* _add = _internal_add_quests();
  // @@protoc_insertion_point(field_add:CMsgOverworldEncounterTokenQuestData.quests)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldEncounterTokenQuestData_Quest >&
CMsgOverworldEncounterTokenQuestData::quests() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldEncounterTokenQuestData.quests)
  return _impl_.quests_;
}

// -------------------------------------------------------------------

// CMsgOverworldHeroList

// repeated int32 hero_ids = 1;
inline int CMsgOverworldHeroList::_internal_hero_ids_size() const {
  return _impl_.hero_ids_.size();
}
inline int CMsgOverworldHeroList::hero_ids_size() const {
  return _internal_hero_ids_size();
}
inline void CMsgOverworldHeroList::clear_hero_ids() {
  _impl_.hero_ids_.Clear();
}
inline int32_t CMsgOverworldHeroList::_internal_hero_ids(int index) const {
  return _impl_.hero_ids_.Get(index);
}
inline int32_t CMsgOverworldHeroList::hero_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldHeroList.hero_ids)
  return _internal_hero_ids(index);
}
inline void CMsgOverworldHeroList::set_hero_ids(int index, int32_t value) {
  _impl_.hero_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgOverworldHeroList.hero_ids)
}
inline void CMsgOverworldHeroList::_internal_add_hero_ids(int32_t value) {
  _impl_.hero_ids_.Add(value);
}
inline void CMsgOverworldHeroList::add_hero_ids(int32_t value) {
  _internal_add_hero_ids(value);
  // @@protoc_insertion_point(field_add:CMsgOverworldHeroList.hero_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CMsgOverworldHeroList::_internal_hero_ids() const {
  return _impl_.hero_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
CMsgOverworldHeroList::hero_ids() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldHeroList.hero_ids)
  return _internal_hero_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CMsgOverworldHeroList::_internal_mutable_hero_ids() {
  return &_impl_.hero_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
CMsgOverworldHeroList::mutable_hero_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldHeroList.hero_ids)
  return _internal_mutable_hero_ids();
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterChooseHeroData

// optional .CMsgOverworldHeroList hero_list = 1;
inline bool CMsgOverworldEncounterChooseHeroData::_internal_has_hero_list() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.hero_list_ != nullptr);
  return value;
}
inline bool CMsgOverworldEncounterChooseHeroData::has_hero_list() const {
  return _internal_has_hero_list();
}
inline void CMsgOverworldEncounterChooseHeroData::clear_hero_list() {
  if (_impl_.hero_list_ != nullptr) _impl_.hero_list_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldHeroList& CMsgOverworldEncounterChooseHeroData::_internal_hero_list() const {
  const ::CMsgOverworldHeroList* p = _impl_.hero_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldHeroList&>(
      ::_CMsgOverworldHeroList_default_instance_);
}
inline const ::CMsgOverworldHeroList& CMsgOverworldEncounterChooseHeroData::hero_list() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterChooseHeroData.hero_list)
  return _internal_hero_list();
}
inline void CMsgOverworldEncounterChooseHeroData::unsafe_arena_set_allocated_hero_list(
    ::CMsgOverworldHeroList* hero_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.hero_list_);
  }
  _impl_.hero_list_ = hero_list;
  if (hero_list) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldEncounterChooseHeroData.hero_list)
}
inline ::CMsgOverworldHeroList* CMsgOverworldEncounterChooseHeroData::release_hero_list() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldHeroList* temp = _impl_.hero_list_;
  _impl_.hero_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldHeroList* CMsgOverworldEncounterChooseHeroData::unsafe_arena_release_hero_list() {
  // @@protoc_insertion_point(field_release:CMsgOverworldEncounterChooseHeroData.hero_list)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldHeroList* temp = _impl_.hero_list_;
  _impl_.hero_list_ = nullptr;
  return temp;
}
inline ::CMsgOverworldHeroList* CMsgOverworldEncounterChooseHeroData::_internal_mutable_hero_list() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.hero_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldHeroList>(GetArenaForAllocation());
    _impl_.hero_list_ = p;
  }
  return _impl_.hero_list_;
}
inline ::CMsgOverworldHeroList* CMsgOverworldEncounterChooseHeroData::mutable_hero_list() {
  ::CMsgOverworldHeroList* _msg = _internal_mutable_hero_list();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterChooseHeroData.hero_list)
  return _msg;
}
inline void CMsgOverworldEncounterChooseHeroData::set_allocated_hero_list(::CMsgOverworldHeroList* hero_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.hero_list_;
  }
  if (hero_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hero_list);
    if (message_arena != submessage_arena) {
      hero_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hero_list, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hero_list_ = hero_list;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldEncounterChooseHeroData.hero_list)
}

// optional bool additive = 2;
inline bool CMsgOverworldEncounterChooseHeroData::_internal_has_additive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterChooseHeroData::has_additive() const {
  return _internal_has_additive();
}
inline void CMsgOverworldEncounterChooseHeroData::clear_additive() {
  _impl_.additive_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgOverworldEncounterChooseHeroData::_internal_additive() const {
  return _impl_.additive_;
}
inline bool CMsgOverworldEncounterChooseHeroData::additive() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterChooseHeroData.additive)
  return _internal_additive();
}
inline void CMsgOverworldEncounterChooseHeroData::_internal_set_additive(bool value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.additive_ = value;
}
inline void CMsgOverworldEncounterChooseHeroData::set_additive(bool value) {
  _internal_set_additive(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterChooseHeroData.additive)
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterProgressData

// optional int32 choice = 1;
inline bool CMsgOverworldEncounterProgressData::_internal_has_choice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterProgressData::has_choice() const {
  return _internal_has_choice();
}
inline void CMsgOverworldEncounterProgressData::clear_choice() {
  _impl_.choice_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t CMsgOverworldEncounterProgressData::_internal_choice() const {
  return _impl_.choice_;
}
inline int32_t CMsgOverworldEncounterProgressData::choice() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterProgressData.choice)
  return _internal_choice();
}
inline void CMsgOverworldEncounterProgressData::_internal_set_choice(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.choice_ = value;
}
inline void CMsgOverworldEncounterProgressData::set_choice(int32_t value) {
  _internal_set_choice(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterProgressData.choice)
}

// optional int32 progress = 2;
inline bool CMsgOverworldEncounterProgressData::_internal_has_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterProgressData::has_progress() const {
  return _internal_has_progress();
}
inline void CMsgOverworldEncounterProgressData::clear_progress() {
  _impl_.progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CMsgOverworldEncounterProgressData::_internal_progress() const {
  return _impl_.progress_;
}
inline int32_t CMsgOverworldEncounterProgressData::progress() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterProgressData.progress)
  return _internal_progress();
}
inline void CMsgOverworldEncounterProgressData::_internal_set_progress(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.progress_ = value;
}
inline void CMsgOverworldEncounterProgressData::set_progress(int32_t value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterProgressData.progress)
}

// optional int32 max_progress = 3;
inline bool CMsgOverworldEncounterProgressData::_internal_has_max_progress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterProgressData::has_max_progress() const {
  return _internal_has_max_progress();
}
inline void CMsgOverworldEncounterProgressData::clear_max_progress() {
  _impl_.max_progress_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgOverworldEncounterProgressData::_internal_max_progress() const {
  return _impl_.max_progress_;
}
inline int32_t CMsgOverworldEncounterProgressData::max_progress() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterProgressData.max_progress)
  return _internal_max_progress();
}
inline void CMsgOverworldEncounterProgressData::_internal_set_max_progress(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.max_progress_ = value;
}
inline void CMsgOverworldEncounterProgressData::set_max_progress(int32_t value) {
  _internal_set_max_progress(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterProgressData.max_progress)
}

// optional bool visited = 4;
inline bool CMsgOverworldEncounterProgressData::_internal_has_visited() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterProgressData::has_visited() const {
  return _internal_has_visited();
}
inline void CMsgOverworldEncounterProgressData::clear_visited() {
  _impl_.visited_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool CMsgOverworldEncounterProgressData::_internal_visited() const {
  return _impl_.visited_;
}
inline bool CMsgOverworldEncounterProgressData::visited() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterProgressData.visited)
  return _internal_visited();
}
inline void CMsgOverworldEncounterProgressData::_internal_set_visited(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.visited_ = value;
}
inline void CMsgOverworldEncounterProgressData::set_visited(bool value) {
  _internal_set_visited(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterProgressData.visited)
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterData

// repeated .CExtraMsgBlock extra_encounter_data = 1;
inline int CMsgOverworldEncounterData::_internal_extra_encounter_data_size() const {
  return _impl_.extra_encounter_data_.size();
}
inline int CMsgOverworldEncounterData::extra_encounter_data_size() const {
  return _internal_extra_encounter_data_size();
}
inline ::CExtraMsgBlock* CMsgOverworldEncounterData::mutable_extra_encounter_data(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldEncounterData.extra_encounter_data)
  return _impl_.extra_encounter_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CExtraMsgBlock >*
CMsgOverworldEncounterData::mutable_extra_encounter_data() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldEncounterData.extra_encounter_data)
  return &_impl_.extra_encounter_data_;
}
inline const ::CExtraMsgBlock& CMsgOverworldEncounterData::_internal_extra_encounter_data(int index) const {
  return _impl_.extra_encounter_data_.Get(index);
}
inline const ::CExtraMsgBlock& CMsgOverworldEncounterData::extra_encounter_data(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterData.extra_encounter_data)
  return _internal_extra_encounter_data(index);
}
inline ::CExtraMsgBlock* CMsgOverworldEncounterData::_internal_add_extra_encounter_data() {
  return _impl_.extra_encounter_data_.Add();
}
inline ::CExtraMsgBlock* CMsgOverworldEncounterData::add_extra_encounter_data() {
  ::CExtraMsgBlock* _add = _internal_add_extra_encounter_data();
  // @@protoc_insertion_point(field_add:CMsgOverworldEncounterData.extra_encounter_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CExtraMsgBlock >&
CMsgOverworldEncounterData::extra_encounter_data() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldEncounterData.extra_encounter_data)
  return _impl_.extra_encounter_data_;
}

// -------------------------------------------------------------------

// CMsgOverworldNode

// optional uint32 node_id = 1;
inline bool CMsgOverworldNode::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgOverworldNode::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgOverworldNode::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgOverworldNode::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldNode.node_id)
  return _internal_node_id();
}
inline void CMsgOverworldNode::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_id_ = value;
}
inline void CMsgOverworldNode::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldNode.node_id)
}

// optional .EOverworldNodeState node_state = 2 [default = k_eOverworldNodeState_Invalid];
inline bool CMsgOverworldNode::_internal_has_node_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgOverworldNode::has_node_state() const {
  return _internal_has_node_state();
}
inline void CMsgOverworldNode::clear_node_state() {
  _impl_.node_state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::EOverworldNodeState CMsgOverworldNode::_internal_node_state() const {
  return static_cast< ::EOverworldNodeState >(_impl_.node_state_);
}
inline ::EOverworldNodeState CMsgOverworldNode::node_state() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldNode.node_state)
  return _internal_node_state();
}
inline void CMsgOverworldNode::_internal_set_node_state(::EOverworldNodeState value) {
  assert(::EOverworldNodeState_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.node_state_ = value;
}
inline void CMsgOverworldNode::set_node_state(::EOverworldNodeState value) {
  _internal_set_node_state(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldNode.node_state)
}

// optional .CMsgOverworldEncounterData node_encounter_data = 3;
inline bool CMsgOverworldNode::_internal_has_node_encounter_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_encounter_data_ != nullptr);
  return value;
}
inline bool CMsgOverworldNode::has_node_encounter_data() const {
  return _internal_has_node_encounter_data();
}
inline void CMsgOverworldNode::clear_node_encounter_data() {
  if (_impl_.node_encounter_data_ != nullptr) _impl_.node_encounter_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldEncounterData& CMsgOverworldNode::_internal_node_encounter_data() const {
  const ::CMsgOverworldEncounterData* p = _impl_.node_encounter_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldEncounterData&>(
      ::_CMsgOverworldEncounterData_default_instance_);
}
inline const ::CMsgOverworldEncounterData& CMsgOverworldNode::node_encounter_data() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldNode.node_encounter_data)
  return _internal_node_encounter_data();
}
inline void CMsgOverworldNode::unsafe_arena_set_allocated_node_encounter_data(
    ::CMsgOverworldEncounterData* node_encounter_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.node_encounter_data_);
  }
  _impl_.node_encounter_data_ = node_encounter_data;
  if (node_encounter_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldNode.node_encounter_data)
}
inline ::CMsgOverworldEncounterData* CMsgOverworldNode::release_node_encounter_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldEncounterData* temp = _impl_.node_encounter_data_;
  _impl_.node_encounter_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldEncounterData* CMsgOverworldNode::unsafe_arena_release_node_encounter_data() {
  // @@protoc_insertion_point(field_release:CMsgOverworldNode.node_encounter_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldEncounterData* temp = _impl_.node_encounter_data_;
  _impl_.node_encounter_data_ = nullptr;
  return temp;
}
inline ::CMsgOverworldEncounterData* CMsgOverworldNode::_internal_mutable_node_encounter_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.node_encounter_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldEncounterData>(GetArenaForAllocation());
    _impl_.node_encounter_data_ = p;
  }
  return _impl_.node_encounter_data_;
}
inline ::CMsgOverworldEncounterData* CMsgOverworldNode::mutable_node_encounter_data() {
  ::CMsgOverworldEncounterData* _msg = _internal_mutable_node_encounter_data();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldNode.node_encounter_data)
  return _msg;
}
inline void CMsgOverworldNode::set_allocated_node_encounter_data(::CMsgOverworldEncounterData* node_encounter_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.node_encounter_data_;
  }
  if (node_encounter_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node_encounter_data);
    if (message_arena != submessage_arena) {
      node_encounter_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_encounter_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.node_encounter_data_ = node_encounter_data;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldNode.node_encounter_data)
}

// -------------------------------------------------------------------

// CMsgOverworldPath

// optional uint32 path_id = 1;
inline bool CMsgOverworldPath::_internal_has_path_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldPath::has_path_id() const {
  return _internal_has_path_id();
}
inline void CMsgOverworldPath::clear_path_id() {
  _impl_.path_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgOverworldPath::_internal_path_id() const {
  return _impl_.path_id_;
}
inline uint32_t CMsgOverworldPath::path_id() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldPath.path_id)
  return _internal_path_id();
}
inline void CMsgOverworldPath::_internal_set_path_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_id_ = value;
}
inline void CMsgOverworldPath::set_path_id(uint32_t value) {
  _internal_set_path_id(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldPath.path_id)
}

// optional .CMsgOverworldTokenQuantity path_cost = 2;
inline bool CMsgOverworldPath::_internal_has_path_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.path_cost_ != nullptr);
  return value;
}
inline bool CMsgOverworldPath::has_path_cost() const {
  return _internal_has_path_cost();
}
inline void CMsgOverworldPath::clear_path_cost() {
  if (_impl_.path_cost_ != nullptr) _impl_.path_cost_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldPath::_internal_path_cost() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.path_cost_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldPath::path_cost() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldPath.path_cost)
  return _internal_path_cost();
}
inline void CMsgOverworldPath::unsafe_arena_set_allocated_path_cost(
    ::CMsgOverworldTokenQuantity* path_cost) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.path_cost_);
  }
  _impl_.path_cost_ = path_cost;
  if (path_cost) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldPath.path_cost)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldPath::release_path_cost() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.path_cost_;
  _impl_.path_cost_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldPath::unsafe_arena_release_path_cost() {
  // @@protoc_insertion_point(field_release:CMsgOverworldPath.path_cost)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.path_cost_;
  _impl_.path_cost_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldPath::_internal_mutable_path_cost() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.path_cost_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.path_cost_ = p;
  }
  return _impl_.path_cost_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldPath::mutable_path_cost() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_path_cost();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldPath.path_cost)
  return _msg;
}
inline void CMsgOverworldPath::set_allocated_path_cost(::CMsgOverworldTokenQuantity* path_cost) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.path_cost_;
  }
  if (path_cost) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(path_cost);
    if (message_arena != submessage_arena) {
      path_cost = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path_cost, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.path_cost_ = path_cost;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldPath.path_cost)
}

// -------------------------------------------------------------------

// CMsgOverworldUserData

// optional .CMsgOverworldTokenQuantity token_inventory = 1;
inline bool CMsgOverworldUserData::_internal_has_token_inventory() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_inventory_ != nullptr);
  return value;
}
inline bool CMsgOverworldUserData::has_token_inventory() const {
  return _internal_has_token_inventory();
}
inline void CMsgOverworldUserData::clear_token_inventory() {
  if (_impl_.token_inventory_ != nullptr) _impl_.token_inventory_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldUserData::_internal_token_inventory() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_inventory_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldUserData::token_inventory() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldUserData.token_inventory)
  return _internal_token_inventory();
}
inline void CMsgOverworldUserData::unsafe_arena_set_allocated_token_inventory(
    ::CMsgOverworldTokenQuantity* token_inventory) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_inventory_);
  }
  _impl_.token_inventory_ = token_inventory;
  if (token_inventory) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldUserData.token_inventory)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldUserData::release_token_inventory() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_inventory_;
  _impl_.token_inventory_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldUserData::unsafe_arena_release_token_inventory() {
  // @@protoc_insertion_point(field_release:CMsgOverworldUserData.token_inventory)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_inventory_;
  _impl_.token_inventory_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldUserData::_internal_mutable_token_inventory() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_inventory_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_inventory_ = p;
  }
  return _impl_.token_inventory_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldUserData::mutable_token_inventory() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_inventory();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldUserData.token_inventory)
  return _msg;
}
inline void CMsgOverworldUserData::set_allocated_token_inventory(::CMsgOverworldTokenQuantity* token_inventory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_inventory_;
  }
  if (token_inventory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_inventory);
    if (message_arena != submessage_arena) {
      token_inventory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_inventory, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_inventory_ = token_inventory;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldUserData.token_inventory)
}

// repeated .CMsgOverworldNode overworld_nodes = 2;
inline int CMsgOverworldUserData::_internal_overworld_nodes_size() const {
  return _impl_.overworld_nodes_.size();
}
inline int CMsgOverworldUserData::overworld_nodes_size() const {
  return _internal_overworld_nodes_size();
}
inline void CMsgOverworldUserData::clear_overworld_nodes() {
  _impl_.overworld_nodes_.Clear();
}
inline ::CMsgOverworldNode* CMsgOverworldUserData::mutable_overworld_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldUserData.overworld_nodes)
  return _impl_.overworld_nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldNode >*
CMsgOverworldUserData::mutable_overworld_nodes() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldUserData.overworld_nodes)
  return &_impl_.overworld_nodes_;
}
inline const ::CMsgOverworldNode& CMsgOverworldUserData::_internal_overworld_nodes(int index) const {
  return _impl_.overworld_nodes_.Get(index);
}
inline const ::CMsgOverworldNode& CMsgOverworldUserData::overworld_nodes(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldUserData.overworld_nodes)
  return _internal_overworld_nodes(index);
}
inline ::CMsgOverworldNode* CMsgOverworldUserData::_internal_add_overworld_nodes() {
  return _impl_.overworld_nodes_.Add();
}
inline ::CMsgOverworldNode* CMsgOverworldUserData::add_overworld_nodes() {
  ::CMsgOverworldNode* _add = _internal_add_overworld_nodes();
  // @@protoc_insertion_point(field_add:CMsgOverworldUserData.overworld_nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldNode >&
CMsgOverworldUserData::overworld_nodes() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldUserData.overworld_nodes)
  return _impl_.overworld_nodes_;
}

// repeated .CMsgOverworldPath overworld_paths = 3;
inline int CMsgOverworldUserData::_internal_overworld_paths_size() const {
  return _impl_.overworld_paths_.size();
}
inline int CMsgOverworldUserData::overworld_paths_size() const {
  return _internal_overworld_paths_size();
}
inline void CMsgOverworldUserData::clear_overworld_paths() {
  _impl_.overworld_paths_.Clear();
}
inline ::CMsgOverworldPath* CMsgOverworldUserData::mutable_overworld_paths(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldUserData.overworld_paths)
  return _impl_.overworld_paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldPath >*
CMsgOverworldUserData::mutable_overworld_paths() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldUserData.overworld_paths)
  return &_impl_.overworld_paths_;
}
inline const ::CMsgOverworldPath& CMsgOverworldUserData::_internal_overworld_paths(int index) const {
  return _impl_.overworld_paths_.Get(index);
}
inline const ::CMsgOverworldPath& CMsgOverworldUserData::overworld_paths(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldUserData.overworld_paths)
  return _internal_overworld_paths(index);
}
inline ::CMsgOverworldPath* CMsgOverworldUserData::_internal_add_overworld_paths() {
  return _impl_.overworld_paths_.Add();
}
inline ::CMsgOverworldPath* CMsgOverworldUserData::add_overworld_paths() {
  ::CMsgOverworldPath* _add = _internal_add_overworld_paths();
  // @@protoc_insertion_point(field_add:CMsgOverworldUserData.overworld_paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldPath >&
CMsgOverworldUserData::overworld_paths() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldUserData.overworld_paths)
  return _impl_.overworld_paths_;
}

// optional uint32 current_node_id = 4;
inline bool CMsgOverworldUserData::_internal_has_current_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldUserData::has_current_node_id() const {
  return _internal_has_current_node_id();
}
inline void CMsgOverworldUserData::clear_current_node_id() {
  _impl_.current_node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgOverworldUserData::_internal_current_node_id() const {
  return _impl_.current_node_id_;
}
inline uint32_t CMsgOverworldUserData::current_node_id() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldUserData.current_node_id)
  return _internal_current_node_id();
}
inline void CMsgOverworldUserData::_internal_set_current_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.current_node_id_ = value;
}
inline void CMsgOverworldUserData::set_current_node_id(uint32_t value) {
  _internal_set_current_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldUserData.current_node_id)
}

// -------------------------------------------------------------------

// CMsgOverworldMatchRewards_Player

// optional uint32 player_slot = 1;
inline bool CMsgOverworldMatchRewards_Player::_internal_has_player_slot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldMatchRewards_Player::has_player_slot() const {
  return _internal_has_player_slot();
}
inline void CMsgOverworldMatchRewards_Player::clear_player_slot() {
  _impl_.player_slot_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgOverworldMatchRewards_Player::_internal_player_slot() const {
  return _impl_.player_slot_;
}
inline uint32_t CMsgOverworldMatchRewards_Player::player_slot() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldMatchRewards.Player.player_slot)
  return _internal_player_slot();
}
inline void CMsgOverworldMatchRewards_Player::_internal_set_player_slot(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.player_slot_ = value;
}
inline void CMsgOverworldMatchRewards_Player::set_player_slot(uint32_t value) {
  _internal_set_player_slot(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldMatchRewards.Player.player_slot)
}

// optional .CMsgOverworldTokenQuantity tokens = 2;
inline bool CMsgOverworldMatchRewards_Player::_internal_has_tokens() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tokens_ != nullptr);
  return value;
}
inline bool CMsgOverworldMatchRewards_Player::has_tokens() const {
  return _internal_has_tokens();
}
inline void CMsgOverworldMatchRewards_Player::clear_tokens() {
  if (_impl_.tokens_ != nullptr) _impl_.tokens_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldMatchRewards_Player::_internal_tokens() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.tokens_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgOverworldMatchRewards_Player::tokens() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldMatchRewards.Player.tokens)
  return _internal_tokens();
}
inline void CMsgOverworldMatchRewards_Player::unsafe_arena_set_allocated_tokens(
    ::CMsgOverworldTokenQuantity* tokens) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tokens_);
  }
  _impl_.tokens_ = tokens;
  if (tokens) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgOverworldMatchRewards.Player.tokens)
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldMatchRewards_Player::release_tokens() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.tokens_;
  _impl_.tokens_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldMatchRewards_Player::unsafe_arena_release_tokens() {
  // @@protoc_insertion_point(field_release:CMsgOverworldMatchRewards.Player.tokens)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.tokens_;
  _impl_.tokens_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldMatchRewards_Player::_internal_mutable_tokens() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tokens_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.tokens_ = p;
  }
  return _impl_.tokens_;
}
inline ::CMsgOverworldTokenQuantity* CMsgOverworldMatchRewards_Player::mutable_tokens() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_tokens();
  // @@protoc_insertion_point(field_mutable:CMsgOverworldMatchRewards.Player.tokens)
  return _msg;
}
inline void CMsgOverworldMatchRewards_Player::set_allocated_tokens(::CMsgOverworldTokenQuantity* tokens) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tokens_;
  }
  if (tokens) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokens);
    if (message_arena != submessage_arena) {
      tokens = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokens, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tokens_ = tokens;
  // @@protoc_insertion_point(field_set_allocated:CMsgOverworldMatchRewards.Player.tokens)
}

// optional uint32 overworld_id = 3;
inline bool CMsgOverworldMatchRewards_Player::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgOverworldMatchRewards_Player::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgOverworldMatchRewards_Player::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgOverworldMatchRewards_Player::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgOverworldMatchRewards_Player::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldMatchRewards.Player.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgOverworldMatchRewards_Player::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.overworld_id_ = value;
}
inline void CMsgOverworldMatchRewards_Player::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldMatchRewards.Player.overworld_id)
}

// -------------------------------------------------------------------

// CMsgOverworldMatchRewards

// repeated .CMsgOverworldMatchRewards.Player players = 1;
inline int CMsgOverworldMatchRewards::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int CMsgOverworldMatchRewards::players_size() const {
  return _internal_players_size();
}
inline void CMsgOverworldMatchRewards::clear_players() {
  _impl_.players_.Clear();
}
inline ::CMsgOverworldMatchRewards_Player* CMsgOverworldMatchRewards::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgOverworldMatchRewards.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldMatchRewards_Player >*
CMsgOverworldMatchRewards::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgOverworldMatchRewards.players)
  return &_impl_.players_;
}
inline const ::CMsgOverworldMatchRewards_Player& CMsgOverworldMatchRewards::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::CMsgOverworldMatchRewards_Player& CMsgOverworldMatchRewards::players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgOverworldMatchRewards.players)
  return _internal_players(index);
}
inline ::CMsgOverworldMatchRewards_Player* CMsgOverworldMatchRewards::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::CMsgOverworldMatchRewards_Player* CMsgOverworldMatchRewards::add_players() {
  ::CMsgOverworldMatchRewards_Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:CMsgOverworldMatchRewards.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgOverworldMatchRewards_Player >&
CMsgOverworldMatchRewards::players() const {
  // @@protoc_insertion_point(field_list:CMsgOverworldMatchRewards.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGetUserData

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldGetUserData::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetUserData::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldGetUserData::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldGetUserData::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldGetUserData::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetUserData.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldGetUserData::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldGetUserData::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetUserData.overworld_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGetUserDataResponse

// optional .CMsgClientToGCOverworldGetUserDataResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldGetUserDataResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetUserDataResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldGetUserDataResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldGetUserDataResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetUserDataResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldGetUserDataResponse::_internal_set_response(::CMsgClientToGCOverworldGetUserDataResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldGetUserDataResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldGetUserDataResponse::set_response(::CMsgClientToGCOverworldGetUserDataResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetUserDataResponse.response)
}

// optional .CMsgOverworldUserData user_data = 2;
inline bool CMsgClientToGCOverworldGetUserDataResponse::_internal_has_user_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_data_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldGetUserDataResponse::has_user_data() const {
  return _internal_has_user_data();
}
inline void CMsgClientToGCOverworldGetUserDataResponse::clear_user_data() {
  if (_impl_.user_data_ != nullptr) _impl_.user_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldUserData& CMsgClientToGCOverworldGetUserDataResponse::_internal_user_data() const {
  const ::CMsgOverworldUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldUserData&>(
      ::_CMsgOverworldUserData_default_instance_);
}
inline const ::CMsgOverworldUserData& CMsgClientToGCOverworldGetUserDataResponse::user_data() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetUserDataResponse.user_data)
  return _internal_user_data();
}
inline void CMsgClientToGCOverworldGetUserDataResponse::unsafe_arena_set_allocated_user_data(
    ::CMsgOverworldUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldGetUserDataResponse.user_data)
}
inline ::CMsgOverworldUserData* CMsgClientToGCOverworldGetUserDataResponse::release_user_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldUserData* CMsgClientToGCOverworldGetUserDataResponse::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldGetUserDataResponse.user_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::CMsgOverworldUserData* CMsgClientToGCOverworldGetUserDataResponse::_internal_mutable_user_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::CMsgOverworldUserData* CMsgClientToGCOverworldGetUserDataResponse::mutable_user_data() {
  ::CMsgOverworldUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldGetUserDataResponse.user_data)
  return _msg;
}
inline void CMsgClientToGCOverworldGetUserDataResponse::set_allocated_user_data(::CMsgOverworldUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldGetUserDataResponse.user_data)
}

// -------------------------------------------------------------------

// CMsgGCToClientOverworldUserDataUpdated

// optional uint32 overworld_id = 1;
inline bool CMsgGCToClientOverworldUserDataUpdated::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGCToClientOverworldUserDataUpdated::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgGCToClientOverworldUserDataUpdated::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgGCToClientOverworldUserDataUpdated::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgGCToClientOverworldUserDataUpdated::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgGCToClientOverworldUserDataUpdated.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgGCToClientOverworldUserDataUpdated::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.overworld_id_ = value;
}
inline void CMsgGCToClientOverworldUserDataUpdated::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgGCToClientOverworldUserDataUpdated.overworld_id)
}

// optional .CMsgOverworldUserData user_data = 2;
inline bool CMsgGCToClientOverworldUserDataUpdated::_internal_has_user_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.user_data_ != nullptr);
  return value;
}
inline bool CMsgGCToClientOverworldUserDataUpdated::has_user_data() const {
  return _internal_has_user_data();
}
inline void CMsgGCToClientOverworldUserDataUpdated::clear_user_data() {
  if (_impl_.user_data_ != nullptr) _impl_.user_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldUserData& CMsgGCToClientOverworldUserDataUpdated::_internal_user_data() const {
  const ::CMsgOverworldUserData* p = _impl_.user_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldUserData&>(
      ::_CMsgOverworldUserData_default_instance_);
}
inline const ::CMsgOverworldUserData& CMsgGCToClientOverworldUserDataUpdated::user_data() const {
  // @@protoc_insertion_point(field_get:CMsgGCToClientOverworldUserDataUpdated.user_data)
  return _internal_user_data();
}
inline void CMsgGCToClientOverworldUserDataUpdated::unsafe_arena_set_allocated_user_data(
    ::CMsgOverworldUserData* user_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_data_);
  }
  _impl_.user_data_ = user_data;
  if (user_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgGCToClientOverworldUserDataUpdated.user_data)
}
inline ::CMsgOverworldUserData* CMsgGCToClientOverworldUserDataUpdated::release_user_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldUserData* CMsgGCToClientOverworldUserDataUpdated::unsafe_arena_release_user_data() {
  // @@protoc_insertion_point(field_release:CMsgGCToClientOverworldUserDataUpdated.user_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldUserData* temp = _impl_.user_data_;
  _impl_.user_data_ = nullptr;
  return temp;
}
inline ::CMsgOverworldUserData* CMsgGCToClientOverworldUserDataUpdated::_internal_mutable_user_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.user_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldUserData>(GetArenaForAllocation());
    _impl_.user_data_ = p;
  }
  return _impl_.user_data_;
}
inline ::CMsgOverworldUserData* CMsgGCToClientOverworldUserDataUpdated::mutable_user_data() {
  ::CMsgOverworldUserData* _msg = _internal_mutable_user_data();
  // @@protoc_insertion_point(field_mutable:CMsgGCToClientOverworldUserDataUpdated.user_data)
  return _msg;
}
inline void CMsgGCToClientOverworldUserDataUpdated::set_allocated_user_data(::CMsgOverworldUserData* user_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_data_;
  }
  if (user_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user_data);
    if (message_arena != submessage_arena) {
      user_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_data_ = user_data;
  // @@protoc_insertion_point(field_set_allocated:CMsgGCToClientOverworldUserDataUpdated.user_data)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldCompletePath

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldCompletePath::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldCompletePath::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldCompletePath::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldCompletePath::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldCompletePath::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldCompletePath.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldCompletePath::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldCompletePath::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldCompletePath.overworld_id)
}

// optional uint32 path_id = 2;
inline bool CMsgClientToGCOverworldCompletePath::_internal_has_path_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldCompletePath::has_path_id() const {
  return _internal_has_path_id();
}
inline void CMsgClientToGCOverworldCompletePath::clear_path_id() {
  _impl_.path_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldCompletePath::_internal_path_id() const {
  return _impl_.path_id_;
}
inline uint32_t CMsgClientToGCOverworldCompletePath::path_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldCompletePath.path_id)
  return _internal_path_id();
}
inline void CMsgClientToGCOverworldCompletePath::_internal_set_path_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.path_id_ = value;
}
inline void CMsgClientToGCOverworldCompletePath::set_path_id(uint32_t value) {
  _internal_set_path_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldCompletePath.path_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldCompletePathResponse

// optional .CMsgClientToGCOverworldCompletePathResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldCompletePathResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldCompletePathResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldCompletePathResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldCompletePathResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldCompletePathResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldCompletePathResponse::_internal_set_response(::CMsgClientToGCOverworldCompletePathResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldCompletePathResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldCompletePathResponse::set_response(::CMsgClientToGCOverworldCompletePathResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldCompletePathResponse.response)
}

// optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
inline bool CMsgClientToGCOverworldCompletePathResponse::_internal_has_claim_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.claim_response_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldCompletePathResponse::has_claim_response() const {
  return _internal_has_claim_response();
}
inline const ::CMsgDOTAClaimEventActionResponse& CMsgClientToGCOverworldCompletePathResponse::_internal_claim_response() const {
  const ::CMsgDOTAClaimEventActionResponse* p = _impl_.claim_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDOTAClaimEventActionResponse&>(
      ::_CMsgDOTAClaimEventActionResponse_default_instance_);
}
inline const ::CMsgDOTAClaimEventActionResponse& CMsgClientToGCOverworldCompletePathResponse::claim_response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldCompletePathResponse.claim_response)
  return _internal_claim_response();
}
inline void CMsgClientToGCOverworldCompletePathResponse::unsafe_arena_set_allocated_claim_response(
    ::CMsgDOTAClaimEventActionResponse* claim_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claim_response_);
  }
  _impl_.claim_response_ = claim_response;
  if (claim_response) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldCompletePathResponse.claim_response)
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldCompletePathResponse::release_claim_response() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTAClaimEventActionResponse* temp = _impl_.claim_response_;
  _impl_.claim_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldCompletePathResponse::unsafe_arena_release_claim_response() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldCompletePathResponse.claim_response)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTAClaimEventActionResponse* temp = _impl_.claim_response_;
  _impl_.claim_response_ = nullptr;
  return temp;
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldCompletePathResponse::_internal_mutable_claim_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.claim_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDOTAClaimEventActionResponse>(GetArenaForAllocation());
    _impl_.claim_response_ = p;
  }
  return _impl_.claim_response_;
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldCompletePathResponse::mutable_claim_response() {
  ::CMsgDOTAClaimEventActionResponse* _msg = _internal_mutable_claim_response();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldCompletePathResponse.claim_response)
  return _msg;
}
inline void CMsgClientToGCOverworldCompletePathResponse::set_allocated_claim_response(::CMsgDOTAClaimEventActionResponse* claim_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claim_response_);
  }
  if (claim_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claim_response));
    if (message_arena != submessage_arena) {
      claim_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claim_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.claim_response_ = claim_response;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldCompletePathResponse.claim_response)
}

// -------------------------------------------------------------------

// CMsgOverworldEncounterPitFighterRewardData

// optional uint32 token_id = 1;
inline bool CMsgOverworldEncounterPitFighterRewardData::_internal_has_token_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterPitFighterRewardData::has_token_id() const {
  return _internal_has_token_id();
}
inline void CMsgOverworldEncounterPitFighterRewardData::clear_token_id() {
  _impl_.token_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgOverworldEncounterPitFighterRewardData::_internal_token_id() const {
  return _impl_.token_id_;
}
inline uint32_t CMsgOverworldEncounterPitFighterRewardData::token_id() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterPitFighterRewardData.token_id)
  return _internal_token_id();
}
inline void CMsgOverworldEncounterPitFighterRewardData::_internal_set_token_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.token_id_ = value;
}
inline void CMsgOverworldEncounterPitFighterRewardData::set_token_id(uint32_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterPitFighterRewardData.token_id)
}

// optional uint32 choice = 2;
inline bool CMsgOverworldEncounterPitFighterRewardData::_internal_has_choice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgOverworldEncounterPitFighterRewardData::has_choice() const {
  return _internal_has_choice();
}
inline void CMsgOverworldEncounterPitFighterRewardData::clear_choice() {
  _impl_.choice_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgOverworldEncounterPitFighterRewardData::_internal_choice() const {
  return _impl_.choice_;
}
inline uint32_t CMsgOverworldEncounterPitFighterRewardData::choice() const {
  // @@protoc_insertion_point(field_get:CMsgOverworldEncounterPitFighterRewardData.choice)
  return _internal_choice();
}
inline void CMsgOverworldEncounterPitFighterRewardData::_internal_set_choice(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.choice_ = value;
}
inline void CMsgOverworldEncounterPitFighterRewardData::set_choice(uint32_t value) {
  _internal_set_choice(value);
  // @@protoc_insertion_point(field_set:CMsgOverworldEncounterPitFighterRewardData.choice)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldClaimEncounterReward

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldClaimEncounterReward::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterReward::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterReward.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldClaimEncounterReward::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldClaimEncounterReward.overworld_id)
}

// optional uint32 node_id = 2;
inline bool CMsgClientToGCOverworldClaimEncounterReward::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterReward::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterReward.node_id)
  return _internal_node_id();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.node_id_ = value;
}
inline void CMsgClientToGCOverworldClaimEncounterReward::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldClaimEncounterReward.node_id)
}

// optional uint32 reward_data = 3;
inline bool CMsgClientToGCOverworldClaimEncounterReward::_internal_has_reward_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterReward::has_reward_data() const {
  return _internal_has_reward_data();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::clear_reward_data() {
  _impl_.reward_data_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::_internal_reward_data() const {
  return _impl_.reward_data_;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::reward_data() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterReward.reward_data)
  return _internal_reward_data();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::_internal_set_reward_data(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.reward_data_ = value;
}
inline void CMsgClientToGCOverworldClaimEncounterReward::set_reward_data(uint32_t value) {
  _internal_set_reward_data(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldClaimEncounterReward.reward_data)
}

// optional uint32 periodic_resource_id = 4;
inline bool CMsgClientToGCOverworldClaimEncounterReward::_internal_has_periodic_resource_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterReward::has_periodic_resource_id() const {
  return _internal_has_periodic_resource_id();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::clear_periodic_resource_id() {
  _impl_.periodic_resource_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::_internal_periodic_resource_id() const {
  return _impl_.periodic_resource_id_;
}
inline uint32_t CMsgClientToGCOverworldClaimEncounterReward::periodic_resource_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterReward.periodic_resource_id)
  return _internal_periodic_resource_id();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::_internal_set_periodic_resource_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.periodic_resource_id_ = value;
}
inline void CMsgClientToGCOverworldClaimEncounterReward::set_periodic_resource_id(uint32_t value) {
  _internal_set_periodic_resource_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldClaimEncounterReward.periodic_resource_id)
}

// optional .CMsgOverworldEncounterData extra_reward_data = 5;
inline bool CMsgClientToGCOverworldClaimEncounterReward::_internal_has_extra_reward_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_reward_data_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterReward::has_extra_reward_data() const {
  return _internal_has_extra_reward_data();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::clear_extra_reward_data() {
  if (_impl_.extra_reward_data_ != nullptr) _impl_.extra_reward_data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldEncounterData& CMsgClientToGCOverworldClaimEncounterReward::_internal_extra_reward_data() const {
  const ::CMsgOverworldEncounterData* p = _impl_.extra_reward_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldEncounterData&>(
      ::_CMsgOverworldEncounterData_default_instance_);
}
inline const ::CMsgOverworldEncounterData& CMsgClientToGCOverworldClaimEncounterReward::extra_reward_data() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterReward.extra_reward_data)
  return _internal_extra_reward_data();
}
inline void CMsgClientToGCOverworldClaimEncounterReward::unsafe_arena_set_allocated_extra_reward_data(
    ::CMsgOverworldEncounterData* extra_reward_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.extra_reward_data_);
  }
  _impl_.extra_reward_data_ = extra_reward_data;
  if (extra_reward_data) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldClaimEncounterReward.extra_reward_data)
}
inline ::CMsgOverworldEncounterData* CMsgClientToGCOverworldClaimEncounterReward::release_extra_reward_data() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldEncounterData* temp = _impl_.extra_reward_data_;
  _impl_.extra_reward_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldEncounterData* CMsgClientToGCOverworldClaimEncounterReward::unsafe_arena_release_extra_reward_data() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldClaimEncounterReward.extra_reward_data)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldEncounterData* temp = _impl_.extra_reward_data_;
  _impl_.extra_reward_data_ = nullptr;
  return temp;
}
inline ::CMsgOverworldEncounterData* CMsgClientToGCOverworldClaimEncounterReward::_internal_mutable_extra_reward_data() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.extra_reward_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldEncounterData>(GetArenaForAllocation());
    _impl_.extra_reward_data_ = p;
  }
  return _impl_.extra_reward_data_;
}
inline ::CMsgOverworldEncounterData* CMsgClientToGCOverworldClaimEncounterReward::mutable_extra_reward_data() {
  ::CMsgOverworldEncounterData* _msg = _internal_mutable_extra_reward_data();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldClaimEncounterReward.extra_reward_data)
  return _msg;
}
inline void CMsgClientToGCOverworldClaimEncounterReward::set_allocated_extra_reward_data(::CMsgOverworldEncounterData* extra_reward_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.extra_reward_data_;
  }
  if (extra_reward_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extra_reward_data);
    if (message_arena != submessage_arena) {
      extra_reward_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extra_reward_data, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.extra_reward_data_ = extra_reward_data;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldClaimEncounterReward.extra_reward_data)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldClaimEncounterRewardResponse

// optional .CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterRewardResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_set_response(::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::set_response(::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldClaimEncounterRewardResponse.response)
}

// optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_has_claim_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.claim_response_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse::has_claim_response() const {
  return _internal_has_claim_response();
}
inline const ::CMsgDOTAClaimEventActionResponse& CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_claim_response() const {
  const ::CMsgDOTAClaimEventActionResponse* p = _impl_.claim_response_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgDOTAClaimEventActionResponse&>(
      ::_CMsgDOTAClaimEventActionResponse_default_instance_);
}
inline const ::CMsgDOTAClaimEventActionResponse& CMsgClientToGCOverworldClaimEncounterRewardResponse::claim_response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterRewardResponse.claim_response)
  return _internal_claim_response();
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::unsafe_arena_set_allocated_claim_response(
    ::CMsgDOTAClaimEventActionResponse* claim_response) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claim_response_);
  }
  _impl_.claim_response_ = claim_response;
  if (claim_response) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldClaimEncounterRewardResponse.claim_response)
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldClaimEncounterRewardResponse::release_claim_response() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTAClaimEventActionResponse* temp = _impl_.claim_response_;
  _impl_.claim_response_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldClaimEncounterRewardResponse::unsafe_arena_release_claim_response() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldClaimEncounterRewardResponse.claim_response)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgDOTAClaimEventActionResponse* temp = _impl_.claim_response_;
  _impl_.claim_response_ = nullptr;
  return temp;
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_mutable_claim_response() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.claim_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgDOTAClaimEventActionResponse>(GetArenaForAllocation());
    _impl_.claim_response_ = p;
  }
  return _impl_.claim_response_;
}
inline ::CMsgDOTAClaimEventActionResponse* CMsgClientToGCOverworldClaimEncounterRewardResponse::mutable_claim_response() {
  ::CMsgDOTAClaimEventActionResponse* _msg = _internal_mutable_claim_response();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldClaimEncounterRewardResponse.claim_response)
  return _msg;
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::set_allocated_claim_response(::CMsgDOTAClaimEventActionResponse* claim_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.claim_response_);
  }
  if (claim_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(claim_response));
    if (message_arena != submessage_arena) {
      claim_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, claim_response, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.claim_response_ = claim_response;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldClaimEncounterRewardResponse.claim_response)
}

// optional .CMsgOverworldTokenQuantity tokens_received = 3;
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_has_tokens_received() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tokens_received_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldClaimEncounterRewardResponse::has_tokens_received() const {
  return _internal_has_tokens_received();
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::clear_tokens_received() {
  if (_impl_.tokens_received_ != nullptr) _impl_.tokens_received_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_tokens_received() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.tokens_received_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldClaimEncounterRewardResponse::tokens_received() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldClaimEncounterRewardResponse.tokens_received)
  return _internal_tokens_received();
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::unsafe_arena_set_allocated_tokens_received(
    ::CMsgOverworldTokenQuantity* tokens_received) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tokens_received_);
  }
  _impl_.tokens_received_ = tokens_received;
  if (tokens_received) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldClaimEncounterRewardResponse.tokens_received)
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldClaimEncounterRewardResponse::release_tokens_received() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.tokens_received_;
  _impl_.tokens_received_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldClaimEncounterRewardResponse::unsafe_arena_release_tokens_received() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldClaimEncounterRewardResponse.tokens_received)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.tokens_received_;
  _impl_.tokens_received_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldClaimEncounterRewardResponse::_internal_mutable_tokens_received() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.tokens_received_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.tokens_received_ = p;
  }
  return _impl_.tokens_received_;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldClaimEncounterRewardResponse::mutable_tokens_received() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_tokens_received();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldClaimEncounterRewardResponse.tokens_received)
  return _msg;
}
inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::set_allocated_tokens_received(::CMsgOverworldTokenQuantity* tokens_received) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tokens_received_;
  }
  if (tokens_received) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokens_received);
    if (message_arena != submessage_arena) {
      tokens_received = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokens_received, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.tokens_received_ = tokens_received;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldClaimEncounterRewardResponse.tokens_received)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldVisitEncounter

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldVisitEncounter::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldVisitEncounter::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldVisitEncounter::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldVisitEncounter::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldVisitEncounter::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldVisitEncounter.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldVisitEncounter::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldVisitEncounter::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldVisitEncounter.overworld_id)
}

// optional uint32 node_id = 2;
inline bool CMsgClientToGCOverworldVisitEncounter::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldVisitEncounter::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgClientToGCOverworldVisitEncounter::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldVisitEncounter::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgClientToGCOverworldVisitEncounter::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldVisitEncounter.node_id)
  return _internal_node_id();
}
inline void CMsgClientToGCOverworldVisitEncounter::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_id_ = value;
}
inline void CMsgClientToGCOverworldVisitEncounter::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldVisitEncounter.node_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldVisitEncounterResponse

// optional .CMsgClientToGCOverworldVisitEncounterResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldVisitEncounterResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldVisitEncounterResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldVisitEncounterResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldVisitEncounterResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldVisitEncounterResponse::_internal_set_response(::CMsgClientToGCOverworldVisitEncounterResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldVisitEncounterResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldVisitEncounterResponse::set_response(::CMsgClientToGCOverworldVisitEncounterResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldVisitEncounterResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldMoveToNode

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldMoveToNode::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldMoveToNode::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldMoveToNode::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldMoveToNode::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldMoveToNode::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldMoveToNode.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldMoveToNode::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldMoveToNode::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldMoveToNode.overworld_id)
}

// optional uint32 node_id = 2;
inline bool CMsgClientToGCOverworldMoveToNode::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldMoveToNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgClientToGCOverworldMoveToNode::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldMoveToNode::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgClientToGCOverworldMoveToNode::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldMoveToNode.node_id)
  return _internal_node_id();
}
inline void CMsgClientToGCOverworldMoveToNode::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_id_ = value;
}
inline void CMsgClientToGCOverworldMoveToNode::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldMoveToNode.node_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldMoveToNodeResponse

// optional .CMsgClientToGCOverworldMoveToNodeResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldMoveToNodeResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldMoveToNodeResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldMoveToNodeResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldMoveToNodeResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldMoveToNodeResponse::_internal_set_response(::CMsgClientToGCOverworldMoveToNodeResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldMoveToNodeResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldMoveToNodeResponse::set_response(::CMsgClientToGCOverworldMoveToNodeResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldMoveToNodeResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldTradeTokens

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldTradeTokens::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokens::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldTradeTokens::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientToGCOverworldTradeTokens::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldTradeTokens::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokens.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldTradeTokens::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldTradeTokens::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldTradeTokens.overworld_id)
}

// optional .CMsgOverworldTokenQuantity token_offer = 2;
inline bool CMsgClientToGCOverworldTradeTokens::_internal_has_token_offer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_offer_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokens::has_token_offer() const {
  return _internal_has_token_offer();
}
inline void CMsgClientToGCOverworldTradeTokens::clear_token_offer() {
  if (_impl_.token_offer_ != nullptr) _impl_.token_offer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldTradeTokens::_internal_token_offer() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_offer_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldTradeTokens::token_offer() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokens.token_offer)
  return _internal_token_offer();
}
inline void CMsgClientToGCOverworldTradeTokens::unsafe_arena_set_allocated_token_offer(
    ::CMsgOverworldTokenQuantity* token_offer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_offer_);
  }
  _impl_.token_offer_ = token_offer;
  if (token_offer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldTradeTokens.token_offer)
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::release_token_offer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_offer_;
  _impl_.token_offer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::unsafe_arena_release_token_offer() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldTradeTokens.token_offer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_offer_;
  _impl_.token_offer_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::_internal_mutable_token_offer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_offer_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_offer_ = p;
  }
  return _impl_.token_offer_;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::mutable_token_offer() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_offer();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldTradeTokens.token_offer)
  return _msg;
}
inline void CMsgClientToGCOverworldTradeTokens::set_allocated_token_offer(::CMsgOverworldTokenQuantity* token_offer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_offer_;
  }
  if (token_offer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_offer);
    if (message_arena != submessage_arena) {
      token_offer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_offer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_offer_ = token_offer;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldTradeTokens.token_offer)
}

// optional .CMsgOverworldTokenQuantity token_request = 3;
inline bool CMsgClientToGCOverworldTradeTokens::_internal_has_token_request() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_request_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokens::has_token_request() const {
  return _internal_has_token_request();
}
inline void CMsgClientToGCOverworldTradeTokens::clear_token_request() {
  if (_impl_.token_request_ != nullptr) _impl_.token_request_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldTradeTokens::_internal_token_request() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldTradeTokens::token_request() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokens.token_request)
  return _internal_token_request();
}
inline void CMsgClientToGCOverworldTradeTokens::unsafe_arena_set_allocated_token_request(
    ::CMsgOverworldTokenQuantity* token_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_request_);
  }
  _impl_.token_request_ = token_request;
  if (token_request) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldTradeTokens.token_request)
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::release_token_request() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_request_;
  _impl_.token_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::unsafe_arena_release_token_request() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldTradeTokens.token_request)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_request_;
  _impl_.token_request_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::_internal_mutable_token_request() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.token_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_request_ = p;
  }
  return _impl_.token_request_;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokens::mutable_token_request() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_request();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldTradeTokens.token_request)
  return _msg;
}
inline void CMsgClientToGCOverworldTradeTokens::set_allocated_token_request(::CMsgOverworldTokenQuantity* token_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_request_;
  }
  if (token_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_request);
    if (message_arena != submessage_arena) {
      token_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_request, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.token_request_ = token_request;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldTradeTokens.token_request)
}

// optional uint32 recipe = 4;
inline bool CMsgClientToGCOverworldTradeTokens::_internal_has_recipe() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokens::has_recipe() const {
  return _internal_has_recipe();
}
inline void CMsgClientToGCOverworldTradeTokens::clear_recipe() {
  _impl_.recipe_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgClientToGCOverworldTradeTokens::_internal_recipe() const {
  return _impl_.recipe_;
}
inline uint32_t CMsgClientToGCOverworldTradeTokens::recipe() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokens.recipe)
  return _internal_recipe();
}
inline void CMsgClientToGCOverworldTradeTokens::_internal_set_recipe(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.recipe_ = value;
}
inline void CMsgClientToGCOverworldTradeTokens::set_recipe(uint32_t value) {
  _internal_set_recipe(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldTradeTokens.recipe)
}

// optional uint32 encounter_id = 5;
inline bool CMsgClientToGCOverworldTradeTokens::_internal_has_encounter_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokens::has_encounter_id() const {
  return _internal_has_encounter_id();
}
inline void CMsgClientToGCOverworldTradeTokens::clear_encounter_id() {
  _impl_.encounter_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgClientToGCOverworldTradeTokens::_internal_encounter_id() const {
  return _impl_.encounter_id_;
}
inline uint32_t CMsgClientToGCOverworldTradeTokens::encounter_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokens.encounter_id)
  return _internal_encounter_id();
}
inline void CMsgClientToGCOverworldTradeTokens::_internal_set_encounter_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.encounter_id_ = value;
}
inline void CMsgClientToGCOverworldTradeTokens::set_encounter_id(uint32_t value) {
  _internal_set_encounter_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldTradeTokens.encounter_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldTradeTokensResponse

// optional .CMsgClientToGCOverworldTradeTokensResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldTradeTokensResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokensResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldTradeTokensResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldTradeTokensResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokensResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldTradeTokensResponse::_internal_set_response(::CMsgClientToGCOverworldTradeTokensResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldTradeTokensResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldTradeTokensResponse::set_response(::CMsgClientToGCOverworldTradeTokensResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldTradeTokensResponse.response)
}

// optional .CMsgOverworldTokenQuantity tokens_received = 2;
inline bool CMsgClientToGCOverworldTradeTokensResponse::_internal_has_tokens_received() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tokens_received_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldTradeTokensResponse::has_tokens_received() const {
  return _internal_has_tokens_received();
}
inline void CMsgClientToGCOverworldTradeTokensResponse::clear_tokens_received() {
  if (_impl_.tokens_received_ != nullptr) _impl_.tokens_received_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldTradeTokensResponse::_internal_tokens_received() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.tokens_received_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldTradeTokensResponse::tokens_received() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldTradeTokensResponse.tokens_received)
  return _internal_tokens_received();
}
inline void CMsgClientToGCOverworldTradeTokensResponse::unsafe_arena_set_allocated_tokens_received(
    ::CMsgOverworldTokenQuantity* tokens_received) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tokens_received_);
  }
  _impl_.tokens_received_ = tokens_received;
  if (tokens_received) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldTradeTokensResponse.tokens_received)
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokensResponse::release_tokens_received() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.tokens_received_;
  _impl_.tokens_received_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokensResponse::unsafe_arena_release_tokens_received() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldTradeTokensResponse.tokens_received)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.tokens_received_;
  _impl_.tokens_received_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokensResponse::_internal_mutable_tokens_received() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.tokens_received_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.tokens_received_ = p;
  }
  return _impl_.tokens_received_;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldTradeTokensResponse::mutable_tokens_received() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_tokens_received();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldTradeTokensResponse.tokens_received)
  return _msg;
}
inline void CMsgClientToGCOverworldTradeTokensResponse::set_allocated_tokens_received(::CMsgOverworldTokenQuantity* tokens_received) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tokens_received_;
  }
  if (tokens_received) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tokens_received);
    if (message_arena != submessage_arena) {
      tokens_received = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tokens_received, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tokens_received_ = tokens_received;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldTradeTokensResponse.tokens_received)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGiftTokens

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldGiftTokens::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGiftTokens::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldGiftTokens::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldGiftTokens::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldGiftTokens::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGiftTokens.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldGiftTokens::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldGiftTokens::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGiftTokens.overworld_id)
}

// optional .CMsgOverworldTokenCount token_gift = 2;
inline bool CMsgClientToGCOverworldGiftTokens::_internal_has_token_gift() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_gift_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldGiftTokens::has_token_gift() const {
  return _internal_has_token_gift();
}
inline void CMsgClientToGCOverworldGiftTokens::clear_token_gift() {
  if (_impl_.token_gift_ != nullptr) _impl_.token_gift_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenCount& CMsgClientToGCOverworldGiftTokens::_internal_token_gift() const {
  const ::CMsgOverworldTokenCount* p = _impl_.token_gift_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenCount&>(
      ::_CMsgOverworldTokenCount_default_instance_);
}
inline const ::CMsgOverworldTokenCount& CMsgClientToGCOverworldGiftTokens::token_gift() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGiftTokens.token_gift)
  return _internal_token_gift();
}
inline void CMsgClientToGCOverworldGiftTokens::unsafe_arena_set_allocated_token_gift(
    ::CMsgOverworldTokenCount* token_gift) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_gift_);
  }
  _impl_.token_gift_ = token_gift;
  if (token_gift) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldGiftTokens.token_gift)
}
inline ::CMsgOverworldTokenCount* CMsgClientToGCOverworldGiftTokens::release_token_gift() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenCount* temp = _impl_.token_gift_;
  _impl_.token_gift_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenCount* CMsgClientToGCOverworldGiftTokens::unsafe_arena_release_token_gift() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldGiftTokens.token_gift)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenCount* temp = _impl_.token_gift_;
  _impl_.token_gift_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenCount* CMsgClientToGCOverworldGiftTokens::_internal_mutable_token_gift() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_gift_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenCount>(GetArenaForAllocation());
    _impl_.token_gift_ = p;
  }
  return _impl_.token_gift_;
}
inline ::CMsgOverworldTokenCount* CMsgClientToGCOverworldGiftTokens::mutable_token_gift() {
  ::CMsgOverworldTokenCount* _msg = _internal_mutable_token_gift();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldGiftTokens.token_gift)
  return _msg;
}
inline void CMsgClientToGCOverworldGiftTokens::set_allocated_token_gift(::CMsgOverworldTokenCount* token_gift) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_gift_;
  }
  if (token_gift) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_gift);
    if (message_arena != submessage_arena) {
      token_gift = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_gift, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_gift_ = token_gift;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldGiftTokens.token_gift)
}

// optional uint32 recipient_account_id = 3;
inline bool CMsgClientToGCOverworldGiftTokens::_internal_has_recipient_account_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGiftTokens::has_recipient_account_id() const {
  return _internal_has_recipient_account_id();
}
inline void CMsgClientToGCOverworldGiftTokens::clear_recipient_account_id() {
  _impl_.recipient_account_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientToGCOverworldGiftTokens::_internal_recipient_account_id() const {
  return _impl_.recipient_account_id_;
}
inline uint32_t CMsgClientToGCOverworldGiftTokens::recipient_account_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGiftTokens.recipient_account_id)
  return _internal_recipient_account_id();
}
inline void CMsgClientToGCOverworldGiftTokens::_internal_set_recipient_account_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.recipient_account_id_ = value;
}
inline void CMsgClientToGCOverworldGiftTokens::set_recipient_account_id(uint32_t value) {
  _internal_set_recipient_account_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGiftTokens.recipient_account_id)
}

// optional uint32 periodic_resource_id = 4;
inline bool CMsgClientToGCOverworldGiftTokens::_internal_has_periodic_resource_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGiftTokens::has_periodic_resource_id() const {
  return _internal_has_periodic_resource_id();
}
inline void CMsgClientToGCOverworldGiftTokens::clear_periodic_resource_id() {
  _impl_.periodic_resource_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgClientToGCOverworldGiftTokens::_internal_periodic_resource_id() const {
  return _impl_.periodic_resource_id_;
}
inline uint32_t CMsgClientToGCOverworldGiftTokens::periodic_resource_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGiftTokens.periodic_resource_id)
  return _internal_periodic_resource_id();
}
inline void CMsgClientToGCOverworldGiftTokens::_internal_set_periodic_resource_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.periodic_resource_id_ = value;
}
inline void CMsgClientToGCOverworldGiftTokens::set_periodic_resource_id(uint32_t value) {
  _internal_set_periodic_resource_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGiftTokens.periodic_resource_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGiftTokensResponse

// optional .CMsgClientToGCOverworldGiftTokensResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldGiftTokensResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGiftTokensResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldGiftTokensResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldGiftTokensResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGiftTokensResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldGiftTokensResponse::_internal_set_response(::CMsgClientToGCOverworldGiftTokensResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldGiftTokensResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldGiftTokensResponse::set_response(::CMsgClientToGCOverworldGiftTokensResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGiftTokensResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevResetAll

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldDevResetAll::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevResetAll::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldDevResetAll::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldDevResetAll::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldDevResetAll::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevResetAll.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldDevResetAll::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldDevResetAll::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevResetAll.overworld_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevResetAllResponse

// optional .CMsgClientToGCOverworldDevResetAllResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldDevResetAllResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevResetAllResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldDevResetAllResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldDevResetAllResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevResetAllResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldDevResetAllResponse::_internal_set_response(::CMsgClientToGCOverworldDevResetAllResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldDevResetAllResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldDevResetAllResponse::set_response(::CMsgClientToGCOverworldDevResetAllResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevResetAllResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevResetNode

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldDevResetNode::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevResetNode::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldDevResetNode::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldDevResetNode::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldDevResetNode::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevResetNode.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldDevResetNode::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldDevResetNode::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevResetNode.overworld_id)
}

// optional uint32 node_id = 2;
inline bool CMsgClientToGCOverworldDevResetNode::_internal_has_node_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevResetNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void CMsgClientToGCOverworldDevResetNode::clear_node_id() {
  _impl_.node_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldDevResetNode::_internal_node_id() const {
  return _impl_.node_id_;
}
inline uint32_t CMsgClientToGCOverworldDevResetNode::node_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevResetNode.node_id)
  return _internal_node_id();
}
inline void CMsgClientToGCOverworldDevResetNode::_internal_set_node_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.node_id_ = value;
}
inline void CMsgClientToGCOverworldDevResetNode::set_node_id(uint32_t value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevResetNode.node_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevResetNodeResponse

// optional .CMsgClientToGCOverworldDevResetNodeResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldDevResetNodeResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevResetNodeResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldDevResetNodeResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevResetNodeResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldDevResetNodeResponse::_internal_set_response(::CMsgClientToGCOverworldDevResetNodeResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldDevResetNodeResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldDevResetNodeResponse::set_response(::CMsgClientToGCOverworldDevResetNodeResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevResetNodeResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevGrantTokens

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldDevGrantTokens::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevGrantTokens::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldDevGrantTokens::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldDevGrantTokens::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldDevGrantTokens::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevGrantTokens.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldDevGrantTokens::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldDevGrantTokens::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevGrantTokens.overworld_id)
}

// optional .CMsgOverworldTokenQuantity token_quantity = 2;
inline bool CMsgClientToGCOverworldDevGrantTokens::_internal_has_token_quantity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.token_quantity_ != nullptr);
  return value;
}
inline bool CMsgClientToGCOverworldDevGrantTokens::has_token_quantity() const {
  return _internal_has_token_quantity();
}
inline void CMsgClientToGCOverworldDevGrantTokens::clear_token_quantity() {
  if (_impl_.token_quantity_ != nullptr) _impl_.token_quantity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldDevGrantTokens::_internal_token_quantity() const {
  const ::CMsgOverworldTokenQuantity* p = _impl_.token_quantity_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgOverworldTokenQuantity&>(
      ::_CMsgOverworldTokenQuantity_default_instance_);
}
inline const ::CMsgOverworldTokenQuantity& CMsgClientToGCOverworldDevGrantTokens::token_quantity() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevGrantTokens.token_quantity)
  return _internal_token_quantity();
}
inline void CMsgClientToGCOverworldDevGrantTokens::unsafe_arena_set_allocated_token_quantity(
    ::CMsgOverworldTokenQuantity* token_quantity) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_quantity_);
  }
  _impl_.token_quantity_ = token_quantity;
  if (token_quantity) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgClientToGCOverworldDevGrantTokens.token_quantity)
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldDevGrantTokens::release_token_quantity() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_quantity_;
  _impl_.token_quantity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldDevGrantTokens::unsafe_arena_release_token_quantity() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldDevGrantTokens.token_quantity)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::CMsgOverworldTokenQuantity* temp = _impl_.token_quantity_;
  _impl_.token_quantity_ = nullptr;
  return temp;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldDevGrantTokens::_internal_mutable_token_quantity() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.token_quantity_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgOverworldTokenQuantity>(GetArenaForAllocation());
    _impl_.token_quantity_ = p;
  }
  return _impl_.token_quantity_;
}
inline ::CMsgOverworldTokenQuantity* CMsgClientToGCOverworldDevGrantTokens::mutable_token_quantity() {
  ::CMsgOverworldTokenQuantity* _msg = _internal_mutable_token_quantity();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldDevGrantTokens.token_quantity)
  return _msg;
}
inline void CMsgClientToGCOverworldDevGrantTokens::set_allocated_token_quantity(::CMsgOverworldTokenQuantity* token_quantity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_quantity_;
  }
  if (token_quantity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token_quantity);
    if (message_arena != submessage_arena) {
      token_quantity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token_quantity, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.token_quantity_ = token_quantity;
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldDevGrantTokens.token_quantity)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevGrantTokensResponse

// optional .CMsgClientToGCOverworldDevGrantTokensResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldDevGrantTokensResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevGrantTokensResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldDevGrantTokensResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevGrantTokensResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldDevGrantTokensResponse::_internal_set_response(::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldDevGrantTokensResponse::set_response(::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevGrantTokensResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevClearInventory

// optional uint32 overworld_id = 1;
inline bool CMsgClientToGCOverworldDevClearInventory::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevClearInventory::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldDevClearInventory::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldDevClearInventory::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldDevClearInventory::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevClearInventory.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldDevClearInventory::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldDevClearInventory::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevClearInventory.overworld_id)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldDevClearInventoryResponse

// optional .CMsgClientToGCOverworldDevClearInventoryResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldDevClearInventoryResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldDevClearInventoryResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldDevClearInventoryResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldDevClearInventoryResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldDevClearInventoryResponse::_internal_set_response(::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldDevClearInventoryResponse::set_response(::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldDevClearInventoryResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldFeedback

// optional uint32 language = 1;
inline bool CMsgClientToGCOverworldFeedback::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldFeedback::has_language() const {
  return _internal_has_language();
}
inline void CMsgClientToGCOverworldFeedback::clear_language() {
  _impl_.language_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldFeedback::_internal_language() const {
  return _impl_.language_;
}
inline uint32_t CMsgClientToGCOverworldFeedback::language() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldFeedback.language)
  return _internal_language();
}
inline void CMsgClientToGCOverworldFeedback::_internal_set_language(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.language_ = value;
}
inline void CMsgClientToGCOverworldFeedback::set_language(uint32_t value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldFeedback.language)
}

// optional uint32 overworld_id = 2;
inline bool CMsgClientToGCOverworldFeedback::_internal_has_overworld_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldFeedback::has_overworld_id() const {
  return _internal_has_overworld_id();
}
inline void CMsgClientToGCOverworldFeedback::clear_overworld_id() {
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientToGCOverworldFeedback::_internal_overworld_id() const {
  return _impl_.overworld_id_;
}
inline uint32_t CMsgClientToGCOverworldFeedback::overworld_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldFeedback.overworld_id)
  return _internal_overworld_id();
}
inline void CMsgClientToGCOverworldFeedback::_internal_set_overworld_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.overworld_id_ = value;
}
inline void CMsgClientToGCOverworldFeedback::set_overworld_id(uint32_t value) {
  _internal_set_overworld_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldFeedback.overworld_id)
}

// optional string feedback = 3;
inline bool CMsgClientToGCOverworldFeedback::_internal_has_feedback() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldFeedback::has_feedback() const {
  return _internal_has_feedback();
}
inline void CMsgClientToGCOverworldFeedback::clear_feedback() {
  _impl_.feedback_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientToGCOverworldFeedback::feedback() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldFeedback.feedback)
  return _internal_feedback();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientToGCOverworldFeedback::set_feedback(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.feedback_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldFeedback.feedback)
}
inline std::string* CMsgClientToGCOverworldFeedback::mutable_feedback() {
  std::string* _s = _internal_mutable_feedback();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldFeedback.feedback)
  return _s;
}
inline const std::string& CMsgClientToGCOverworldFeedback::_internal_feedback() const {
  return _impl_.feedback_.Get();
}
inline void CMsgClientToGCOverworldFeedback::_internal_set_feedback(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.feedback_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientToGCOverworldFeedback::_internal_mutable_feedback() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.feedback_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientToGCOverworldFeedback::release_feedback() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldFeedback.feedback)
  if (!_internal_has_feedback()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.feedback_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_.IsDefault()) {
    _impl_.feedback_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientToGCOverworldFeedback::set_allocated_feedback(std::string* feedback) {
  if (feedback != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.feedback_.SetAllocated(feedback, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.feedback_.IsDefault()) {
    _impl_.feedback_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldFeedback.feedback)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldFeedbackResponse

// optional .CMsgClientToGCOverworldFeedbackResponse.EResponse response = 1 [default = k_eInternalError];
inline bool CMsgClientToGCOverworldFeedbackResponse::_internal_has_response() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldFeedbackResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgClientToGCOverworldFeedbackResponse::clear_response() {
  _impl_.response_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::_internal_response() const {
  return static_cast< ::CMsgClientToGCOverworldFeedbackResponse_EResponse >(_impl_.response_);
}
inline ::CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldFeedbackResponse.response)
  return _internal_response();
}
inline void CMsgClientToGCOverworldFeedbackResponse::_internal_set_response(::CMsgClientToGCOverworldFeedbackResponse_EResponse value) {
  assert(::CMsgClientToGCOverworldFeedbackResponse_EResponse_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.response_ = value;
}
inline void CMsgClientToGCOverworldFeedbackResponse::set_response(::CMsgClientToGCOverworldFeedbackResponse_EResponse value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldFeedbackResponse.response)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGetDynamicImage

// optional uint32 magic = 1;
inline bool CMsgClientToGCOverworldGetDynamicImage::_internal_has_magic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImage::has_magic() const {
  return _internal_has_magic();
}
inline void CMsgClientToGCOverworldGetDynamicImage::clear_magic() {
  _impl_.magic_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImage::_internal_magic() const {
  return _impl_.magic_;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImage::magic() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImage.magic)
  return _internal_magic();
}
inline void CMsgClientToGCOverworldGetDynamicImage::_internal_set_magic(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.magic_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImage::set_magic(uint32_t value) {
  _internal_set_magic(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImage.magic)
}

// optional uint32 image_id = 2;
inline bool CMsgClientToGCOverworldGetDynamicImage::_internal_has_image_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImage::has_image_id() const {
  return _internal_has_image_id();
}
inline void CMsgClientToGCOverworldGetDynamicImage::clear_image_id() {
  _impl_.image_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImage::_internal_image_id() const {
  return _impl_.image_id_;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImage::image_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImage.image_id)
  return _internal_image_id();
}
inline void CMsgClientToGCOverworldGetDynamicImage::_internal_set_image_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.image_id_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImage::set_image_id(uint32_t value) {
  _internal_set_image_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImage.image_id)
}

// optional uint32 language = 3;
inline bool CMsgClientToGCOverworldGetDynamicImage::_internal_has_language() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImage::has_language() const {
  return _internal_has_language();
}
inline void CMsgClientToGCOverworldGetDynamicImage::clear_language() {
  _impl_.language_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImage::_internal_language() const {
  return _impl_.language_;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImage::language() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImage.language)
  return _internal_language();
}
inline void CMsgClientToGCOverworldGetDynamicImage::_internal_set_language(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.language_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImage::set_language(uint32_t value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImage.language)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGetDynamicImageResponse_Image

// optional uint32 width = 1;
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_has_width() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::has_width() const {
  return _internal_has_width();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::clear_width() {
  _impl_.width_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_width() const {
  return _impl_.width_;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImageResponse_Image::width() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImageResponse.Image.width)
  return _internal_width();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_set_width(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.width_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImageResponse.Image.width)
}

// optional uint32 height = 2;
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_has_height() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::has_height() const {
  return _internal_has_height();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::clear_height() {
  _impl_.height_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_height() const {
  return _impl_.height_;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImageResponse_Image::height() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImageResponse.Image.height)
  return _internal_height();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_set_height(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.height_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImageResponse.Image.height)
}

// optional .CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat format = 3 [default = k_eUnknown];
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::has_format() const {
  return _internal_has_format();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_format() const {
  return static_cast< ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat >(_impl_.format_);
}
inline ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse_Image::format() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImageResponse.Image.format)
  return _internal_format();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_set_format(::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat value) {
  assert(::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.format_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::set_format(::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImageResponse.Image.format)
}

// optional bytes image_bytes = 4;
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_has_image_bytes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::has_image_bytes() const {
  return _internal_has_image_bytes();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::clear_image_bytes() {
  _impl_.image_bytes_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientToGCOverworldGetDynamicImageResponse_Image::image_bytes() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImageResponse.Image.image_bytes)
  return _internal_image_bytes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientToGCOverworldGetDynamicImageResponse_Image::set_image_bytes(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.image_bytes_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImageResponse.Image.image_bytes)
}
inline std::string* CMsgClientToGCOverworldGetDynamicImageResponse_Image::mutable_image_bytes() {
  std::string* _s = _internal_mutable_image_bytes();
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldGetDynamicImageResponse.Image.image_bytes)
  return _s;
}
inline const std::string& CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_image_bytes() const {
  return _impl_.image_bytes_.Get();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_set_image_bytes(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.image_bytes_.Set(value, GetArenaForAllocation());
}
inline std::string* CMsgClientToGCOverworldGetDynamicImageResponse_Image::_internal_mutable_image_bytes() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.image_bytes_.Mutable(GetArenaForAllocation());
}
inline std::string* CMsgClientToGCOverworldGetDynamicImageResponse_Image::release_image_bytes() {
  // @@protoc_insertion_point(field_release:CMsgClientToGCOverworldGetDynamicImageResponse.Image.image_bytes)
  if (!_internal_has_image_bytes()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.image_bytes_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_bytes_.IsDefault()) {
    _impl_.image_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::set_allocated_image_bytes(std::string* image_bytes) {
  if (image_bytes != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.image_bytes_.SetAllocated(image_bytes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_bytes_.IsDefault()) {
    _impl_.image_bytes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientToGCOverworldGetDynamicImageResponse.Image.image_bytes)
}

// -------------------------------------------------------------------

// CMsgClientToGCOverworldGetDynamicImageResponse

// optional uint32 image_id = 1;
inline bool CMsgClientToGCOverworldGetDynamicImageResponse::_internal_has_image_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientToGCOverworldGetDynamicImageResponse::has_image_id() const {
  return _internal_has_image_id();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse::clear_image_id() {
  _impl_.image_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImageResponse::_internal_image_id() const {
  return _impl_.image_id_;
}
inline uint32_t CMsgClientToGCOverworldGetDynamicImageResponse::image_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImageResponse.image_id)
  return _internal_image_id();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse::_internal_set_image_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.image_id_ = value;
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse::set_image_id(uint32_t value) {
  _internal_set_image_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientToGCOverworldGetDynamicImageResponse.image_id)
}

// repeated .CMsgClientToGCOverworldGetDynamicImageResponse.Image images = 2;
inline int CMsgClientToGCOverworldGetDynamicImageResponse::_internal_images_size() const {
  return _impl_.images_.size();
}
inline int CMsgClientToGCOverworldGetDynamicImageResponse::images_size() const {
  return _internal_images_size();
}
inline void CMsgClientToGCOverworldGetDynamicImageResponse::clear_images() {
  _impl_.images_.Clear();
}
inline ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* CMsgClientToGCOverworldGetDynamicImageResponse::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgClientToGCOverworldGetDynamicImageResponse.images)
  return _impl_.images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image >*
CMsgClientToGCOverworldGetDynamicImageResponse::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:CMsgClientToGCOverworldGetDynamicImageResponse.images)
  return &_impl_.images_;
}
inline const ::CMsgClientToGCOverworldGetDynamicImageResponse_Image& CMsgClientToGCOverworldGetDynamicImageResponse::_internal_images(int index) const {
  return _impl_.images_.Get(index);
}
inline const ::CMsgClientToGCOverworldGetDynamicImageResponse_Image& CMsgClientToGCOverworldGetDynamicImageResponse::images(int index) const {
  // @@protoc_insertion_point(field_get:CMsgClientToGCOverworldGetDynamicImageResponse.images)
  return _internal_images(index);
}
inline ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* CMsgClientToGCOverworldGetDynamicImageResponse::_internal_add_images() {
  return _impl_.images_.Add();
}
inline ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* CMsgClientToGCOverworldGetDynamicImageResponse::add_images() {
  ::CMsgClientToGCOverworldGetDynamicImageResponse_Image* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:CMsgClientToGCOverworldGetDynamicImageResponse.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image >&
CMsgClientToGCOverworldGetDynamicImageResponse::images() const {
  // @@protoc_insertion_point(field_list:CMsgClientToGCOverworldGetDynamicImageResponse.images)
  return _impl_.images_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CMsgClientToGCOverworldGetUserDataResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldGetUserDataResponse_EResponse>() {
  return ::CMsgClientToGCOverworldGetUserDataResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldCompletePathResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldCompletePathResponse_EResponse>() {
  return ::CMsgClientToGCOverworldCompletePathResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse>() {
  return ::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse>() {
  return ::CMsgClientToGCOverworldVisitEncounterResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse>() {
  return ::CMsgClientToGCOverworldMoveToNodeResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldTradeTokensResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldTradeTokensResponse_EResponse>() {
  return ::CMsgClientToGCOverworldTradeTokensResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldGiftTokensResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldGiftTokensResponse_EResponse>() {
  return ::CMsgClientToGCOverworldGiftTokensResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldDevResetAllResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldDevResetAllResponse_EResponse>() {
  return ::CMsgClientToGCOverworldDevResetAllResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse>() {
  return ::CMsgClientToGCOverworldDevResetNodeResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse>() {
  return ::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse>() {
  return ::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldFeedbackResponse_EResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldFeedbackResponse_EResponse>() {
  return ::CMsgClientToGCOverworldFeedbackResponse_EResponse_descriptor();
}
template <> struct is_proto_enum< ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat>() {
  return ::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_descriptor();
}
template <> struct is_proto_enum< ::EOverworldNodeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EOverworldNodeState>() {
  return ::EOverworldNodeState_descriptor();
}
template <> struct is_proto_enum< ::EOverworldAuditAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EOverworldAuditAction>() {
  return ::EOverworldAuditAction_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dota_5fgcmessages_5fcommon_5foverworld_2eproto
