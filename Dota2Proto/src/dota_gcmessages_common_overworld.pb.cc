// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dota_gcmessages_common_overworld.proto

#include "dota_gcmessages_common_overworld.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgOverworldTokenCount::CMsgOverworldTokenCount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_id_)*/0u
  , /*decltype(_impl_.token_count_)*/0u} {}
struct CMsgOverworldTokenCountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldTokenCountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldTokenCountDefaultTypeInternal() {}
  union {
    CMsgOverworldTokenCount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldTokenCountDefaultTypeInternal _CMsgOverworldTokenCount_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldTokenQuantity::CMsgOverworldTokenQuantity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.token_counts_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgOverworldTokenQuantityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldTokenQuantityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldTokenQuantityDefaultTypeInternal() {}
  union {
    CMsgOverworldTokenQuantity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldTokenQuantityDefaultTypeInternal _CMsgOverworldTokenQuantity_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenTreasureData_RewardOption::CMsgOverworldEncounterTokenTreasureData_RewardOption(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_cost_)*/nullptr
  , /*decltype(_impl_.token_reward_)*/nullptr
  , /*decltype(_impl_.reward_data_)*/0u} {}
struct CMsgOverworldEncounterTokenTreasureData_RewardOptionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenTreasureData_RewardOptionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterTokenTreasureData_RewardOptionDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterTokenTreasureData_RewardOption _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterTokenTreasureData_RewardOptionDefaultTypeInternal _CMsgOverworldEncounterTokenTreasureData_RewardOption_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenTreasureData::CMsgOverworldEncounterTokenTreasureData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.reward_options_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgOverworldEncounterTokenTreasureDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenTreasureDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterTokenTreasureDataDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterTokenTreasureData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterTokenTreasureDataDefaultTypeInternal _CMsgOverworldEncounterTokenTreasureData_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenQuestData_Quest::CMsgOverworldEncounterTokenQuestData_Quest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_cost_)*/nullptr
  , /*decltype(_impl_.token_reward_)*/nullptr
  , /*decltype(_impl_.reward_data_)*/0u} {}
struct CMsgOverworldEncounterTokenQuestData_QuestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenQuestData_QuestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterTokenQuestData_QuestDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterTokenQuestData_Quest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterTokenQuestData_QuestDefaultTypeInternal _CMsgOverworldEncounterTokenQuestData_Quest_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenQuestData::CMsgOverworldEncounterTokenQuestData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.quests_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgOverworldEncounterTokenQuestDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterTokenQuestDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterTokenQuestDataDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterTokenQuestData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterTokenQuestDataDefaultTypeInternal _CMsgOverworldEncounterTokenQuestData_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldHeroList::CMsgOverworldHeroList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hero_ids_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgOverworldHeroListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldHeroListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldHeroListDefaultTypeInternal() {}
  union {
    CMsgOverworldHeroList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldHeroListDefaultTypeInternal _CMsgOverworldHeroList_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterChooseHeroData::CMsgOverworldEncounterChooseHeroData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.hero_list_)*/nullptr
  , /*decltype(_impl_.additive_)*/false} {}
struct CMsgOverworldEncounterChooseHeroDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterChooseHeroDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterChooseHeroDataDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterChooseHeroData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterChooseHeroDataDefaultTypeInternal _CMsgOverworldEncounterChooseHeroData_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterProgressData::CMsgOverworldEncounterProgressData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.choice_)*/0
  , /*decltype(_impl_.progress_)*/0
  , /*decltype(_impl_.max_progress_)*/0
  , /*decltype(_impl_.visited_)*/false} {}
struct CMsgOverworldEncounterProgressDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterProgressDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterProgressDataDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterProgressData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterProgressDataDefaultTypeInternal _CMsgOverworldEncounterProgressData_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterData::CMsgOverworldEncounterData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.extra_encounter_data_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgOverworldEncounterDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterDataDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterDataDefaultTypeInternal _CMsgOverworldEncounterData_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldNode::CMsgOverworldNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.node_encounter_data_)*/nullptr
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.node_state_)*/0} {}
struct CMsgOverworldNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldNodeDefaultTypeInternal() {}
  union {
    CMsgOverworldNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldNodeDefaultTypeInternal _CMsgOverworldNode_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldPath::CMsgOverworldPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_cost_)*/nullptr
  , /*decltype(_impl_.path_id_)*/0u} {}
struct CMsgOverworldPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldPathDefaultTypeInternal() {}
  union {
    CMsgOverworldPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldPathDefaultTypeInternal _CMsgOverworldPath_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldUserData::CMsgOverworldUserData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_nodes_)*/{}
  , /*decltype(_impl_.overworld_paths_)*/{}
  , /*decltype(_impl_.token_inventory_)*/nullptr
  , /*decltype(_impl_.current_node_id_)*/0u} {}
struct CMsgOverworldUserDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldUserDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldUserDataDefaultTypeInternal() {}
  union {
    CMsgOverworldUserData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldUserDataDefaultTypeInternal _CMsgOverworldUserData_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldMatchRewards_Player::CMsgOverworldMatchRewards_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tokens_)*/nullptr
  , /*decltype(_impl_.player_slot_)*/0u
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgOverworldMatchRewards_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldMatchRewards_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldMatchRewards_PlayerDefaultTypeInternal() {}
  union {
    CMsgOverworldMatchRewards_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldMatchRewards_PlayerDefaultTypeInternal _CMsgOverworldMatchRewards_Player_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldMatchRewards::CMsgOverworldMatchRewards(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CMsgOverworldMatchRewardsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldMatchRewardsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldMatchRewardsDefaultTypeInternal() {}
  union {
    CMsgOverworldMatchRewards _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldMatchRewardsDefaultTypeInternal _CMsgOverworldMatchRewards_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetUserData::CMsgClientToGCOverworldGetUserData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgClientToGCOverworldGetUserDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetUserDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGetUserDataDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGetUserData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGetUserDataDefaultTypeInternal _CMsgClientToGCOverworldGetUserData_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetUserDataResponse::CMsgClientToGCOverworldGetUserDataResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_data_)*/nullptr
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldGetUserDataResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetUserDataResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGetUserDataResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGetUserDataResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGetUserDataResponseDefaultTypeInternal _CMsgClientToGCOverworldGetUserDataResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgGCToClientOverworldUserDataUpdated::CMsgGCToClientOverworldUserDataUpdated(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.user_data_)*/nullptr
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgGCToClientOverworldUserDataUpdatedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgGCToClientOverworldUserDataUpdatedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgGCToClientOverworldUserDataUpdatedDefaultTypeInternal() {}
  union {
    CMsgGCToClientOverworldUserDataUpdated _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgGCToClientOverworldUserDataUpdatedDefaultTypeInternal _CMsgGCToClientOverworldUserDataUpdated_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldCompletePath::CMsgClientToGCOverworldCompletePath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.path_id_)*/0u} {}
struct CMsgClientToGCOverworldCompletePathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldCompletePathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldCompletePathDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldCompletePath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldCompletePathDefaultTypeInternal _CMsgClientToGCOverworldCompletePath_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldCompletePathResponse::CMsgClientToGCOverworldCompletePathResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.claim_response_)*/nullptr
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldCompletePathResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldCompletePathResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldCompletePathResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldCompletePathResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldCompletePathResponseDefaultTypeInternal _CMsgClientToGCOverworldCompletePathResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgOverworldEncounterPitFighterRewardData::CMsgOverworldEncounterPitFighterRewardData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_id_)*/0u
  , /*decltype(_impl_.choice_)*/0u} {}
struct CMsgOverworldEncounterPitFighterRewardDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgOverworldEncounterPitFighterRewardDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgOverworldEncounterPitFighterRewardDataDefaultTypeInternal() {}
  union {
    CMsgOverworldEncounterPitFighterRewardData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgOverworldEncounterPitFighterRewardDataDefaultTypeInternal _CMsgOverworldEncounterPitFighterRewardData_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldClaimEncounterReward::CMsgClientToGCOverworldClaimEncounterReward(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.extra_reward_data_)*/nullptr
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.node_id_)*/0u
  , /*decltype(_impl_.reward_data_)*/0u
  , /*decltype(_impl_.periodic_resource_id_)*/0u} {}
struct CMsgClientToGCOverworldClaimEncounterRewardDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldClaimEncounterRewardDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldClaimEncounterRewardDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldClaimEncounterReward _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldClaimEncounterRewardDefaultTypeInternal _CMsgClientToGCOverworldClaimEncounterReward_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldClaimEncounterRewardResponse::CMsgClientToGCOverworldClaimEncounterRewardResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.claim_response_)*/nullptr
  , /*decltype(_impl_.tokens_received_)*/nullptr
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldClaimEncounterRewardResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldClaimEncounterRewardResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldClaimEncounterRewardResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldClaimEncounterRewardResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldClaimEncounterRewardResponseDefaultTypeInternal _CMsgClientToGCOverworldClaimEncounterRewardResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldVisitEncounter::CMsgClientToGCOverworldVisitEncounter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.node_id_)*/0u} {}
struct CMsgClientToGCOverworldVisitEncounterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldVisitEncounterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldVisitEncounterDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldVisitEncounter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldVisitEncounterDefaultTypeInternal _CMsgClientToGCOverworldVisitEncounter_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldVisitEncounterResponse::CMsgClientToGCOverworldVisitEncounterResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldVisitEncounterResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldVisitEncounterResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldVisitEncounterResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldVisitEncounterResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldVisitEncounterResponseDefaultTypeInternal _CMsgClientToGCOverworldVisitEncounterResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldMoveToNode::CMsgClientToGCOverworldMoveToNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.node_id_)*/0u} {}
struct CMsgClientToGCOverworldMoveToNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldMoveToNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldMoveToNodeDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldMoveToNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldMoveToNodeDefaultTypeInternal _CMsgClientToGCOverworldMoveToNode_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldMoveToNodeResponse::CMsgClientToGCOverworldMoveToNodeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldMoveToNodeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldMoveToNodeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldMoveToNodeResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldMoveToNodeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldMoveToNodeResponseDefaultTypeInternal _CMsgClientToGCOverworldMoveToNodeResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldTradeTokens::CMsgClientToGCOverworldTradeTokens(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_offer_)*/nullptr
  , /*decltype(_impl_.token_request_)*/nullptr
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.recipe_)*/0u
  , /*decltype(_impl_.encounter_id_)*/0u} {}
struct CMsgClientToGCOverworldTradeTokensDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldTradeTokensDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldTradeTokensDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldTradeTokens _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldTradeTokensDefaultTypeInternal _CMsgClientToGCOverworldTradeTokens_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldTradeTokensResponse::CMsgClientToGCOverworldTradeTokensResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tokens_received_)*/nullptr
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldTradeTokensResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldTradeTokensResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldTradeTokensResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldTradeTokensResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldTradeTokensResponseDefaultTypeInternal _CMsgClientToGCOverworldTradeTokensResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGiftTokens::CMsgClientToGCOverworldGiftTokens(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_gift_)*/nullptr
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.recipient_account_id_)*/0u
  , /*decltype(_impl_.periodic_resource_id_)*/0u} {}
struct CMsgClientToGCOverworldGiftTokensDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGiftTokensDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGiftTokensDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGiftTokens _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGiftTokensDefaultTypeInternal _CMsgClientToGCOverworldGiftTokens_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGiftTokensResponse::CMsgClientToGCOverworldGiftTokensResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldGiftTokensResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGiftTokensResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGiftTokensResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGiftTokensResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGiftTokensResponseDefaultTypeInternal _CMsgClientToGCOverworldGiftTokensResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetAll::CMsgClientToGCOverworldDevResetAll(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgClientToGCOverworldDevResetAllDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetAllDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevResetAllDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevResetAll _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevResetAllDefaultTypeInternal _CMsgClientToGCOverworldDevResetAll_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetAllResponse::CMsgClientToGCOverworldDevResetAllResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldDevResetAllResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetAllResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevResetAllResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevResetAllResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevResetAllResponseDefaultTypeInternal _CMsgClientToGCOverworldDevResetAllResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetNode::CMsgClientToGCOverworldDevResetNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u
  , /*decltype(_impl_.node_id_)*/0u} {}
struct CMsgClientToGCOverworldDevResetNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevResetNodeDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevResetNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevResetNodeDefaultTypeInternal _CMsgClientToGCOverworldDevResetNode_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetNodeResponse::CMsgClientToGCOverworldDevResetNodeResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldDevResetNodeResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevResetNodeResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevResetNodeResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevResetNodeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevResetNodeResponseDefaultTypeInternal _CMsgClientToGCOverworldDevResetNodeResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevGrantTokens::CMsgClientToGCOverworldDevGrantTokens(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_quantity_)*/nullptr
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgClientToGCOverworldDevGrantTokensDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevGrantTokensDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevGrantTokensDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevGrantTokens _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevGrantTokensDefaultTypeInternal _CMsgClientToGCOverworldDevGrantTokens_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevGrantTokensResponse::CMsgClientToGCOverworldDevGrantTokensResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldDevGrantTokensResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevGrantTokensResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevGrantTokensResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevGrantTokensResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevGrantTokensResponseDefaultTypeInternal _CMsgClientToGCOverworldDevGrantTokensResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevClearInventory::CMsgClientToGCOverworldDevClearInventory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgClientToGCOverworldDevClearInventoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevClearInventoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevClearInventoryDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevClearInventory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevClearInventoryDefaultTypeInternal _CMsgClientToGCOverworldDevClearInventory_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevClearInventoryResponse::CMsgClientToGCOverworldDevClearInventoryResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldDevClearInventoryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldDevClearInventoryResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldDevClearInventoryResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldDevClearInventoryResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldDevClearInventoryResponseDefaultTypeInternal _CMsgClientToGCOverworldDevClearInventoryResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldFeedback::CMsgClientToGCOverworldFeedback(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.feedback_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/0u
  , /*decltype(_impl_.overworld_id_)*/0u} {}
struct CMsgClientToGCOverworldFeedbackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldFeedbackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldFeedbackDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldFeedback _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldFeedbackDefaultTypeInternal _CMsgClientToGCOverworldFeedback_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldFeedbackResponse::CMsgClientToGCOverworldFeedbackResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.response_)*/0} {}
struct CMsgClientToGCOverworldFeedbackResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldFeedbackResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldFeedbackResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldFeedbackResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldFeedbackResponseDefaultTypeInternal _CMsgClientToGCOverworldFeedbackResponse_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImage::CMsgClientToGCOverworldGetDynamicImage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.magic_)*/0u
  , /*decltype(_impl_.image_id_)*/0u
  , /*decltype(_impl_.language_)*/0u} {}
struct CMsgClientToGCOverworldGetDynamicImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGetDynamicImageDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGetDynamicImage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGetDynamicImageDefaultTypeInternal _CMsgClientToGCOverworldGetDynamicImage_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageResponse_Image::CMsgClientToGCOverworldGetDynamicImageResponse_Image(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.image_bytes_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.width_)*/0u
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_.format_)*/0} {}
struct CMsgClientToGCOverworldGetDynamicImageResponse_ImageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageResponse_ImageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGetDynamicImageResponse_ImageDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGetDynamicImageResponse_Image _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGetDynamicImageResponse_ImageDefaultTypeInternal _CMsgClientToGCOverworldGetDynamicImageResponse_Image_default_instance_;
PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageResponse::CMsgClientToGCOverworldGetDynamicImageResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.images_)*/{}
  , /*decltype(_impl_.image_id_)*/0u} {}
struct CMsgClientToGCOverworldGetDynamicImageResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgClientToGCOverworldGetDynamicImageResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgClientToGCOverworldGetDynamicImageResponseDefaultTypeInternal() {}
  union {
    CMsgClientToGCOverworldGetDynamicImageResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgClientToGCOverworldGetDynamicImageResponseDefaultTypeInternal _CMsgClientToGCOverworldGetDynamicImageResponse_default_instance_;
static ::_pb::Metadata file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[44];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[15];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto = nullptr;

const uint32_t TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldTokenCount, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldTokenCount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldTokenCount, _impl_.token_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldTokenCount, _impl_.token_count_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldTokenQuantity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldTokenQuantity, _impl_.token_counts_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData_RewardOption, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData_RewardOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData_RewardOption, _impl_.reward_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData_RewardOption, _impl_.token_cost_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData_RewardOption, _impl_.token_reward_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenTreasureData, _impl_.reward_options_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData_Quest, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData_Quest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData_Quest, _impl_.reward_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData_Quest, _impl_.token_cost_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData_Quest, _impl_.token_reward_),
  2,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterTokenQuestData, _impl_.quests_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldHeroList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldHeroList, _impl_.hero_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterChooseHeroData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterChooseHeroData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterChooseHeroData, _impl_.hero_list_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterChooseHeroData, _impl_.additive_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterProgressData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterProgressData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterProgressData, _impl_.choice_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterProgressData, _impl_.progress_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterProgressData, _impl_.max_progress_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterProgressData, _impl_.visited_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterData, _impl_.extra_encounter_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldNode, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldNode, _impl_.node_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldNode, _impl_.node_encounter_data_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldPath, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldPath, _impl_.path_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldPath, _impl_.path_cost_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldUserData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldUserData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldUserData, _impl_.token_inventory_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldUserData, _impl_.overworld_nodes_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldUserData, _impl_.overworld_paths_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldUserData, _impl_.current_node_id_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards_Player, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards_Player, _impl_.tokens_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards_Player, _impl_.overworld_id_),
  1,
  0,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldMatchRewards, _impl_.players_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserData, _impl_.overworld_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserDataResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserDataResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserDataResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetUserDataResponse, _impl_.user_data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientOverworldUserDataUpdated, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientOverworldUserDataUpdated, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientOverworldUserDataUpdated, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgGCToClientOverworldUserDataUpdated, _impl_.user_data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePath, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePath, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePath, _impl_.path_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePathResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePathResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldCompletePathResponse, _impl_.claim_response_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterPitFighterRewardData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterPitFighterRewardData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterPitFighterRewardData, _impl_.token_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgOverworldEncounterPitFighterRewardData, _impl_.choice_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _impl_.node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _impl_.reward_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _impl_.periodic_resource_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterReward, _impl_.extra_reward_data_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterRewardResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterRewardResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterRewardResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterRewardResponse, _impl_.claim_response_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldClaimEncounterRewardResponse, _impl_.tokens_received_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounter, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounter, _impl_.node_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounterResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounterResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldVisitEncounterResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNode, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNode, _impl_.node_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNodeResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNodeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldMoveToNodeResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _impl_.token_offer_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _impl_.token_request_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _impl_.recipe_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokens, _impl_.encounter_id_),
  2,
  0,
  1,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokensResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokensResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokensResponse, _impl_.response_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldTradeTokensResponse, _impl_.tokens_received_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokens, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokens, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokens, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokens, _impl_.token_gift_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokens, _impl_.recipient_account_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokens, _impl_.periodic_resource_id_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokensResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokensResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGiftTokensResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetAll, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetAll, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetAll, _impl_.overworld_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetAllResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetAllResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetAllResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNode, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNode, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNode, _impl_.node_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNodeResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNodeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevResetNodeResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokens, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokens, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokens, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokens, _impl_.token_quantity_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokensResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokensResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevGrantTokensResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevClearInventory, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevClearInventory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevClearInventory, _impl_.overworld_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevClearInventoryResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevClearInventoryResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldDevClearInventoryResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedback, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedback, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedback, _impl_.language_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedback, _impl_.overworld_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedback, _impl_.feedback_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedbackResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedbackResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldFeedbackResponse, _impl_.response_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImage, _impl_.magic_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImage, _impl_.image_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImage, _impl_.language_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse_Image, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_.image_bytes_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse, _impl_.image_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgClientToGCOverworldGetDynamicImageResponse, _impl_.images_),
  0,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CMsgOverworldTokenCount)},
  { 10, -1, -1, sizeof(::CMsgOverworldTokenQuantity)},
  { 17, 26, -1, sizeof(::CMsgOverworldEncounterTokenTreasureData_RewardOption)},
  { 29, -1, -1, sizeof(::CMsgOverworldEncounterTokenTreasureData)},
  { 36, 45, -1, sizeof(::CMsgOverworldEncounterTokenQuestData_Quest)},
  { 48, -1, -1, sizeof(::CMsgOverworldEncounterTokenQuestData)},
  { 55, -1, -1, sizeof(::CMsgOverworldHeroList)},
  { 62, 70, -1, sizeof(::CMsgOverworldEncounterChooseHeroData)},
  { 72, 82, -1, sizeof(::CMsgOverworldEncounterProgressData)},
  { 86, -1, -1, sizeof(::CMsgOverworldEncounterData)},
  { 93, 102, -1, sizeof(::CMsgOverworldNode)},
  { 105, 113, -1, sizeof(::CMsgOverworldPath)},
  { 115, 125, -1, sizeof(::CMsgOverworldUserData)},
  { 129, 138, -1, sizeof(::CMsgOverworldMatchRewards_Player)},
  { 141, -1, -1, sizeof(::CMsgOverworldMatchRewards)},
  { 148, 155, -1, sizeof(::CMsgClientToGCOverworldGetUserData)},
  { 156, 164, -1, sizeof(::CMsgClientToGCOverworldGetUserDataResponse)},
  { 166, 174, -1, sizeof(::CMsgGCToClientOverworldUserDataUpdated)},
  { 176, 184, -1, sizeof(::CMsgClientToGCOverworldCompletePath)},
  { 186, 194, -1, sizeof(::CMsgClientToGCOverworldCompletePathResponse)},
  { 196, 204, -1, sizeof(::CMsgOverworldEncounterPitFighterRewardData)},
  { 206, 217, -1, sizeof(::CMsgClientToGCOverworldClaimEncounterReward)},
  { 222, 231, -1, sizeof(::CMsgClientToGCOverworldClaimEncounterRewardResponse)},
  { 234, 242, -1, sizeof(::CMsgClientToGCOverworldVisitEncounter)},
  { 244, 251, -1, sizeof(::CMsgClientToGCOverworldVisitEncounterResponse)},
  { 252, 260, -1, sizeof(::CMsgClientToGCOverworldMoveToNode)},
  { 262, 269, -1, sizeof(::CMsgClientToGCOverworldMoveToNodeResponse)},
  { 270, 281, -1, sizeof(::CMsgClientToGCOverworldTradeTokens)},
  { 286, 294, -1, sizeof(::CMsgClientToGCOverworldTradeTokensResponse)},
  { 296, 306, -1, sizeof(::CMsgClientToGCOverworldGiftTokens)},
  { 310, 317, -1, sizeof(::CMsgClientToGCOverworldGiftTokensResponse)},
  { 318, 325, -1, sizeof(::CMsgClientToGCOverworldDevResetAll)},
  { 326, 333, -1, sizeof(::CMsgClientToGCOverworldDevResetAllResponse)},
  { 334, 342, -1, sizeof(::CMsgClientToGCOverworldDevResetNode)},
  { 344, 351, -1, sizeof(::CMsgClientToGCOverworldDevResetNodeResponse)},
  { 352, 360, -1, sizeof(::CMsgClientToGCOverworldDevGrantTokens)},
  { 362, 369, -1, sizeof(::CMsgClientToGCOverworldDevGrantTokensResponse)},
  { 370, 377, -1, sizeof(::CMsgClientToGCOverworldDevClearInventory)},
  { 378, 385, -1, sizeof(::CMsgClientToGCOverworldDevClearInventoryResponse)},
  { 386, 395, -1, sizeof(::CMsgClientToGCOverworldFeedback)},
  { 398, 405, -1, sizeof(::CMsgClientToGCOverworldFeedbackResponse)},
  { 406, 415, -1, sizeof(::CMsgClientToGCOverworldGetDynamicImage)},
  { 418, 428, -1, sizeof(::CMsgClientToGCOverworldGetDynamicImageResponse_Image)},
  { 432, 440, -1, sizeof(::CMsgClientToGCOverworldGetDynamicImageResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgOverworldTokenCount_default_instance_._instance,
  &::_CMsgOverworldTokenQuantity_default_instance_._instance,
  &::_CMsgOverworldEncounterTokenTreasureData_RewardOption_default_instance_._instance,
  &::_CMsgOverworldEncounterTokenTreasureData_default_instance_._instance,
  &::_CMsgOverworldEncounterTokenQuestData_Quest_default_instance_._instance,
  &::_CMsgOverworldEncounterTokenQuestData_default_instance_._instance,
  &::_CMsgOverworldHeroList_default_instance_._instance,
  &::_CMsgOverworldEncounterChooseHeroData_default_instance_._instance,
  &::_CMsgOverworldEncounterProgressData_default_instance_._instance,
  &::_CMsgOverworldEncounterData_default_instance_._instance,
  &::_CMsgOverworldNode_default_instance_._instance,
  &::_CMsgOverworldPath_default_instance_._instance,
  &::_CMsgOverworldUserData_default_instance_._instance,
  &::_CMsgOverworldMatchRewards_Player_default_instance_._instance,
  &::_CMsgOverworldMatchRewards_default_instance_._instance,
  &::_CMsgClientToGCOverworldGetUserData_default_instance_._instance,
  &::_CMsgClientToGCOverworldGetUserDataResponse_default_instance_._instance,
  &::_CMsgGCToClientOverworldUserDataUpdated_default_instance_._instance,
  &::_CMsgClientToGCOverworldCompletePath_default_instance_._instance,
  &::_CMsgClientToGCOverworldCompletePathResponse_default_instance_._instance,
  &::_CMsgOverworldEncounterPitFighterRewardData_default_instance_._instance,
  &::_CMsgClientToGCOverworldClaimEncounterReward_default_instance_._instance,
  &::_CMsgClientToGCOverworldClaimEncounterRewardResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldVisitEncounter_default_instance_._instance,
  &::_CMsgClientToGCOverworldVisitEncounterResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldMoveToNode_default_instance_._instance,
  &::_CMsgClientToGCOverworldMoveToNodeResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldTradeTokens_default_instance_._instance,
  &::_CMsgClientToGCOverworldTradeTokensResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldGiftTokens_default_instance_._instance,
  &::_CMsgClientToGCOverworldGiftTokensResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevResetAll_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevResetAllResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevResetNode_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevResetNodeResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevGrantTokens_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevGrantTokensResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevClearInventory_default_instance_._instance,
  &::_CMsgClientToGCOverworldDevClearInventoryResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldFeedback_default_instance_._instance,
  &::_CMsgClientToGCOverworldFeedbackResponse_default_instance_._instance,
  &::_CMsgClientToGCOverworldGetDynamicImage_default_instance_._instance,
  &::_CMsgClientToGCOverworldGetDynamicImageResponse_Image_default_instance_._instance,
  &::_CMsgClientToGCOverworldGetDynamicImageResponse_default_instance_._instance,
};

const char descriptor_table_protodef_dota_5fgcmessages_5fcommon_5foverworld_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n&dota_gcmessages_common_overworld.proto"
  "\032\023steammessages.proto\032\027dota_shared_enums"
  ".proto\032\034dota_gcmessages_common.proto\032\026gc"
  "sdk_gcmessages.proto\"@\n\027CMsgOverworldTok"
  "enCount\022\020\n\010token_id\030\001 \001(\r\022\023\n\013token_count"
  "\030\002 \001(\r\"L\n\032CMsgOverworldTokenQuantity\022.\n\014"
  "token_counts\030\001 \003(\0132\030.CMsgOverworldTokenC"
  "ount\"\202\002\n\'CMsgOverworldEncounterTokenTrea"
  "sureData\022M\n\016reward_options\030\001 \003(\01325.CMsgO"
  "verworldEncounterTokenTreasureData.Rewar"
  "dOption\032\207\001\n\014RewardOption\022\023\n\013reward_data\030"
  "\001 \001(\r\022/\n\ntoken_cost\030\002 \001(\0132\033.CMsgOverworl"
  "dTokenQuantity\0221\n\014token_reward\030\003 \001(\0132\033.C"
  "MsgOverworldTokenQuantity\"\346\001\n$CMsgOverwo"
  "rldEncounterTokenQuestData\022;\n\006quests\030\001 \003"
  "(\0132+.CMsgOverworldEncounterTokenQuestDat"
  "a.Quest\032\200\001\n\005Quest\022\023\n\013reward_data\030\001 \001(\r\022/"
  "\n\ntoken_cost\030\002 \001(\0132\033.CMsgOverworldTokenQ"
  "uantity\0221\n\014token_reward\030\003 \001(\0132\033.CMsgOver"
  "worldTokenQuantity\")\n\025CMsgOverworldHeroL"
  "ist\022\020\n\010hero_ids\030\001 \003(\005\"c\n$CMsgOverworldEn"
  "counterChooseHeroData\022)\n\thero_list\030\001 \001(\013"
  "2\026.CMsgOverworldHeroList\022\020\n\010additive\030\002 \001"
  "(\010\"m\n\"CMsgOverworldEncounterProgressData"
  "\022\016\n\006choice\030\001 \001(\005\022\020\n\010progress\030\002 \001(\005\022\024\n\014ma"
  "x_progress\030\003 \001(\005\022\017\n\007visited\030\004 \001(\010\"K\n\032CMs"
  "gOverworldEncounterData\022-\n\024extra_encount"
  "er_data\030\001 \003(\0132\017.CExtraMsgBlock\"\247\001\n\021CMsgO"
  "verworldNode\022\017\n\007node_id\030\001 \001(\r\022G\n\nnode_st"
  "ate\030\002 \001(\0162\024.EOverworldNodeState:\035k_eOver"
  "worldNodeState_Invalid\0228\n\023node_encounter"
  "_data\030\003 \001(\0132\033.CMsgOverworldEncounterData"
  "\"T\n\021CMsgOverworldPath\022\017\n\007path_id\030\001 \001(\r\022."
  "\n\tpath_cost\030\002 \001(\0132\033.CMsgOverworldTokenQu"
  "antity\"\300\001\n\025CMsgOverworldUserData\0224\n\017toke"
  "n_inventory\030\001 \001(\0132\033.CMsgOverworldTokenQu"
  "antity\022+\n\017overworld_nodes\030\002 \003(\0132\022.CMsgOv"
  "erworldNode\022+\n\017overworld_paths\030\003 \003(\0132\022.C"
  "MsgOverworldPath\022\027\n\017current_node_id\030\004 \001("
  "\r\"\261\001\n\031CMsgOverworldMatchRewards\0222\n\007playe"
  "rs\030\001 \003(\0132!.CMsgOverworldMatchRewards.Pla"
  "yer\032`\n\006Player\022\023\n\013player_slot\030\001 \001(\r\022+\n\006to"
  "kens\030\002 \001(\0132\033.CMsgOverworldTokenQuantity\022"
  "\024\n\014overworld_id\030\003 \001(\r\":\n\"CMsgClientToGCO"
  "verworldGetUserData\022\024\n\014overworld_id\030\001 \001("
  "\r\"\257\002\n*CMsgClientToGCOverworldGetUserData"
  "Response\022Y\n\010response\030\001 \001(\01625.CMsgClientT"
  "oGCOverworldGetUserDataResponse.ERespons"
  "e:\020k_eInternalError\022)\n\tuser_data\030\002 \001(\0132\026"
  ".CMsgOverworldUserData\"{\n\tEResponse\022\024\n\020k"
  "_eInternalError\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_e"
  "TooBusy\020\002\022\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout"
  "\020\004\022\027\n\023k_eInvalidOverworld\020\005\"i\n&CMsgGCToC"
  "lientOverworldUserDataUpdated\022\024\n\014overwor"
  "ld_id\030\001 \001(\r\022)\n\tuser_data\030\002 \001(\0132\026.CMsgOve"
  "rworldUserData\"L\n#CMsgClientToGCOverworl"
  "dCompletePath\022\024\n\014overworld_id\030\001 \001(\r\022\017\n\007p"
  "ath_id\030\002 \001(\r\"\237\003\n+CMsgClientToGCOverworld"
  "CompletePathResponse\022Z\n\010response\030\001 \001(\01626"
  ".CMsgClientToGCOverworldCompletePathResp"
  "onse.EResponse:\020k_eInternalError\0229\n\016clai"
  "m_response\030\002 \001(\0132!.CMsgDOTAClaimEventAct"
  "ionResponse\"\330\001\n\tEResponse\022\024\n\020k_eInternal"
  "Error\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooBusy\020\002\022"
  "\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022\027\n\023k_eI"
  "nvalidOverworld\020\005\022\022\n\016k_eInvalidPath\020\006\022\026\n"
  "\022k_eNotEnoughTokens\020\007\022\023\n\017k_ePathIsLocked"
  "\020\010\022\032\n\026k_ePathAlreadyUnlocked\020\t\"N\n*CMsgOv"
  "erworldEncounterPitFighterRewardData\022\020\n\010"
  "token_id\030\001 \001(\r\022\016\n\006choice\030\002 \001(\r\"\277\001\n+CMsgC"
  "lientToGCOverworldClaimEncounterReward\022\024"
  "\n\014overworld_id\030\001 \001(\r\022\017\n\007node_id\030\002 \001(\r\022\023\n"
  "\013reward_data\030\003 \001(\r\022\034\n\024periodic_resource_"
  "id\030\004 \001(\r\0226\n\021extra_reward_data\030\005 \001(\0132\033.CM"
  "sgOverworldEncounterData\"\212\005\n3CMsgClientT"
  "oGCOverworldClaimEncounterRewardResponse"
  "\022b\n\010response\030\001 \001(\0162>.CMsgClientToGCOverw"
  "orldClaimEncounterRewardResponse.ERespon"
  "se:\020k_eInternalError\0229\n\016claim_response\030\002"
  " \001(\0132!.CMsgDOTAClaimEventActionResponse\022"
  "4\n\017tokens_received\030\003 \001(\0132\033.CMsgOverworld"
  "TokenQuantity\"\375\002\n\tEResponse\022\024\n\020k_eIntern"
  "alError\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooBusy\020"
  "\002\022\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022\027\n\023k_"
  "eInvalidOverworld\020\005\022\022\n\016k_eInvalidNode\020\006\022"
  "\021\n\rk_eNodeLocked\020\007\022\033\n\027k_eRewardAlreadyCl"
  "aimed\020\010\022\027\n\023k_eNodeNotEncounter\020\t\022\036\n\032k_eE"
  "ncounterMissingRewards\020\n\022\"\n\036k_eInvalidEn"
  "counterRewardStyle\020\013\022\033\n\027k_eInvalidEncoun"
  "terData\020\014\022\037\n\033k_eNotEnoughTokensForReward"
  "\020\r\022!\n\035k_eNotEnoughResourceForReward\020\016\"N\n"
  "%CMsgClientToGCOverworldVisitEncounter\022\024"
  "\n\014overworld_id\030\001 \001(\r\022\017\n\007node_id\030\002 \001(\r\"\342\002"
  "\n-CMsgClientToGCOverworldVisitEncounterR"
  "esponse\022\\\n\010response\030\001 \001(\01628.CMsgClientTo"
  "GCOverworldVisitEncounterResponse.ERespo"
  "nse:\020k_eInternalError\"\322\001\n\tEResponse\022\024\n\020k"
  "_eInternalError\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_e"
  "TooBusy\020\002\022\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout"
  "\020\004\022\027\n\023k_eInvalidOverworld\020\005\022\022\n\016k_eInvali"
  "dNode\020\006\022\021\n\rk_eNodeLocked\020\007\022\027\n\023k_eNodeNot"
  "Encounter\020\010\022\025\n\021k_eAlreadyVisited\020\t\"J\n!CM"
  "sgClientToGCOverworldMoveToNode\022\024\n\014overw"
  "orld_id\030\001 \001(\r\022\017\n\007node_id\030\002 \001(\r\"\252\002\n)CMsgC"
  "lientToGCOverworldMoveToNodeResponse\022X\n\010"
  "response\030\001 \001(\01624.CMsgClientToGCOverworld"
  "MoveToNodeResponse.EResponse:\020k_eInterna"
  "lError\"\242\001\n\tEResponse\022\024\n\020k_eInternalError"
  "\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooBusy\020\002\022\017\n\013k_"
  "eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022\027\n\023k_eInvali"
  "dOverworld\020\005\022\022\n\016k_eInvalidNode\020\006\022\021\n\rk_eN"
  "odeLocked\020\007\"\306\001\n\"CMsgClientToGCOverworldT"
  "radeTokens\022\024\n\014overworld_id\030\001 \001(\r\0220\n\013toke"
  "n_offer\030\002 \001(\0132\033.CMsgOverworldTokenQuanti"
  "ty\0222\n\rtoken_request\030\003 \001(\0132\033.CMsgOverworl"
  "dTokenQuantity\022\016\n\006recipe\030\004 \001(\r\022\024\n\014encoun"
  "ter_id\030\005 \001(\r\"\334\003\n*CMsgClientToGCOverworld"
  "TradeTokensResponse\022Y\n\010response\030\001 \001(\01625."
  "CMsgClientToGCOverworldTradeTokensRespon"
  "se.EResponse:\020k_eInternalError\0224\n\017tokens"
  "_received\030\002 \001(\0132\033.CMsgOverworldTokenQuan"
  "tity\"\234\002\n\tEResponse\022\024\n\020k_eInternalError\020\000"
  "\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooBusy\020\002\022\017\n\013k_eD"
  "isabled\020\003\022\016\n\nk_eTimeout\020\004\022\021\n\rk_eNotAllow"
  "ed\020\005\022\021\n\rk_eNodeLocked\020\006\022\027\n\023k_eInvalidOve"
  "rworld\020\007\022\023\n\017k_eInvalidOffer\020\010\022\026\n\022k_eNotE"
  "noughTokens\020\t\022\022\n\016k_eInvalidNode\020\n\022\027\n\023k_e"
  "InvalidEncounter\020\013\022\037\n\033k_eRewardDoesNotMa"
  "tchRecipe\020\014\"\243\001\n!CMsgClientToGCOverworldG"
  "iftTokens\022\024\n\014overworld_id\030\001 \001(\r\022,\n\ntoken"
  "_gift\030\002 \001(\0132\030.CMsgOverworldTokenCount\022\034\n"
  "\024recipient_account_id\030\003 \001(\r\022\034\n\024periodic_"
  "resource_id\030\004 \001(\r\"\220\003\n)CMsgClientToGCOver"
  "worldGiftTokensResponse\022X\n\010response\030\001 \001("
  "\01624.CMsgClientToGCOverworldGiftTokensRes"
  "ponse.EResponse:\020k_eInternalError\"\210\002\n\tER"
  "esponse\022\024\n\020k_eInternalError\020\000\022\016\n\nk_eSucc"
  "ess\020\001\022\016\n\nk_eTooBusy\020\002\022\017\n\013k_eDisabled\020\003\022\016"
  "\n\nk_eTimeout\020\004\022\021\n\rk_eNotAllowed\020\005\022\021\n\rk_e"
  "NodeLocked\020\006\022\027\n\023k_eInvalidOverworld\020\007\022\022\n"
  "\016k_eInvalidGift\020\010\022\026\n\022k_eNotEnoughTokens\020"
  "\t\022\027\n\023k_eInvalidRecipient\020\n\022 \n\034k_eNotEnou"
  "ghPeriodicResource\020\013\":\n\"CMsgClientToGCOv"
  "erworldDevResetAll\022\024\n\014overworld_id\030\001 \001(\r"
  "\"\230\002\n*CMsgClientToGCOverworldDevResetAllR"
  "esponse\022Y\n\010response\030\001 \001(\01625.CMsgClientTo"
  "GCOverworldDevResetAllResponse.EResponse"
  ":\020k_eInternalError\"\216\001\n\tEResponse\022\024\n\020k_eI"
  "nternalError\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eToo"
  "Busy\020\002\022\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022"
  "\021\n\rk_eNotAllowed\020\005\022\027\n\023k_eInvalidOverworl"
  "d\020\006\"L\n#CMsgClientToGCOverworldDevResetNo"
  "de\022\024\n\014overworld_id\030\001 \001(\r\022\017\n\007node_id\030\002 \001("
  "\r\"\256\002\n+CMsgClientToGCOverworldDevResetNod"
  "eResponse\022Z\n\010response\030\001 \001(\01626.CMsgClient"
  "ToGCOverworldDevResetNodeResponse.ERespo"
  "nse:\020k_eInternalError\"\242\001\n\tEResponse\022\024\n\020k"
  "_eInternalError\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_e"
  "TooBusy\020\002\022\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout"
  "\020\004\022\021\n\rk_eNotAllowed\020\005\022\027\n\023k_eInvalidOverw"
  "orld\020\006\022\022\n\016k_eInvalidNode\020\007\"r\n%CMsgClient"
  "ToGCOverworldDevGrantTokens\022\024\n\014overworld"
  "_id\030\001 \001(\r\0223\n\016token_quantity\030\002 \001(\0132\033.CMsg"
  "OverworldTokenQuantity\"\236\002\n-CMsgClientToG"
  "COverworldDevGrantTokensResponse\022\\\n\010resp"
  "onse\030\001 \001(\01628.CMsgClientToGCOverworldDevG"
  "rantTokensResponse.EResponse:\020k_eInterna"
  "lError\"\216\001\n\tEResponse\022\024\n\020k_eInternalError"
  "\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooBusy\020\002\022\017\n\013k_"
  "eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022\021\n\rk_eNotAll"
  "owed\020\005\022\027\n\023k_eInvalidOverworld\020\006\"@\n(CMsgC"
  "lientToGCOverworldDevClearInventory\022\024\n\014o"
  "verworld_id\030\001 \001(\r\"\244\002\n0CMsgClientToGCOver"
  "worldDevClearInventoryResponse\022_\n\010respon"
  "se\030\001 \001(\0162;.CMsgClientToGCOverworldDevCle"
  "arInventoryResponse.EResponse:\020k_eIntern"
  "alError\"\216\001\n\tEResponse\022\024\n\020k_eInternalErro"
  "r\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooBusy\020\002\022\017\n\013k"
  "_eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022\021\n\rk_eNotAl"
  "lowed\020\005\022\027\n\023k_eInvalidOverworld\020\006\"[\n\037CMsg"
  "ClientToGCOverworldFeedback\022\020\n\010language\030"
  "\001 \001(\r\022\024\n\014overworld_id\030\002 \001(\r\022\020\n\010feedback\030"
  "\003 \001(\t\"\222\002\n\'CMsgClientToGCOverworldFeedbac"
  "kResponse\022V\n\010response\030\001 \001(\01622.CMsgClient"
  "ToGCOverworldFeedbackResponse.EResponse:"
  "\020k_eInternalError\"\216\001\n\tEResponse\022\024\n\020k_eIn"
  "ternalError\020\000\022\016\n\nk_eSuccess\020\001\022\016\n\nk_eTooB"
  "usy\020\002\022\017\n\013k_eDisabled\020\003\022\016\n\nk_eTimeout\020\004\022\021"
  "\n\rk_eNotAllowed\020\005\022\027\n\023k_eInvalidOverworld"
  "\020\006\"[\n&CMsgClientToGCOverworldGetDynamicI"
  "mage\022\r\n\005magic\030\001 \001(\r\022\020\n\010image_id\030\002 \001(\r\022\020\n"
  "\010language\030\003 \001(\r\"\350\002\n.CMsgClientToGCOverwo"
  "rldGetDynamicImageResponse\022\020\n\010image_id\030\001"
  " \001(\r\022E\n\006images\030\002 \003(\01325.CMsgClientToGCOve"
  "rworldGetDynamicImageResponse.Image\032\234\001\n\005"
  "Image\022\r\n\005width\030\001 \001(\r\022\016\n\006height\030\002 \001(\r\022_\n\006"
  "format\030\003 \001(\0162C.CMsgClientToGCOverworldGe"
  "tDynamicImageResponse.EDynamicImageForma"
  "t:\nk_eUnknown\022\023\n\013image_bytes\030\004 \001(\014\">\n\023ED"
  "ynamicImageFormat\022\016\n\nk_eUnknown\020\000\022\n\n\006k_e"
  "PNG\020\001\022\013\n\007k_eData\020\002*~\n\023EOverworldNodeStat"
  "e\022!\n\035k_eOverworldNodeState_Invalid\020\000\022 \n\034"
  "k_eOverworldNodeState_Locked\020\001\022\"\n\036k_eOve"
  "rworldNodeState_Unlocked\020\002*\250\006\n\025EOverworl"
  "dAuditAction\022#\n\037k_eOverworldAuditAction_"
  "Invalid\020\000\022+\n\'k_eOverworldAuditAction_Dev"
  "ModifyTokens\020\001\022-\n)k_eOverworldAuditActio"
  "n_DevClearInventory\020\002\022*\n&k_eOverworldAud"
  "itAction_DevGrantTokens\020\003\022(\n$k_eOverworl"
  "dAuditAction_CompletePath\020\004\0220\n,k_eOverwo"
  "rldAuditAction_ClaimEncounterReward\020\005\022(\n"
  "$k_eOverworldAuditAction_DevResetNode\020\006\022"
  "(\n$k_eOverworldAuditAction_DevResetPath\020"
  "\007\022,\n(k_eOverworldAuditAction_MatchReward"
  "sFull\020\010\022,\n(k_eOverworldAuditAction_Match"
  "RewardsHalf\020\t\0221\n-k_eOverworldAuditAction"
  "_EventActionTokenGrant\020\n\022+\n\'k_eOverworld"
  "AuditAction_TokenTraderLost\020\013\022-\n)k_eOver"
  "worldAuditAction_TokenTraderGained\020\014\0224\n0"
  "k_eOverworldAuditAction_EncounterRewardT"
  "okenCost\020\r\0226\n2k_eOverworldAuditAction_En"
  "counterRewardTokenReward\020\016\022.\n*k_eOverwor"
  "ldAuditAction_SupportGrantTokens\020\020\022)\n%k_"
  "eOverworldAuditAction_TokenGiftSent\020\021"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_deps[4] = {
  &::descriptor_table_dota_5fgcmessages_5fcommon_2eproto,
  &::descriptor_table_dota_5fshared_5fenums_2eproto,
  &::descriptor_table_gcsdk_5fgcmessages_2eproto,
  &::descriptor_table_steammessages_2eproto,
};
static ::_pbi::once_flag descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto = {
    false, false, 8957, descriptor_table_protodef_dota_5fgcmessages_5fcommon_5foverworld_2eproto,
    "dota_gcmessages_common_overworld.proto",
    &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once, descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_deps, 4, 44,
    schemas, file_default_instances, TableStruct_dota_5fgcmessages_5fcommon_5foverworld_2eproto::offsets,
    file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto, file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto,
    file_level_service_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter() {
  return &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_dota_5fgcmessages_5fcommon_5foverworld_2eproto(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldGetUserDataResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[0];
}
bool CMsgClientToGCOverworldGetUserDataResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldGetUserDataResponse_EResponse CMsgClientToGCOverworldGetUserDataResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldGetUserDataResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldCompletePathResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[1];
}
bool CMsgClientToGCOverworldCompletePathResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eInvalidPath;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_eNotEnoughTokens;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_ePathIsLocked;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::k_ePathAlreadyUnlocked;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldCompletePathResponse_EResponse CMsgClientToGCOverworldCompletePathResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldCompletePathResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[2];
}
bool CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eInvalidNode;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eNodeLocked;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eRewardAlreadyClaimed;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eNodeNotEncounter;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eEncounterMissingRewards;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eInvalidEncounterRewardStyle;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eInvalidEncounterData;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eNotEnoughTokensForReward;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::k_eNotEnoughResourceForReward;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse CMsgClientToGCOverworldClaimEncounterRewardResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldClaimEncounterRewardResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldVisitEncounterResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[3];
}
bool CMsgClientToGCOverworldVisitEncounterResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eInvalidNode;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eNodeLocked;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eNodeNotEncounter;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::k_eAlreadyVisited;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldVisitEncounterResponse_EResponse CMsgClientToGCOverworldVisitEncounterResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldVisitEncounterResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldMoveToNodeResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[4];
}
bool CMsgClientToGCOverworldMoveToNodeResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eInvalidNode;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::k_eNodeLocked;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldMoveToNodeResponse_EResponse CMsgClientToGCOverworldMoveToNodeResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldMoveToNodeResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldTradeTokensResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[5];
}
bool CMsgClientToGCOverworldTradeTokensResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eNodeLocked;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eInvalidOffer;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eNotEnoughTokens;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eInvalidNode;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eInvalidEncounter;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::k_eRewardDoesNotMatchRecipe;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldTradeTokensResponse_EResponse CMsgClientToGCOverworldTradeTokensResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldTradeTokensResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldGiftTokensResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[6];
}
bool CMsgClientToGCOverworldGiftTokensResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eNodeLocked;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eInvalidGift;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eNotEnoughTokens;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eInvalidRecipient;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::k_eNotEnoughPeriodicResource;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldGiftTokensResponse_EResponse CMsgClientToGCOverworldGiftTokensResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldGiftTokensResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevResetAllResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[7];
}
bool CMsgClientToGCOverworldDevResetAllResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldDevResetAllResponse_EResponse CMsgClientToGCOverworldDevResetAllResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldDevResetAllResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevResetNodeResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[8];
}
bool CMsgClientToGCOverworldDevResetNodeResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::k_eInvalidNode;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldDevResetNodeResponse_EResponse CMsgClientToGCOverworldDevResetNodeResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldDevResetNodeResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[9];
}
bool CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldDevGrantTokensResponse_EResponse CMsgClientToGCOverworldDevGrantTokensResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldDevGrantTokensResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[10];
}
bool CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldDevClearInventoryResponse_EResponse CMsgClientToGCOverworldDevClearInventoryResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldDevClearInventoryResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldFeedbackResponse_EResponse_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[11];
}
bool CMsgClientToGCOverworldFeedbackResponse_EResponse_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eInternalError;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eSuccess;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eTooBusy;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eDisabled;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eTimeout;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eNotAllowed;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::k_eInvalidOverworld;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::EResponse_MIN;
constexpr CMsgClientToGCOverworldFeedbackResponse_EResponse CMsgClientToGCOverworldFeedbackResponse::EResponse_MAX;
constexpr int CMsgClientToGCOverworldFeedbackResponse::EResponse_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[12];
}
bool CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse::k_eUnknown;
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse::k_ePNG;
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse::k_eData;
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse::EDynamicImageFormat_MIN;
constexpr CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat CMsgClientToGCOverworldGetDynamicImageResponse::EDynamicImageFormat_MAX;
constexpr int CMsgClientToGCOverworldGetDynamicImageResponse::EDynamicImageFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverworldNodeState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[13];
}
bool EOverworldNodeState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOverworldAuditAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto);
  return file_level_enum_descriptors_dota_5fgcmessages_5fcommon_5foverworld_2eproto[14];
}
bool EOverworldAuditAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgOverworldTokenCount::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldTokenCount>()._impl_._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_token_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgOverworldTokenCount::CMsgOverworldTokenCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldTokenCount)
}
CMsgOverworldTokenCount::CMsgOverworldTokenCount(const CMsgOverworldTokenCount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldTokenCount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_id_){}
    , decltype(_impl_.token_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.token_id_, &from._impl_.token_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.token_count_) -
    reinterpret_cast<char*>(&_impl_.token_id_)) + sizeof(_impl_.token_count_));
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldTokenCount)
}

inline void CMsgOverworldTokenCount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_id_){0u}
    , decltype(_impl_.token_count_){0u}
  };
}

CMsgOverworldTokenCount::~CMsgOverworldTokenCount() {
  // @@protoc_insertion_point(destructor:CMsgOverworldTokenCount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldTokenCount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgOverworldTokenCount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldTokenCount::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldTokenCount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.token_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.token_count_) -
        reinterpret_cast<char*>(&_impl_.token_id_)) + sizeof(_impl_.token_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldTokenCount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 token_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_token_id(&has_bits);
          _impl_.token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 token_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_token_count(&has_bits);
          _impl_.token_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldTokenCount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldTokenCount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 token_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_token_id(), target);
  }

  // optional uint32 token_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_token_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldTokenCount)
  return target;
}

size_t CMsgOverworldTokenCount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldTokenCount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 token_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_token_id());
    }

    // optional uint32 token_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_token_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldTokenCount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldTokenCount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldTokenCount::GetClassData() const { return &_class_data_; }


void CMsgOverworldTokenCount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldTokenCount*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldTokenCount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldTokenCount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.token_id_ = from._impl_.token_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.token_count_ = from._impl_.token_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldTokenCount::CopyFrom(const CMsgOverworldTokenCount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldTokenCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldTokenCount::IsInitialized() const {
  return true;
}

void CMsgOverworldTokenCount::InternalSwap(CMsgOverworldTokenCount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldTokenCount, _impl_.token_count_)
      + sizeof(CMsgOverworldTokenCount::_impl_.token_count_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldTokenCount, _impl_.token_id_)>(
          reinterpret_cast<char*>(&_impl_.token_id_),
          reinterpret_cast<char*>(&other->_impl_.token_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldTokenCount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[0]);
}

// ===================================================================

class CMsgOverworldTokenQuantity::_Internal {
 public:
};

CMsgOverworldTokenQuantity::CMsgOverworldTokenQuantity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldTokenQuantity)
}
CMsgOverworldTokenQuantity::CMsgOverworldTokenQuantity(const CMsgOverworldTokenQuantity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldTokenQuantity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.token_counts_){from._impl_.token_counts_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldTokenQuantity)
}

inline void CMsgOverworldTokenQuantity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.token_counts_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgOverworldTokenQuantity::~CMsgOverworldTokenQuantity() {
  // @@protoc_insertion_point(destructor:CMsgOverworldTokenQuantity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldTokenQuantity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_counts_.~RepeatedPtrField();
}

void CMsgOverworldTokenQuantity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldTokenQuantity::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldTokenQuantity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.token_counts_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldTokenQuantity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgOverworldTokenCount token_counts = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_token_counts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldTokenQuantity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldTokenQuantity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgOverworldTokenCount token_counts = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_token_counts_size()); i < n; i++) {
    const auto& repfield = this->_internal_token_counts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldTokenQuantity)
  return target;
}

size_t CMsgOverworldTokenQuantity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldTokenQuantity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgOverworldTokenCount token_counts = 1;
  total_size += 1UL * this->_internal_token_counts_size();
  for (const auto& msg : this->_impl_.token_counts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldTokenQuantity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldTokenQuantity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldTokenQuantity::GetClassData() const { return &_class_data_; }


void CMsgOverworldTokenQuantity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldTokenQuantity*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldTokenQuantity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldTokenQuantity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.token_counts_.MergeFrom(from._impl_.token_counts_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldTokenQuantity::CopyFrom(const CMsgOverworldTokenQuantity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldTokenQuantity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldTokenQuantity::IsInitialized() const {
  return true;
}

void CMsgOverworldTokenQuantity::InternalSwap(CMsgOverworldTokenQuantity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.token_counts_.InternalSwap(&other->_impl_.token_counts_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldTokenQuantity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[1]);
}

// ===================================================================

class CMsgOverworldEncounterTokenTreasureData_RewardOption::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldEncounterTokenTreasureData_RewardOption>()._impl_._has_bits_);
  static void set_has_reward_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgOverworldTokenQuantity& token_cost(const CMsgOverworldEncounterTokenTreasureData_RewardOption* msg);
  static void set_has_token_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgOverworldTokenQuantity& token_reward(const CMsgOverworldEncounterTokenTreasureData_RewardOption* msg);
  static void set_has_token_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgOverworldEncounterTokenTreasureData_RewardOption::_Internal::token_cost(const CMsgOverworldEncounterTokenTreasureData_RewardOption* msg) {
  return *msg->_impl_.token_cost_;
}
const ::CMsgOverworldTokenQuantity&
CMsgOverworldEncounterTokenTreasureData_RewardOption::_Internal::token_reward(const CMsgOverworldEncounterTokenTreasureData_RewardOption* msg) {
  return *msg->_impl_.token_reward_;
}
CMsgOverworldEncounterTokenTreasureData_RewardOption::CMsgOverworldEncounterTokenTreasureData_RewardOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterTokenTreasureData.RewardOption)
}
CMsgOverworldEncounterTokenTreasureData_RewardOption::CMsgOverworldEncounterTokenTreasureData_RewardOption(const CMsgOverworldEncounterTokenTreasureData_RewardOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterTokenTreasureData_RewardOption* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_cost_){nullptr}
    , decltype(_impl_.token_reward_){nullptr}
    , decltype(_impl_.reward_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_cost()) {
    _this->_impl_.token_cost_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_cost_);
  }
  if (from._internal_has_token_reward()) {
    _this->_impl_.token_reward_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_reward_);
  }
  _this->_impl_.reward_data_ = from._impl_.reward_data_;
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterTokenTreasureData.RewardOption)
}

inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_cost_){nullptr}
    , decltype(_impl_.token_reward_){nullptr}
    , decltype(_impl_.reward_data_){0u}
  };
}

CMsgOverworldEncounterTokenTreasureData_RewardOption::~CMsgOverworldEncounterTokenTreasureData_RewardOption() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterTokenTreasureData_RewardOption::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_cost_;
  if (this != internal_default_instance()) delete _impl_.token_reward_;
}

void CMsgOverworldEncounterTokenTreasureData_RewardOption::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterTokenTreasureData_RewardOption::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.token_cost_ != nullptr);
      _impl_.token_cost_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.token_reward_ != nullptr);
      _impl_.token_reward_->Clear();
    }
  }
  _impl_.reward_data_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterTokenTreasureData_RewardOption::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 reward_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reward_data(&has_bits);
          _impl_.reward_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_reward = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_reward(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterTokenTreasureData_RewardOption::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 reward_data = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reward_data(), target);
  }

  // optional .CMsgOverworldTokenQuantity token_cost = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::token_cost(this),
        _Internal::token_cost(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgOverworldTokenQuantity token_reward = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::token_reward(this),
        _Internal::token_reward(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  return target;
}

size_t CMsgOverworldEncounterTokenTreasureData_RewardOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgOverworldTokenQuantity token_cost = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_cost_);
    }

    // optional .CMsgOverworldTokenQuantity token_reward = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_reward_);
    }

    // optional uint32 reward_data = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterTokenTreasureData_RewardOption::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterTokenTreasureData_RewardOption::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterTokenTreasureData_RewardOption::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterTokenTreasureData_RewardOption::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterTokenTreasureData_RewardOption*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterTokenTreasureData_RewardOption&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_cost()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_cost());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_token_reward()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_reward());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.reward_data_ = from._impl_.reward_data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterTokenTreasureData_RewardOption::CopyFrom(const CMsgOverworldEncounterTokenTreasureData_RewardOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterTokenTreasureData.RewardOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterTokenTreasureData_RewardOption::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterTokenTreasureData_RewardOption::InternalSwap(CMsgOverworldEncounterTokenTreasureData_RewardOption* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterTokenTreasureData_RewardOption, _impl_.reward_data_)
      + sizeof(CMsgOverworldEncounterTokenTreasureData_RewardOption::_impl_.reward_data_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterTokenTreasureData_RewardOption, _impl_.token_cost_)>(
          reinterpret_cast<char*>(&_impl_.token_cost_),
          reinterpret_cast<char*>(&other->_impl_.token_cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterTokenTreasureData_RewardOption::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[2]);
}

// ===================================================================

class CMsgOverworldEncounterTokenTreasureData::_Internal {
 public:
};

CMsgOverworldEncounterTokenTreasureData::CMsgOverworldEncounterTokenTreasureData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterTokenTreasureData)
}
CMsgOverworldEncounterTokenTreasureData::CMsgOverworldEncounterTokenTreasureData(const CMsgOverworldEncounterTokenTreasureData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterTokenTreasureData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.reward_options_){from._impl_.reward_options_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterTokenTreasureData)
}

inline void CMsgOverworldEncounterTokenTreasureData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.reward_options_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgOverworldEncounterTokenTreasureData::~CMsgOverworldEncounterTokenTreasureData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterTokenTreasureData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterTokenTreasureData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.reward_options_.~RepeatedPtrField();
}

void CMsgOverworldEncounterTokenTreasureData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterTokenTreasureData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterTokenTreasureData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.reward_options_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterTokenTreasureData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgOverworldEncounterTokenTreasureData.RewardOption reward_options = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_reward_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterTokenTreasureData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterTokenTreasureData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgOverworldEncounterTokenTreasureData.RewardOption reward_options = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_reward_options_size()); i < n; i++) {
    const auto& repfield = this->_internal_reward_options(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterTokenTreasureData)
  return target;
}

size_t CMsgOverworldEncounterTokenTreasureData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterTokenTreasureData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgOverworldEncounterTokenTreasureData.RewardOption reward_options = 1;
  total_size += 1UL * this->_internal_reward_options_size();
  for (const auto& msg : this->_impl_.reward_options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterTokenTreasureData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterTokenTreasureData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterTokenTreasureData::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterTokenTreasureData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterTokenTreasureData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterTokenTreasureData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterTokenTreasureData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.reward_options_.MergeFrom(from._impl_.reward_options_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterTokenTreasureData::CopyFrom(const CMsgOverworldEncounterTokenTreasureData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterTokenTreasureData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterTokenTreasureData::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterTokenTreasureData::InternalSwap(CMsgOverworldEncounterTokenTreasureData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.reward_options_.InternalSwap(&other->_impl_.reward_options_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterTokenTreasureData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[3]);
}

// ===================================================================

class CMsgOverworldEncounterTokenQuestData_Quest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldEncounterTokenQuestData_Quest>()._impl_._has_bits_);
  static void set_has_reward_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgOverworldTokenQuantity& token_cost(const CMsgOverworldEncounterTokenQuestData_Quest* msg);
  static void set_has_token_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgOverworldTokenQuantity& token_reward(const CMsgOverworldEncounterTokenQuestData_Quest* msg);
  static void set_has_token_reward(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgOverworldEncounterTokenQuestData_Quest::_Internal::token_cost(const CMsgOverworldEncounterTokenQuestData_Quest* msg) {
  return *msg->_impl_.token_cost_;
}
const ::CMsgOverworldTokenQuantity&
CMsgOverworldEncounterTokenQuestData_Quest::_Internal::token_reward(const CMsgOverworldEncounterTokenQuestData_Quest* msg) {
  return *msg->_impl_.token_reward_;
}
CMsgOverworldEncounterTokenQuestData_Quest::CMsgOverworldEncounterTokenQuestData_Quest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterTokenQuestData.Quest)
}
CMsgOverworldEncounterTokenQuestData_Quest::CMsgOverworldEncounterTokenQuestData_Quest(const CMsgOverworldEncounterTokenQuestData_Quest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterTokenQuestData_Quest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_cost_){nullptr}
    , decltype(_impl_.token_reward_){nullptr}
    , decltype(_impl_.reward_data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_cost()) {
    _this->_impl_.token_cost_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_cost_);
  }
  if (from._internal_has_token_reward()) {
    _this->_impl_.token_reward_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_reward_);
  }
  _this->_impl_.reward_data_ = from._impl_.reward_data_;
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterTokenQuestData.Quest)
}

inline void CMsgOverworldEncounterTokenQuestData_Quest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_cost_){nullptr}
    , decltype(_impl_.token_reward_){nullptr}
    , decltype(_impl_.reward_data_){0u}
  };
}

CMsgOverworldEncounterTokenQuestData_Quest::~CMsgOverworldEncounterTokenQuestData_Quest() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterTokenQuestData.Quest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterTokenQuestData_Quest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_cost_;
  if (this != internal_default_instance()) delete _impl_.token_reward_;
}

void CMsgOverworldEncounterTokenQuestData_Quest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterTokenQuestData_Quest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterTokenQuestData.Quest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.token_cost_ != nullptr);
      _impl_.token_cost_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.token_reward_ != nullptr);
      _impl_.token_reward_->Clear();
    }
  }
  _impl_.reward_data_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterTokenQuestData_Quest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 reward_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reward_data(&has_bits);
          _impl_.reward_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_reward = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_reward(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterTokenQuestData_Quest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterTokenQuestData.Quest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 reward_data = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_reward_data(), target);
  }

  // optional .CMsgOverworldTokenQuantity token_cost = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::token_cost(this),
        _Internal::token_cost(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgOverworldTokenQuantity token_reward = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::token_reward(this),
        _Internal::token_reward(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterTokenQuestData.Quest)
  return target;
}

size_t CMsgOverworldEncounterTokenQuestData_Quest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterTokenQuestData.Quest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgOverworldTokenQuantity token_cost = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_cost_);
    }

    // optional .CMsgOverworldTokenQuantity token_reward = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_reward_);
    }

    // optional uint32 reward_data = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward_data());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterTokenQuestData_Quest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterTokenQuestData_Quest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterTokenQuestData_Quest::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterTokenQuestData_Quest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterTokenQuestData_Quest*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterTokenQuestData_Quest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterTokenQuestData.Quest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_cost()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_cost());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_token_reward()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_reward());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.reward_data_ = from._impl_.reward_data_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterTokenQuestData_Quest::CopyFrom(const CMsgOverworldEncounterTokenQuestData_Quest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterTokenQuestData.Quest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterTokenQuestData_Quest::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterTokenQuestData_Quest::InternalSwap(CMsgOverworldEncounterTokenQuestData_Quest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterTokenQuestData_Quest, _impl_.reward_data_)
      + sizeof(CMsgOverworldEncounterTokenQuestData_Quest::_impl_.reward_data_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterTokenQuestData_Quest, _impl_.token_cost_)>(
          reinterpret_cast<char*>(&_impl_.token_cost_),
          reinterpret_cast<char*>(&other->_impl_.token_cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterTokenQuestData_Quest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[4]);
}

// ===================================================================

class CMsgOverworldEncounterTokenQuestData::_Internal {
 public:
};

CMsgOverworldEncounterTokenQuestData::CMsgOverworldEncounterTokenQuestData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterTokenQuestData)
}
CMsgOverworldEncounterTokenQuestData::CMsgOverworldEncounterTokenQuestData(const CMsgOverworldEncounterTokenQuestData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterTokenQuestData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.quests_){from._impl_.quests_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterTokenQuestData)
}

inline void CMsgOverworldEncounterTokenQuestData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.quests_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgOverworldEncounterTokenQuestData::~CMsgOverworldEncounterTokenQuestData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterTokenQuestData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterTokenQuestData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.quests_.~RepeatedPtrField();
}

void CMsgOverworldEncounterTokenQuestData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterTokenQuestData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterTokenQuestData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.quests_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterTokenQuestData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgOverworldEncounterTokenQuestData.Quest quests = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_quests(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterTokenQuestData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterTokenQuestData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgOverworldEncounterTokenQuestData.Quest quests = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_quests_size()); i < n; i++) {
    const auto& repfield = this->_internal_quests(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterTokenQuestData)
  return target;
}

size_t CMsgOverworldEncounterTokenQuestData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterTokenQuestData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgOverworldEncounterTokenQuestData.Quest quests = 1;
  total_size += 1UL * this->_internal_quests_size();
  for (const auto& msg : this->_impl_.quests_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterTokenQuestData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterTokenQuestData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterTokenQuestData::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterTokenQuestData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterTokenQuestData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterTokenQuestData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterTokenQuestData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.quests_.MergeFrom(from._impl_.quests_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterTokenQuestData::CopyFrom(const CMsgOverworldEncounterTokenQuestData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterTokenQuestData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterTokenQuestData::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterTokenQuestData::InternalSwap(CMsgOverworldEncounterTokenQuestData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.quests_.InternalSwap(&other->_impl_.quests_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterTokenQuestData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[5]);
}

// ===================================================================

class CMsgOverworldHeroList::_Internal {
 public:
};

CMsgOverworldHeroList::CMsgOverworldHeroList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldHeroList)
}
CMsgOverworldHeroList::CMsgOverworldHeroList(const CMsgOverworldHeroList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldHeroList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hero_ids_){from._impl_.hero_ids_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldHeroList)
}

inline void CMsgOverworldHeroList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hero_ids_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgOverworldHeroList::~CMsgOverworldHeroList() {
  // @@protoc_insertion_point(destructor:CMsgOverworldHeroList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldHeroList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hero_ids_.~RepeatedField();
}

void CMsgOverworldHeroList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldHeroList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldHeroList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hero_ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldHeroList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 hero_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_hero_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_hero_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldHeroList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldHeroList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 hero_ids = 1;
  for (int i = 0, n = this->_internal_hero_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_hero_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldHeroList)
  return target;
}

size_t CMsgOverworldHeroList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldHeroList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 hero_ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.hero_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_hero_ids_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldHeroList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldHeroList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldHeroList::GetClassData() const { return &_class_data_; }


void CMsgOverworldHeroList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldHeroList*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldHeroList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldHeroList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hero_ids_.MergeFrom(from._impl_.hero_ids_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldHeroList::CopyFrom(const CMsgOverworldHeroList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldHeroList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldHeroList::IsInitialized() const {
  return true;
}

void CMsgOverworldHeroList::InternalSwap(CMsgOverworldHeroList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hero_ids_.InternalSwap(&other->_impl_.hero_ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldHeroList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[6]);
}

// ===================================================================

class CMsgOverworldEncounterChooseHeroData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldEncounterChooseHeroData>()._impl_._has_bits_);
  static const ::CMsgOverworldHeroList& hero_list(const CMsgOverworldEncounterChooseHeroData* msg);
  static void set_has_hero_list(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_additive(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgOverworldHeroList&
CMsgOverworldEncounterChooseHeroData::_Internal::hero_list(const CMsgOverworldEncounterChooseHeroData* msg) {
  return *msg->_impl_.hero_list_;
}
CMsgOverworldEncounterChooseHeroData::CMsgOverworldEncounterChooseHeroData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterChooseHeroData)
}
CMsgOverworldEncounterChooseHeroData::CMsgOverworldEncounterChooseHeroData(const CMsgOverworldEncounterChooseHeroData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterChooseHeroData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_list_){nullptr}
    , decltype(_impl_.additive_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hero_list()) {
    _this->_impl_.hero_list_ = new ::CMsgOverworldHeroList(*from._impl_.hero_list_);
  }
  _this->_impl_.additive_ = from._impl_.additive_;
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterChooseHeroData)
}

inline void CMsgOverworldEncounterChooseHeroData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.hero_list_){nullptr}
    , decltype(_impl_.additive_){false}
  };
}

CMsgOverworldEncounterChooseHeroData::~CMsgOverworldEncounterChooseHeroData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterChooseHeroData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterChooseHeroData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.hero_list_;
}

void CMsgOverworldEncounterChooseHeroData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterChooseHeroData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterChooseHeroData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.hero_list_ != nullptr);
    _impl_.hero_list_->Clear();
  }
  _impl_.additive_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterChooseHeroData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgOverworldHeroList hero_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_hero_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool additive = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_additive(&has_bits);
          _impl_.additive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterChooseHeroData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterChooseHeroData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgOverworldHeroList hero_list = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::hero_list(this),
        _Internal::hero_list(this).GetCachedSize(), target, stream);
  }

  // optional bool additive = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_additive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterChooseHeroData)
  return target;
}

size_t CMsgOverworldEncounterChooseHeroData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterChooseHeroData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldHeroList hero_list = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.hero_list_);
    }

    // optional bool additive = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterChooseHeroData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterChooseHeroData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterChooseHeroData::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterChooseHeroData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterChooseHeroData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterChooseHeroData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterChooseHeroData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_hero_list()->::CMsgOverworldHeroList::MergeFrom(
          from._internal_hero_list());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.additive_ = from._impl_.additive_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterChooseHeroData::CopyFrom(const CMsgOverworldEncounterChooseHeroData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterChooseHeroData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterChooseHeroData::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterChooseHeroData::InternalSwap(CMsgOverworldEncounterChooseHeroData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterChooseHeroData, _impl_.additive_)
      + sizeof(CMsgOverworldEncounterChooseHeroData::_impl_.additive_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterChooseHeroData, _impl_.hero_list_)>(
          reinterpret_cast<char*>(&_impl_.hero_list_),
          reinterpret_cast<char*>(&other->_impl_.hero_list_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterChooseHeroData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[7]);
}

// ===================================================================

class CMsgOverworldEncounterProgressData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldEncounterProgressData>()._impl_._has_bits_);
  static void set_has_choice(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_visited(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgOverworldEncounterProgressData::CMsgOverworldEncounterProgressData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterProgressData)
}
CMsgOverworldEncounterProgressData::CMsgOverworldEncounterProgressData(const CMsgOverworldEncounterProgressData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterProgressData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choice_){}
    , decltype(_impl_.progress_){}
    , decltype(_impl_.max_progress_){}
    , decltype(_impl_.visited_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.choice_, &from._impl_.choice_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.visited_) -
    reinterpret_cast<char*>(&_impl_.choice_)) + sizeof(_impl_.visited_));
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterProgressData)
}

inline void CMsgOverworldEncounterProgressData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.choice_){0}
    , decltype(_impl_.progress_){0}
    , decltype(_impl_.max_progress_){0}
    , decltype(_impl_.visited_){false}
  };
}

CMsgOverworldEncounterProgressData::~CMsgOverworldEncounterProgressData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterProgressData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterProgressData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgOverworldEncounterProgressData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterProgressData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterProgressData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.choice_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.visited_) -
        reinterpret_cast<char*>(&_impl_.choice_)) + sizeof(_impl_.visited_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterProgressData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 choice = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_choice(&has_bits);
          _impl_.choice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 progress = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_progress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_progress(&has_bits);
          _impl_.max_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool visited = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_visited(&has_bits);
          _impl_.visited_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterProgressData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterProgressData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 choice = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_choice(), target);
  }

  // optional int32 progress = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_progress(), target);
  }

  // optional int32 max_progress = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_progress(), target);
  }

  // optional bool visited = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_visited(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterProgressData)
  return target;
}

size_t CMsgOverworldEncounterProgressData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterProgressData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 choice = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_choice());
    }

    // optional int32 progress = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_progress());
    }

    // optional int32 max_progress = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_progress());
    }

    // optional bool visited = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterProgressData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterProgressData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterProgressData::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterProgressData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterProgressData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterProgressData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterProgressData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.choice_ = from._impl_.choice_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.progress_ = from._impl_.progress_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.max_progress_ = from._impl_.max_progress_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.visited_ = from._impl_.visited_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterProgressData::CopyFrom(const CMsgOverworldEncounterProgressData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterProgressData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterProgressData::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterProgressData::InternalSwap(CMsgOverworldEncounterProgressData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterProgressData, _impl_.visited_)
      + sizeof(CMsgOverworldEncounterProgressData::_impl_.visited_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterProgressData, _impl_.choice_)>(
          reinterpret_cast<char*>(&_impl_.choice_),
          reinterpret_cast<char*>(&other->_impl_.choice_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterProgressData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[8]);
}

// ===================================================================

class CMsgOverworldEncounterData::_Internal {
 public:
};

void CMsgOverworldEncounterData::clear_extra_encounter_data() {
  _impl_.extra_encounter_data_.Clear();
}
CMsgOverworldEncounterData::CMsgOverworldEncounterData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterData)
}
CMsgOverworldEncounterData::CMsgOverworldEncounterData(const CMsgOverworldEncounterData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.extra_encounter_data_){from._impl_.extra_encounter_data_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterData)
}

inline void CMsgOverworldEncounterData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.extra_encounter_data_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgOverworldEncounterData::~CMsgOverworldEncounterData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.extra_encounter_data_.~RepeatedPtrField();
}

void CMsgOverworldEncounterData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extra_encounter_data_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CExtraMsgBlock extra_encounter_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extra_encounter_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CExtraMsgBlock extra_encounter_data = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extra_encounter_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_extra_encounter_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterData)
  return target;
}

size_t CMsgOverworldEncounterData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CExtraMsgBlock extra_encounter_data = 1;
  total_size += 1UL * this->_internal_extra_encounter_data_size();
  for (const auto& msg : this->_impl_.extra_encounter_data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterData::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extra_encounter_data_.MergeFrom(from._impl_.extra_encounter_data_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterData::CopyFrom(const CMsgOverworldEncounterData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterData::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterData::InternalSwap(CMsgOverworldEncounterData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.extra_encounter_data_.InternalSwap(&other->_impl_.extra_encounter_data_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[9]);
}

// ===================================================================

class CMsgOverworldNode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldNode>()._impl_._has_bits_);
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_node_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgOverworldEncounterData& node_encounter_data(const CMsgOverworldNode* msg);
  static void set_has_node_encounter_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldEncounterData&
CMsgOverworldNode::_Internal::node_encounter_data(const CMsgOverworldNode* msg) {
  return *msg->_impl_.node_encounter_data_;
}
CMsgOverworldNode::CMsgOverworldNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldNode)
}
CMsgOverworldNode::CMsgOverworldNode(const CMsgOverworldNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_encounter_data_){nullptr}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.node_state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_node_encounter_data()) {
    _this->_impl_.node_encounter_data_ = new ::CMsgOverworldEncounterData(*from._impl_.node_encounter_data_);
  }
  ::memcpy(&_impl_.node_id_, &from._impl_.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_state_) -
    reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_state_));
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldNode)
}

inline void CMsgOverworldNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.node_encounter_data_){nullptr}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.node_state_){0}
  };
}

CMsgOverworldNode::~CMsgOverworldNode() {
  // @@protoc_insertion_point(destructor:CMsgOverworldNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.node_encounter_data_;
}

void CMsgOverworldNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.node_encounter_data_ != nullptr);
    _impl_.node_encounter_data_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_state_) -
        reinterpret_cast<char*>(&_impl_.node_id_)) + sizeof(_impl_.node_state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 node_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EOverworldNodeState node_state = 2 [default = k_eOverworldNodeState_Invalid];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EOverworldNodeState_IsValid(val))) {
            _internal_set_node_state(static_cast<::EOverworldNodeState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldEncounterData node_encounter_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_node_encounter_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 node_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_node_id(), target);
  }

  // optional .EOverworldNodeState node_state = 2 [default = k_eOverworldNodeState_Invalid];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_node_state(), target);
  }

  // optional .CMsgOverworldEncounterData node_encounter_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::node_encounter_data(this),
        _Internal::node_encounter_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldNode)
  return target;
}

size_t CMsgOverworldNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgOverworldEncounterData node_encounter_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.node_encounter_data_);
    }

    // optional uint32 node_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional .EOverworldNodeState node_state = 2 [default = k_eOverworldNodeState_Invalid];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_node_state());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldNode::GetClassData() const { return &_class_data_; }


void CMsgOverworldNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldNode*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_node_encounter_data()->::CMsgOverworldEncounterData::MergeFrom(
          from._internal_node_encounter_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.node_state_ = from._impl_.node_state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldNode::CopyFrom(const CMsgOverworldNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldNode::IsInitialized() const {
  return true;
}

void CMsgOverworldNode::InternalSwap(CMsgOverworldNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldNode, _impl_.node_state_)
      + sizeof(CMsgOverworldNode::_impl_.node_state_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldNode, _impl_.node_encounter_data_)>(
          reinterpret_cast<char*>(&_impl_.node_encounter_data_),
          reinterpret_cast<char*>(&other->_impl_.node_encounter_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[10]);
}

// ===================================================================

class CMsgOverworldPath::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldPath>()._impl_._has_bits_);
  static void set_has_path_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldTokenQuantity& path_cost(const CMsgOverworldPath* msg);
  static void set_has_path_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgOverworldPath::_Internal::path_cost(const CMsgOverworldPath* msg) {
  return *msg->_impl_.path_cost_;
}
CMsgOverworldPath::CMsgOverworldPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldPath)
}
CMsgOverworldPath::CMsgOverworldPath(const CMsgOverworldPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_cost_){nullptr}
    , decltype(_impl_.path_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_path_cost()) {
    _this->_impl_.path_cost_ = new ::CMsgOverworldTokenQuantity(*from._impl_.path_cost_);
  }
  _this->_impl_.path_id_ = from._impl_.path_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldPath)
}

inline void CMsgOverworldPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_cost_){nullptr}
    , decltype(_impl_.path_id_){0u}
  };
}

CMsgOverworldPath::~CMsgOverworldPath() {
  // @@protoc_insertion_point(destructor:CMsgOverworldPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.path_cost_;
}

void CMsgOverworldPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldPath::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.path_cost_ != nullptr);
    _impl_.path_cost_->Clear();
  }
  _impl_.path_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 path_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_path_id(&has_bits);
          _impl_.path_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity path_cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_path_cost(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 path_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_path_id(), target);
  }

  // optional .CMsgOverworldTokenQuantity path_cost = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::path_cost(this),
        _Internal::path_cost(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldPath)
  return target;
}

size_t CMsgOverworldPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldTokenQuantity path_cost = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.path_cost_);
    }

    // optional uint32 path_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_path_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldPath::GetClassData() const { return &_class_data_; }


void CMsgOverworldPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldPath*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_path_cost()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_path_cost());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.path_id_ = from._impl_.path_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldPath::CopyFrom(const CMsgOverworldPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldPath::IsInitialized() const {
  return true;
}

void CMsgOverworldPath::InternalSwap(CMsgOverworldPath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldPath, _impl_.path_id_)
      + sizeof(CMsgOverworldPath::_impl_.path_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldPath, _impl_.path_cost_)>(
          reinterpret_cast<char*>(&_impl_.path_cost_),
          reinterpret_cast<char*>(&other->_impl_.path_cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[11]);
}

// ===================================================================

class CMsgOverworldUserData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldUserData>()._impl_._has_bits_);
  static const ::CMsgOverworldTokenQuantity& token_inventory(const CMsgOverworldUserData* msg);
  static void set_has_token_inventory(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgOverworldUserData::_Internal::token_inventory(const CMsgOverworldUserData* msg) {
  return *msg->_impl_.token_inventory_;
}
CMsgOverworldUserData::CMsgOverworldUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldUserData)
}
CMsgOverworldUserData::CMsgOverworldUserData(const CMsgOverworldUserData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldUserData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_nodes_){from._impl_.overworld_nodes_}
    , decltype(_impl_.overworld_paths_){from._impl_.overworld_paths_}
    , decltype(_impl_.token_inventory_){nullptr}
    , decltype(_impl_.current_node_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_inventory()) {
    _this->_impl_.token_inventory_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_inventory_);
  }
  _this->_impl_.current_node_id_ = from._impl_.current_node_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldUserData)
}

inline void CMsgOverworldUserData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_nodes_){arena}
    , decltype(_impl_.overworld_paths_){arena}
    , decltype(_impl_.token_inventory_){nullptr}
    , decltype(_impl_.current_node_id_){0u}
  };
}

CMsgOverworldUserData::~CMsgOverworldUserData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldUserData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldUserData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.overworld_nodes_.~RepeatedPtrField();
  _impl_.overworld_paths_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.token_inventory_;
}

void CMsgOverworldUserData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldUserData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldUserData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.overworld_nodes_.Clear();
  _impl_.overworld_paths_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.token_inventory_ != nullptr);
    _impl_.token_inventory_->Clear();
  }
  _impl_.current_node_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldUserData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgOverworldTokenQuantity token_inventory = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_inventory(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgOverworldNode overworld_nodes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_overworld_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgOverworldPath overworld_paths = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_overworld_paths(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_node_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_current_node_id(&has_bits);
          _impl_.current_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldUserData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldUserData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgOverworldTokenQuantity token_inventory = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::token_inventory(this),
        _Internal::token_inventory(this).GetCachedSize(), target, stream);
  }

  // repeated .CMsgOverworldNode overworld_nodes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_overworld_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_overworld_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .CMsgOverworldPath overworld_paths = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_overworld_paths_size()); i < n; i++) {
    const auto& repfield = this->_internal_overworld_paths(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 current_node_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_current_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldUserData)
  return target;
}

size_t CMsgOverworldUserData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldUserData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgOverworldNode overworld_nodes = 2;
  total_size += 1UL * this->_internal_overworld_nodes_size();
  for (const auto& msg : this->_impl_.overworld_nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgOverworldPath overworld_paths = 3;
  total_size += 1UL * this->_internal_overworld_paths_size();
  for (const auto& msg : this->_impl_.overworld_paths_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldTokenQuantity token_inventory = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_inventory_);
    }

    // optional uint32 current_node_id = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_current_node_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldUserData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldUserData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldUserData::GetClassData() const { return &_class_data_; }


void CMsgOverworldUserData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldUserData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldUserData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldUserData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.overworld_nodes_.MergeFrom(from._impl_.overworld_nodes_);
  _this->_impl_.overworld_paths_.MergeFrom(from._impl_.overworld_paths_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_inventory()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_inventory());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.current_node_id_ = from._impl_.current_node_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldUserData::CopyFrom(const CMsgOverworldUserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldUserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldUserData::IsInitialized() const {
  return true;
}

void CMsgOverworldUserData::InternalSwap(CMsgOverworldUserData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.overworld_nodes_.InternalSwap(&other->_impl_.overworld_nodes_);
  _impl_.overworld_paths_.InternalSwap(&other->_impl_.overworld_paths_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldUserData, _impl_.current_node_id_)
      + sizeof(CMsgOverworldUserData::_impl_.current_node_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldUserData, _impl_.token_inventory_)>(
          reinterpret_cast<char*>(&_impl_.token_inventory_),
          reinterpret_cast<char*>(&other->_impl_.token_inventory_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldUserData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[12]);
}

// ===================================================================

class CMsgOverworldMatchRewards_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldMatchRewards_Player>()._impl_._has_bits_);
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldTokenQuantity& tokens(const CMsgOverworldMatchRewards_Player* msg);
  static void set_has_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgOverworldMatchRewards_Player::_Internal::tokens(const CMsgOverworldMatchRewards_Player* msg) {
  return *msg->_impl_.tokens_;
}
CMsgOverworldMatchRewards_Player::CMsgOverworldMatchRewards_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldMatchRewards.Player)
}
CMsgOverworldMatchRewards_Player::CMsgOverworldMatchRewards_Player(const CMsgOverworldMatchRewards_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldMatchRewards_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_){nullptr}
    , decltype(_impl_.player_slot_){}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tokens()) {
    _this->_impl_.tokens_ = new ::CMsgOverworldTokenQuantity(*from._impl_.tokens_);
  }
  ::memcpy(&_impl_.player_slot_, &from._impl_.player_slot_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.overworld_id_) -
    reinterpret_cast<char*>(&_impl_.player_slot_)) + sizeof(_impl_.overworld_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldMatchRewards.Player)
}

inline void CMsgOverworldMatchRewards_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_){nullptr}
    , decltype(_impl_.player_slot_){0u}
    , decltype(_impl_.overworld_id_){0u}
  };
}

CMsgOverworldMatchRewards_Player::~CMsgOverworldMatchRewards_Player() {
  // @@protoc_insertion_point(destructor:CMsgOverworldMatchRewards.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldMatchRewards_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tokens_;
}

void CMsgOverworldMatchRewards_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldMatchRewards_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldMatchRewards.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tokens_ != nullptr);
    _impl_.tokens_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.player_slot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.overworld_id_) -
        reinterpret_cast<char*>(&_impl_.player_slot_)) + sizeof(_impl_.overworld_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldMatchRewards_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 player_slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity tokens = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokens(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 overworld_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldMatchRewards_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldMatchRewards.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 player_slot = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_player_slot(), target);
  }

  // optional .CMsgOverworldTokenQuantity tokens = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tokens(this),
        _Internal::tokens(this).GetCachedSize(), target, stream);
  }

  // optional uint32 overworld_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_overworld_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldMatchRewards.Player)
  return target;
}

size_t CMsgOverworldMatchRewards_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldMatchRewards.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgOverworldTokenQuantity tokens = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tokens_);
    }

    // optional uint32 player_slot = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_player_slot());
    }

    // optional uint32 overworld_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldMatchRewards_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldMatchRewards_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldMatchRewards_Player::GetClassData() const { return &_class_data_; }


void CMsgOverworldMatchRewards_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldMatchRewards_Player*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldMatchRewards_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldMatchRewards.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tokens()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_tokens());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldMatchRewards_Player::CopyFrom(const CMsgOverworldMatchRewards_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldMatchRewards.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldMatchRewards_Player::IsInitialized() const {
  return true;
}

void CMsgOverworldMatchRewards_Player::InternalSwap(CMsgOverworldMatchRewards_Player* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldMatchRewards_Player, _impl_.overworld_id_)
      + sizeof(CMsgOverworldMatchRewards_Player::_impl_.overworld_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldMatchRewards_Player, _impl_.tokens_)>(
          reinterpret_cast<char*>(&_impl_.tokens_),
          reinterpret_cast<char*>(&other->_impl_.tokens_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldMatchRewards_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[13]);
}

// ===================================================================

class CMsgOverworldMatchRewards::_Internal {
 public:
};

CMsgOverworldMatchRewards::CMsgOverworldMatchRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldMatchRewards)
}
CMsgOverworldMatchRewards::CMsgOverworldMatchRewards(const CMsgOverworldMatchRewards& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldMatchRewards* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){from._impl_.players_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldMatchRewards)
}

inline void CMsgOverworldMatchRewards::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.players_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CMsgOverworldMatchRewards::~CMsgOverworldMatchRewards() {
  // @@protoc_insertion_point(destructor:CMsgOverworldMatchRewards)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldMatchRewards::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.players_.~RepeatedPtrField();
}

void CMsgOverworldMatchRewards::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldMatchRewards::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldMatchRewards)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.players_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldMatchRewards::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgOverworldMatchRewards.Player players = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldMatchRewards::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldMatchRewards)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgOverworldMatchRewards.Player players = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldMatchRewards)
  return target;
}

size_t CMsgOverworldMatchRewards::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldMatchRewards)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgOverworldMatchRewards.Player players = 1;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldMatchRewards::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldMatchRewards::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldMatchRewards::GetClassData() const { return &_class_data_; }


void CMsgOverworldMatchRewards::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldMatchRewards*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldMatchRewards&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldMatchRewards)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldMatchRewards::CopyFrom(const CMsgOverworldMatchRewards& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldMatchRewards)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldMatchRewards::IsInitialized() const {
  return true;
}

void CMsgOverworldMatchRewards::InternalSwap(CMsgOverworldMatchRewards* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldMatchRewards::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[14]);
}

// ===================================================================

class CMsgClientToGCOverworldGetUserData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGetUserData>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldGetUserData::CMsgClientToGCOverworldGetUserData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGetUserData)
}
CMsgClientToGCOverworldGetUserData::CMsgClientToGCOverworldGetUserData(const CMsgClientToGCOverworldGetUserData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGetUserData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGetUserData)
}

inline void CMsgClientToGCOverworldGetUserData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
  };
}

CMsgClientToGCOverworldGetUserData::~CMsgClientToGCOverworldGetUserData() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGetUserData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGetUserData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldGetUserData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGetUserData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGetUserData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGetUserData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGetUserData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGetUserData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGetUserData)
  return target;
}

size_t CMsgClientToGCOverworldGetUserData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGetUserData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 overworld_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGetUserData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGetUserData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGetUserData::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGetUserData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGetUserData*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGetUserData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGetUserData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_overworld_id()) {
    _this->_internal_set_overworld_id(from._internal_overworld_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGetUserData::CopyFrom(const CMsgClientToGCOverworldGetUserData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGetUserData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGetUserData::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGetUserData::InternalSwap(CMsgClientToGCOverworldGetUserData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.overworld_id_, other->_impl_.overworld_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGetUserData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[15]);
}

// ===================================================================

class CMsgClientToGCOverworldGetUserDataResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGetUserDataResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldUserData& user_data(const CMsgClientToGCOverworldGetUserDataResponse* msg);
  static void set_has_user_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldUserData&
CMsgClientToGCOverworldGetUserDataResponse::_Internal::user_data(const CMsgClientToGCOverworldGetUserDataResponse* msg) {
  return *msg->_impl_.user_data_;
}
CMsgClientToGCOverworldGetUserDataResponse::CMsgClientToGCOverworldGetUserDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGetUserDataResponse)
}
CMsgClientToGCOverworldGetUserDataResponse::CMsgClientToGCOverworldGetUserDataResponse(const CMsgClientToGCOverworldGetUserDataResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGetUserDataResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_data_){nullptr}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user_data()) {
    _this->_impl_.user_data_ = new ::CMsgOverworldUserData(*from._impl_.user_data_);
  }
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGetUserDataResponse)
}

inline void CMsgClientToGCOverworldGetUserDataResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_data_){nullptr}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldGetUserDataResponse::~CMsgClientToGCOverworldGetUserDataResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGetUserDataResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGetUserDataResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.user_data_;
}

void CMsgClientToGCOverworldGetUserDataResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGetUserDataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGetUserDataResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.user_data_ != nullptr);
    _impl_.user_data_->Clear();
  }
  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGetUserDataResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldGetUserDataResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldGetUserDataResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldGetUserDataResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldUserData user_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGetUserDataResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGetUserDataResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldGetUserDataResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  // optional .CMsgOverworldUserData user_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::user_data(this),
        _Internal::user_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGetUserDataResponse)
  return target;
}

size_t CMsgClientToGCOverworldGetUserDataResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGetUserDataResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldUserData user_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_data_);
    }

    // optional .CMsgClientToGCOverworldGetUserDataResponse.EResponse response = 1 [default = k_eInternalError];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGetUserDataResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGetUserDataResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGetUserDataResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGetUserDataResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGetUserDataResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGetUserDataResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGetUserDataResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_user_data()->::CMsgOverworldUserData::MergeFrom(
          from._internal_user_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGetUserDataResponse::CopyFrom(const CMsgClientToGCOverworldGetUserDataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGetUserDataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGetUserDataResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGetUserDataResponse::InternalSwap(CMsgClientToGCOverworldGetUserDataResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGetUserDataResponse, _impl_.response_)
      + sizeof(CMsgClientToGCOverworldGetUserDataResponse::_impl_.response_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGetUserDataResponse, _impl_.user_data_)>(
          reinterpret_cast<char*>(&_impl_.user_data_),
          reinterpret_cast<char*>(&other->_impl_.user_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGetUserDataResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[16]);
}

// ===================================================================

class CMsgGCToClientOverworldUserDataUpdated::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGCToClientOverworldUserDataUpdated>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldUserData& user_data(const CMsgGCToClientOverworldUserDataUpdated* msg);
  static void set_has_user_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldUserData&
CMsgGCToClientOverworldUserDataUpdated::_Internal::user_data(const CMsgGCToClientOverworldUserDataUpdated* msg) {
  return *msg->_impl_.user_data_;
}
CMsgGCToClientOverworldUserDataUpdated::CMsgGCToClientOverworldUserDataUpdated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgGCToClientOverworldUserDataUpdated)
}
CMsgGCToClientOverworldUserDataUpdated::CMsgGCToClientOverworldUserDataUpdated(const CMsgGCToClientOverworldUserDataUpdated& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgGCToClientOverworldUserDataUpdated* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_data_){nullptr}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_user_data()) {
    _this->_impl_.user_data_ = new ::CMsgOverworldUserData(*from._impl_.user_data_);
  }
  _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgGCToClientOverworldUserDataUpdated)
}

inline void CMsgGCToClientOverworldUserDataUpdated::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.user_data_){nullptr}
    , decltype(_impl_.overworld_id_){0u}
  };
}

CMsgGCToClientOverworldUserDataUpdated::~CMsgGCToClientOverworldUserDataUpdated() {
  // @@protoc_insertion_point(destructor:CMsgGCToClientOverworldUserDataUpdated)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgGCToClientOverworldUserDataUpdated::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.user_data_;
}

void CMsgGCToClientOverworldUserDataUpdated::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgGCToClientOverworldUserDataUpdated::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGCToClientOverworldUserDataUpdated)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.user_data_ != nullptr);
    _impl_.user_data_->Clear();
  }
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGCToClientOverworldUserDataUpdated::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldUserData user_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGCToClientOverworldUserDataUpdated::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGCToClientOverworldUserDataUpdated)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional .CMsgOverworldUserData user_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::user_data(this),
        _Internal::user_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGCToClientOverworldUserDataUpdated)
  return target;
}

size_t CMsgGCToClientOverworldUserDataUpdated::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGCToClientOverworldUserDataUpdated)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldUserData user_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.user_data_);
    }

    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGCToClientOverworldUserDataUpdated::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgGCToClientOverworldUserDataUpdated::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGCToClientOverworldUserDataUpdated::GetClassData() const { return &_class_data_; }


void CMsgGCToClientOverworldUserDataUpdated::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgGCToClientOverworldUserDataUpdated*>(&to_msg);
  auto& from = static_cast<const CMsgGCToClientOverworldUserDataUpdated&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgGCToClientOverworldUserDataUpdated)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_user_data()->::CMsgOverworldUserData::MergeFrom(
          from._internal_user_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGCToClientOverworldUserDataUpdated::CopyFrom(const CMsgGCToClientOverworldUserDataUpdated& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGCToClientOverworldUserDataUpdated)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGCToClientOverworldUserDataUpdated::IsInitialized() const {
  return true;
}

void CMsgGCToClientOverworldUserDataUpdated::InternalSwap(CMsgGCToClientOverworldUserDataUpdated* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgGCToClientOverworldUserDataUpdated, _impl_.overworld_id_)
      + sizeof(CMsgGCToClientOverworldUserDataUpdated::_impl_.overworld_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgGCToClientOverworldUserDataUpdated, _impl_.user_data_)>(
          reinterpret_cast<char*>(&_impl_.user_data_),
          reinterpret_cast<char*>(&other->_impl_.user_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGCToClientOverworldUserDataUpdated::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[17]);
}

// ===================================================================

class CMsgClientToGCOverworldCompletePath::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldCompletePath>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_path_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgClientToGCOverworldCompletePath::CMsgClientToGCOverworldCompletePath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldCompletePath)
}
CMsgClientToGCOverworldCompletePath::CMsgClientToGCOverworldCompletePath(const CMsgClientToGCOverworldCompletePath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldCompletePath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.path_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.path_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.path_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldCompletePath)
}

inline void CMsgClientToGCOverworldCompletePath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.path_id_){0u}
  };
}

CMsgClientToGCOverworldCompletePath::~CMsgClientToGCOverworldCompletePath() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldCompletePath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldCompletePath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldCompletePath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldCompletePath::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldCompletePath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.path_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.path_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldCompletePath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 path_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_path_id(&has_bits);
          _impl_.path_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldCompletePath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldCompletePath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional uint32 path_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_path_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldCompletePath)
  return target;
}

size_t CMsgClientToGCOverworldCompletePath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldCompletePath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 path_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_path_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldCompletePath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldCompletePath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldCompletePath::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldCompletePath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldCompletePath*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldCompletePath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldCompletePath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.path_id_ = from._impl_.path_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldCompletePath::CopyFrom(const CMsgClientToGCOverworldCompletePath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldCompletePath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldCompletePath::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldCompletePath::InternalSwap(CMsgClientToGCOverworldCompletePath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldCompletePath, _impl_.path_id_)
      + sizeof(CMsgClientToGCOverworldCompletePath::_impl_.path_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldCompletePath, _impl_.overworld_id_)>(
          reinterpret_cast<char*>(&_impl_.overworld_id_),
          reinterpret_cast<char*>(&other->_impl_.overworld_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldCompletePath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[18]);
}

// ===================================================================

class CMsgClientToGCOverworldCompletePathResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldCompletePathResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgDOTAClaimEventActionResponse& claim_response(const CMsgClientToGCOverworldCompletePathResponse* msg);
  static void set_has_claim_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgDOTAClaimEventActionResponse&
CMsgClientToGCOverworldCompletePathResponse::_Internal::claim_response(const CMsgClientToGCOverworldCompletePathResponse* msg) {
  return *msg->_impl_.claim_response_;
}
void CMsgClientToGCOverworldCompletePathResponse::clear_claim_response() {
  if (_impl_.claim_response_ != nullptr) _impl_.claim_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgClientToGCOverworldCompletePathResponse::CMsgClientToGCOverworldCompletePathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldCompletePathResponse)
}
CMsgClientToGCOverworldCompletePathResponse::CMsgClientToGCOverworldCompletePathResponse(const CMsgClientToGCOverworldCompletePathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldCompletePathResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claim_response_){nullptr}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_claim_response()) {
    _this->_impl_.claim_response_ = new ::CMsgDOTAClaimEventActionResponse(*from._impl_.claim_response_);
  }
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldCompletePathResponse)
}

inline void CMsgClientToGCOverworldCompletePathResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claim_response_){nullptr}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldCompletePathResponse::~CMsgClientToGCOverworldCompletePathResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldCompletePathResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldCompletePathResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.claim_response_;
}

void CMsgClientToGCOverworldCompletePathResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldCompletePathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldCompletePathResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.claim_response_ != nullptr);
    _impl_.claim_response_->Clear();
  }
  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldCompletePathResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldCompletePathResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldCompletePathResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldCompletePathResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_claim_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldCompletePathResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldCompletePathResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldCompletePathResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::claim_response(this),
        _Internal::claim_response(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldCompletePathResponse)
  return target;
}

size_t CMsgClientToGCOverworldCompletePathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldCompletePathResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.claim_response_);
    }

    // optional .CMsgClientToGCOverworldCompletePathResponse.EResponse response = 1 [default = k_eInternalError];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldCompletePathResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldCompletePathResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldCompletePathResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldCompletePathResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldCompletePathResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldCompletePathResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldCompletePathResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_claim_response()->::CMsgDOTAClaimEventActionResponse::MergeFrom(
          from._internal_claim_response());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldCompletePathResponse::CopyFrom(const CMsgClientToGCOverworldCompletePathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldCompletePathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldCompletePathResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldCompletePathResponse::InternalSwap(CMsgClientToGCOverworldCompletePathResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldCompletePathResponse, _impl_.response_)
      + sizeof(CMsgClientToGCOverworldCompletePathResponse::_impl_.response_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldCompletePathResponse, _impl_.claim_response_)>(
          reinterpret_cast<char*>(&_impl_.claim_response_),
          reinterpret_cast<char*>(&other->_impl_.claim_response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldCompletePathResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[19]);
}

// ===================================================================

class CMsgOverworldEncounterPitFighterRewardData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgOverworldEncounterPitFighterRewardData>()._impl_._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_choice(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgOverworldEncounterPitFighterRewardData::CMsgOverworldEncounterPitFighterRewardData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgOverworldEncounterPitFighterRewardData)
}
CMsgOverworldEncounterPitFighterRewardData::CMsgOverworldEncounterPitFighterRewardData(const CMsgOverworldEncounterPitFighterRewardData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgOverworldEncounterPitFighterRewardData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_id_){}
    , decltype(_impl_.choice_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.token_id_, &from._impl_.token_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.choice_) -
    reinterpret_cast<char*>(&_impl_.token_id_)) + sizeof(_impl_.choice_));
  // @@protoc_insertion_point(copy_constructor:CMsgOverworldEncounterPitFighterRewardData)
}

inline void CMsgOverworldEncounterPitFighterRewardData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_id_){0u}
    , decltype(_impl_.choice_){0u}
  };
}

CMsgOverworldEncounterPitFighterRewardData::~CMsgOverworldEncounterPitFighterRewardData() {
  // @@protoc_insertion_point(destructor:CMsgOverworldEncounterPitFighterRewardData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgOverworldEncounterPitFighterRewardData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgOverworldEncounterPitFighterRewardData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgOverworldEncounterPitFighterRewardData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgOverworldEncounterPitFighterRewardData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.token_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.choice_) -
        reinterpret_cast<char*>(&_impl_.token_id_)) + sizeof(_impl_.choice_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgOverworldEncounterPitFighterRewardData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 token_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_token_id(&has_bits);
          _impl_.token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 choice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_choice(&has_bits);
          _impl_.choice_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgOverworldEncounterPitFighterRewardData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgOverworldEncounterPitFighterRewardData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 token_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_token_id(), target);
  }

  // optional uint32 choice = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_choice(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgOverworldEncounterPitFighterRewardData)
  return target;
}

size_t CMsgOverworldEncounterPitFighterRewardData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgOverworldEncounterPitFighterRewardData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 token_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_token_id());
    }

    // optional uint32 choice = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_choice());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgOverworldEncounterPitFighterRewardData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgOverworldEncounterPitFighterRewardData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgOverworldEncounterPitFighterRewardData::GetClassData() const { return &_class_data_; }


void CMsgOverworldEncounterPitFighterRewardData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgOverworldEncounterPitFighterRewardData*>(&to_msg);
  auto& from = static_cast<const CMsgOverworldEncounterPitFighterRewardData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgOverworldEncounterPitFighterRewardData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.token_id_ = from._impl_.token_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.choice_ = from._impl_.choice_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgOverworldEncounterPitFighterRewardData::CopyFrom(const CMsgOverworldEncounterPitFighterRewardData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgOverworldEncounterPitFighterRewardData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgOverworldEncounterPitFighterRewardData::IsInitialized() const {
  return true;
}

void CMsgOverworldEncounterPitFighterRewardData::InternalSwap(CMsgOverworldEncounterPitFighterRewardData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterPitFighterRewardData, _impl_.choice_)
      + sizeof(CMsgOverworldEncounterPitFighterRewardData::_impl_.choice_)
      - PROTOBUF_FIELD_OFFSET(CMsgOverworldEncounterPitFighterRewardData, _impl_.token_id_)>(
          reinterpret_cast<char*>(&_impl_.token_id_),
          reinterpret_cast<char*>(&other->_impl_.token_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgOverworldEncounterPitFighterRewardData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[20]);
}

// ===================================================================

class CMsgClientToGCOverworldClaimEncounterReward::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldClaimEncounterReward>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_reward_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_periodic_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgOverworldEncounterData& extra_reward_data(const CMsgClientToGCOverworldClaimEncounterReward* msg);
  static void set_has_extra_reward_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldEncounterData&
CMsgClientToGCOverworldClaimEncounterReward::_Internal::extra_reward_data(const CMsgClientToGCOverworldClaimEncounterReward* msg) {
  return *msg->_impl_.extra_reward_data_;
}
CMsgClientToGCOverworldClaimEncounterReward::CMsgClientToGCOverworldClaimEncounterReward(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldClaimEncounterReward)
}
CMsgClientToGCOverworldClaimEncounterReward::CMsgClientToGCOverworldClaimEncounterReward(const CMsgClientToGCOverworldClaimEncounterReward& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldClaimEncounterReward* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extra_reward_data_){nullptr}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.node_id_){}
    , decltype(_impl_.reward_data_){}
    , decltype(_impl_.periodic_resource_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_extra_reward_data()) {
    _this->_impl_.extra_reward_data_ = new ::CMsgOverworldEncounterData(*from._impl_.extra_reward_data_);
  }
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.periodic_resource_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.periodic_resource_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldClaimEncounterReward)
}

inline void CMsgClientToGCOverworldClaimEncounterReward::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.extra_reward_data_){nullptr}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.node_id_){0u}
    , decltype(_impl_.reward_data_){0u}
    , decltype(_impl_.periodic_resource_id_){0u}
  };
}

CMsgClientToGCOverworldClaimEncounterReward::~CMsgClientToGCOverworldClaimEncounterReward() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldClaimEncounterReward)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldClaimEncounterReward::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.extra_reward_data_;
}

void CMsgClientToGCOverworldClaimEncounterReward::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldClaimEncounterReward::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldClaimEncounterReward)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.extra_reward_data_ != nullptr);
    _impl_.extra_reward_data_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.periodic_resource_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.periodic_resource_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldClaimEncounterReward::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reward_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reward_data(&has_bits);
          _impl_.reward_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 periodic_resource_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_periodic_resource_id(&has_bits);
          _impl_.periodic_resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldEncounterData extra_reward_data = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_extra_reward_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldClaimEncounterReward::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldClaimEncounterReward)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional uint32 node_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  // optional uint32 reward_data = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_reward_data(), target);
  }

  // optional uint32 periodic_resource_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_periodic_resource_id(), target);
  }

  // optional .CMsgOverworldEncounterData extra_reward_data = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::extra_reward_data(this),
        _Internal::extra_reward_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldClaimEncounterReward)
  return target;
}

size_t CMsgClientToGCOverworldClaimEncounterReward::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldClaimEncounterReward)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgOverworldEncounterData extra_reward_data = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.extra_reward_data_);
    }

    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 node_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional uint32 reward_data = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reward_data());
    }

    // optional uint32 periodic_resource_id = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_periodic_resource_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldClaimEncounterReward::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldClaimEncounterReward::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldClaimEncounterReward::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldClaimEncounterReward::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldClaimEncounterReward*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldClaimEncounterReward&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldClaimEncounterReward)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_extra_reward_data()->::CMsgOverworldEncounterData::MergeFrom(
          from._internal_extra_reward_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.reward_data_ = from._impl_.reward_data_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.periodic_resource_id_ = from._impl_.periodic_resource_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldClaimEncounterReward::CopyFrom(const CMsgClientToGCOverworldClaimEncounterReward& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldClaimEncounterReward)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldClaimEncounterReward::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldClaimEncounterReward::InternalSwap(CMsgClientToGCOverworldClaimEncounterReward* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldClaimEncounterReward, _impl_.periodic_resource_id_)
      + sizeof(CMsgClientToGCOverworldClaimEncounterReward::_impl_.periodic_resource_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldClaimEncounterReward, _impl_.extra_reward_data_)>(
          reinterpret_cast<char*>(&_impl_.extra_reward_data_),
          reinterpret_cast<char*>(&other->_impl_.extra_reward_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldClaimEncounterReward::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[21]);
}

// ===================================================================

class CMsgClientToGCOverworldClaimEncounterRewardResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldClaimEncounterRewardResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgDOTAClaimEventActionResponse& claim_response(const CMsgClientToGCOverworldClaimEncounterRewardResponse* msg);
  static void set_has_claim_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgOverworldTokenQuantity& tokens_received(const CMsgClientToGCOverworldClaimEncounterRewardResponse* msg);
  static void set_has_tokens_received(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgDOTAClaimEventActionResponse&
CMsgClientToGCOverworldClaimEncounterRewardResponse::_Internal::claim_response(const CMsgClientToGCOverworldClaimEncounterRewardResponse* msg) {
  return *msg->_impl_.claim_response_;
}
const ::CMsgOverworldTokenQuantity&
CMsgClientToGCOverworldClaimEncounterRewardResponse::_Internal::tokens_received(const CMsgClientToGCOverworldClaimEncounterRewardResponse* msg) {
  return *msg->_impl_.tokens_received_;
}
void CMsgClientToGCOverworldClaimEncounterRewardResponse::clear_claim_response() {
  if (_impl_.claim_response_ != nullptr) _impl_.claim_response_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgClientToGCOverworldClaimEncounterRewardResponse::CMsgClientToGCOverworldClaimEncounterRewardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldClaimEncounterRewardResponse)
}
CMsgClientToGCOverworldClaimEncounterRewardResponse::CMsgClientToGCOverworldClaimEncounterRewardResponse(const CMsgClientToGCOverworldClaimEncounterRewardResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldClaimEncounterRewardResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claim_response_){nullptr}
    , decltype(_impl_.tokens_received_){nullptr}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_claim_response()) {
    _this->_impl_.claim_response_ = new ::CMsgDOTAClaimEventActionResponse(*from._impl_.claim_response_);
  }
  if (from._internal_has_tokens_received()) {
    _this->_impl_.tokens_received_ = new ::CMsgOverworldTokenQuantity(*from._impl_.tokens_received_);
  }
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldClaimEncounterRewardResponse)
}

inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.claim_response_){nullptr}
    , decltype(_impl_.tokens_received_){nullptr}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldClaimEncounterRewardResponse::~CMsgClientToGCOverworldClaimEncounterRewardResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldClaimEncounterRewardResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.claim_response_;
  if (this != internal_default_instance()) delete _impl_.tokens_received_;
}

void CMsgClientToGCOverworldClaimEncounterRewardResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldClaimEncounterRewardResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.claim_response_ != nullptr);
      _impl_.claim_response_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.tokens_received_ != nullptr);
      _impl_.tokens_received_->Clear();
    }
  }
  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldClaimEncounterRewardResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldClaimEncounterRewardResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_claim_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity tokens_received = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokens_received(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldClaimEncounterRewardResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::claim_response(this),
        _Internal::claim_response(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgOverworldTokenQuantity tokens_received = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::tokens_received(this),
        _Internal::tokens_received(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  return target;
}

size_t CMsgClientToGCOverworldClaimEncounterRewardResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgDOTAClaimEventActionResponse claim_response = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.claim_response_);
    }

    // optional .CMsgOverworldTokenQuantity tokens_received = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tokens_received_);
    }

    // optional .CMsgClientToGCOverworldClaimEncounterRewardResponse.EResponse response = 1 [default = k_eInternalError];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldClaimEncounterRewardResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldClaimEncounterRewardResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldClaimEncounterRewardResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldClaimEncounterRewardResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldClaimEncounterRewardResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldClaimEncounterRewardResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_claim_response()->::CMsgDOTAClaimEventActionResponse::MergeFrom(
          from._internal_claim_response());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_tokens_received()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_tokens_received());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldClaimEncounterRewardResponse::CopyFrom(const CMsgClientToGCOverworldClaimEncounterRewardResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldClaimEncounterRewardResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldClaimEncounterRewardResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldClaimEncounterRewardResponse::InternalSwap(CMsgClientToGCOverworldClaimEncounterRewardResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldClaimEncounterRewardResponse, _impl_.response_)
      + sizeof(CMsgClientToGCOverworldClaimEncounterRewardResponse::_impl_.response_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldClaimEncounterRewardResponse, _impl_.claim_response_)>(
          reinterpret_cast<char*>(&_impl_.claim_response_),
          reinterpret_cast<char*>(&other->_impl_.claim_response_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldClaimEncounterRewardResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[22]);
}

// ===================================================================

class CMsgClientToGCOverworldVisitEncounter::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldVisitEncounter>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgClientToGCOverworldVisitEncounter::CMsgClientToGCOverworldVisitEncounter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldVisitEncounter)
}
CMsgClientToGCOverworldVisitEncounter::CMsgClientToGCOverworldVisitEncounter(const CMsgClientToGCOverworldVisitEncounter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldVisitEncounter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.node_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.node_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldVisitEncounter)
}

inline void CMsgClientToGCOverworldVisitEncounter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.node_id_){0u}
  };
}

CMsgClientToGCOverworldVisitEncounter::~CMsgClientToGCOverworldVisitEncounter() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldVisitEncounter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldVisitEncounter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldVisitEncounter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldVisitEncounter::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldVisitEncounter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.node_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldVisitEncounter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldVisitEncounter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldVisitEncounter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional uint32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldVisitEncounter)
  return target;
}

size_t CMsgClientToGCOverworldVisitEncounter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldVisitEncounter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 node_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldVisitEncounter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldVisitEncounter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldVisitEncounter::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldVisitEncounter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldVisitEncounter*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldVisitEncounter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldVisitEncounter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldVisitEncounter::CopyFrom(const CMsgClientToGCOverworldVisitEncounter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldVisitEncounter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldVisitEncounter::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldVisitEncounter::InternalSwap(CMsgClientToGCOverworldVisitEncounter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldVisitEncounter, _impl_.node_id_)
      + sizeof(CMsgClientToGCOverworldVisitEncounter::_impl_.node_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldVisitEncounter, _impl_.overworld_id_)>(
          reinterpret_cast<char*>(&_impl_.overworld_id_),
          reinterpret_cast<char*>(&other->_impl_.overworld_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldVisitEncounter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[23]);
}

// ===================================================================

class CMsgClientToGCOverworldVisitEncounterResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldVisitEncounterResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldVisitEncounterResponse::CMsgClientToGCOverworldVisitEncounterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldVisitEncounterResponse)
}
CMsgClientToGCOverworldVisitEncounterResponse::CMsgClientToGCOverworldVisitEncounterResponse(const CMsgClientToGCOverworldVisitEncounterResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldVisitEncounterResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldVisitEncounterResponse)
}

inline void CMsgClientToGCOverworldVisitEncounterResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldVisitEncounterResponse::~CMsgClientToGCOverworldVisitEncounterResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldVisitEncounterResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldVisitEncounterResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldVisitEncounterResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldVisitEncounterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldVisitEncounterResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldVisitEncounterResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldVisitEncounterResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldVisitEncounterResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldVisitEncounterResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldVisitEncounterResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldVisitEncounterResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldVisitEncounterResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldVisitEncounterResponse)
  return target;
}

size_t CMsgClientToGCOverworldVisitEncounterResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldVisitEncounterResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldVisitEncounterResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldVisitEncounterResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldVisitEncounterResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldVisitEncounterResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldVisitEncounterResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldVisitEncounterResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldVisitEncounterResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldVisitEncounterResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldVisitEncounterResponse::CopyFrom(const CMsgClientToGCOverworldVisitEncounterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldVisitEncounterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldVisitEncounterResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldVisitEncounterResponse::InternalSwap(CMsgClientToGCOverworldVisitEncounterResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldVisitEncounterResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[24]);
}

// ===================================================================

class CMsgClientToGCOverworldMoveToNode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldMoveToNode>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgClientToGCOverworldMoveToNode::CMsgClientToGCOverworldMoveToNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldMoveToNode)
}
CMsgClientToGCOverworldMoveToNode::CMsgClientToGCOverworldMoveToNode(const CMsgClientToGCOverworldMoveToNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldMoveToNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.node_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.node_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldMoveToNode)
}

inline void CMsgClientToGCOverworldMoveToNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.node_id_){0u}
  };
}

CMsgClientToGCOverworldMoveToNode::~CMsgClientToGCOverworldMoveToNode() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldMoveToNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldMoveToNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldMoveToNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldMoveToNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldMoveToNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.node_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldMoveToNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldMoveToNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldMoveToNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional uint32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldMoveToNode)
  return target;
}

size_t CMsgClientToGCOverworldMoveToNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldMoveToNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 node_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldMoveToNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldMoveToNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldMoveToNode::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldMoveToNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldMoveToNode*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldMoveToNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldMoveToNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldMoveToNode::CopyFrom(const CMsgClientToGCOverworldMoveToNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldMoveToNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldMoveToNode::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldMoveToNode::InternalSwap(CMsgClientToGCOverworldMoveToNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldMoveToNode, _impl_.node_id_)
      + sizeof(CMsgClientToGCOverworldMoveToNode::_impl_.node_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldMoveToNode, _impl_.overworld_id_)>(
          reinterpret_cast<char*>(&_impl_.overworld_id_),
          reinterpret_cast<char*>(&other->_impl_.overworld_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldMoveToNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[25]);
}

// ===================================================================

class CMsgClientToGCOverworldMoveToNodeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldMoveToNodeResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldMoveToNodeResponse::CMsgClientToGCOverworldMoveToNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldMoveToNodeResponse)
}
CMsgClientToGCOverworldMoveToNodeResponse::CMsgClientToGCOverworldMoveToNodeResponse(const CMsgClientToGCOverworldMoveToNodeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldMoveToNodeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldMoveToNodeResponse)
}

inline void CMsgClientToGCOverworldMoveToNodeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldMoveToNodeResponse::~CMsgClientToGCOverworldMoveToNodeResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldMoveToNodeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldMoveToNodeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldMoveToNodeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldMoveToNodeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldMoveToNodeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldMoveToNodeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldMoveToNodeResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldMoveToNodeResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldMoveToNodeResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldMoveToNodeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldMoveToNodeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldMoveToNodeResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldMoveToNodeResponse)
  return target;
}

size_t CMsgClientToGCOverworldMoveToNodeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldMoveToNodeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldMoveToNodeResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldMoveToNodeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldMoveToNodeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldMoveToNodeResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldMoveToNodeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldMoveToNodeResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldMoveToNodeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldMoveToNodeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldMoveToNodeResponse::CopyFrom(const CMsgClientToGCOverworldMoveToNodeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldMoveToNodeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldMoveToNodeResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldMoveToNodeResponse::InternalSwap(CMsgClientToGCOverworldMoveToNodeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldMoveToNodeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[26]);
}

// ===================================================================

class CMsgClientToGCOverworldTradeTokens::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldTradeTokens>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgOverworldTokenQuantity& token_offer(const CMsgClientToGCOverworldTradeTokens* msg);
  static void set_has_token_offer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgOverworldTokenQuantity& token_request(const CMsgClientToGCOverworldTradeTokens* msg);
  static void set_has_token_request(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_recipe(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encounter_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgClientToGCOverworldTradeTokens::_Internal::token_offer(const CMsgClientToGCOverworldTradeTokens* msg) {
  return *msg->_impl_.token_offer_;
}
const ::CMsgOverworldTokenQuantity&
CMsgClientToGCOverworldTradeTokens::_Internal::token_request(const CMsgClientToGCOverworldTradeTokens* msg) {
  return *msg->_impl_.token_request_;
}
CMsgClientToGCOverworldTradeTokens::CMsgClientToGCOverworldTradeTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldTradeTokens)
}
CMsgClientToGCOverworldTradeTokens::CMsgClientToGCOverworldTradeTokens(const CMsgClientToGCOverworldTradeTokens& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldTradeTokens* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_offer_){nullptr}
    , decltype(_impl_.token_request_){nullptr}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.recipe_){}
    , decltype(_impl_.encounter_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_offer()) {
    _this->_impl_.token_offer_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_offer_);
  }
  if (from._internal_has_token_request()) {
    _this->_impl_.token_request_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_request_);
  }
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.encounter_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.encounter_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldTradeTokens)
}

inline void CMsgClientToGCOverworldTradeTokens::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_offer_){nullptr}
    , decltype(_impl_.token_request_){nullptr}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.recipe_){0u}
    , decltype(_impl_.encounter_id_){0u}
  };
}

CMsgClientToGCOverworldTradeTokens::~CMsgClientToGCOverworldTradeTokens() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldTradeTokens)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldTradeTokens::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_offer_;
  if (this != internal_default_instance()) delete _impl_.token_request_;
}

void CMsgClientToGCOverworldTradeTokens::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldTradeTokens::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldTradeTokens)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.token_offer_ != nullptr);
      _impl_.token_offer_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.token_request_ != nullptr);
      _impl_.token_request_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.encounter_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.encounter_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldTradeTokens::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_offer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_offer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recipe = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_recipe(&has_bits);
          _impl_.recipe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 encounter_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_encounter_id(&has_bits);
          _impl_.encounter_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldTradeTokens::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldTradeTokens)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional .CMsgOverworldTokenQuantity token_offer = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::token_offer(this),
        _Internal::token_offer(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgOverworldTokenQuantity token_request = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::token_request(this),
        _Internal::token_request(this).GetCachedSize(), target, stream);
  }

  // optional uint32 recipe = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_recipe(), target);
  }

  // optional uint32 encounter_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_encounter_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldTradeTokens)
  return target;
}

size_t CMsgClientToGCOverworldTradeTokens::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldTradeTokens)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgOverworldTokenQuantity token_offer = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_offer_);
    }

    // optional .CMsgOverworldTokenQuantity token_request = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_request_);
    }

    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 recipe = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_recipe());
    }

    // optional uint32 encounter_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_encounter_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldTradeTokens::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldTradeTokens::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldTradeTokens::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldTradeTokens::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldTradeTokens*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldTradeTokens&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldTradeTokens)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_offer()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_offer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_token_request()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_request());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.recipe_ = from._impl_.recipe_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.encounter_id_ = from._impl_.encounter_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldTradeTokens::CopyFrom(const CMsgClientToGCOverworldTradeTokens& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldTradeTokens)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldTradeTokens::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldTradeTokens::InternalSwap(CMsgClientToGCOverworldTradeTokens* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldTradeTokens, _impl_.encounter_id_)
      + sizeof(CMsgClientToGCOverworldTradeTokens::_impl_.encounter_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldTradeTokens, _impl_.token_offer_)>(
          reinterpret_cast<char*>(&_impl_.token_offer_),
          reinterpret_cast<char*>(&other->_impl_.token_offer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldTradeTokens::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[27]);
}

// ===================================================================

class CMsgClientToGCOverworldTradeTokensResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldTradeTokensResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldTokenQuantity& tokens_received(const CMsgClientToGCOverworldTradeTokensResponse* msg);
  static void set_has_tokens_received(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgClientToGCOverworldTradeTokensResponse::_Internal::tokens_received(const CMsgClientToGCOverworldTradeTokensResponse* msg) {
  return *msg->_impl_.tokens_received_;
}
CMsgClientToGCOverworldTradeTokensResponse::CMsgClientToGCOverworldTradeTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldTradeTokensResponse)
}
CMsgClientToGCOverworldTradeTokensResponse::CMsgClientToGCOverworldTradeTokensResponse(const CMsgClientToGCOverworldTradeTokensResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldTradeTokensResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_received_){nullptr}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tokens_received()) {
    _this->_impl_.tokens_received_ = new ::CMsgOverworldTokenQuantity(*from._impl_.tokens_received_);
  }
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldTradeTokensResponse)
}

inline void CMsgClientToGCOverworldTradeTokensResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tokens_received_){nullptr}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldTradeTokensResponse::~CMsgClientToGCOverworldTradeTokensResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldTradeTokensResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldTradeTokensResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tokens_received_;
}

void CMsgClientToGCOverworldTradeTokensResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldTradeTokensResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldTradeTokensResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.tokens_received_ != nullptr);
    _impl_.tokens_received_->Clear();
  }
  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldTradeTokensResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldTradeTokensResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldTradeTokensResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldTradeTokensResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity tokens_received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tokens_received(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldTradeTokensResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldTradeTokensResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldTradeTokensResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  // optional .CMsgOverworldTokenQuantity tokens_received = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tokens_received(this),
        _Internal::tokens_received(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldTradeTokensResponse)
  return target;
}

size_t CMsgClientToGCOverworldTradeTokensResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldTradeTokensResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldTokenQuantity tokens_received = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.tokens_received_);
    }

    // optional .CMsgClientToGCOverworldTradeTokensResponse.EResponse response = 1 [default = k_eInternalError];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldTradeTokensResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldTradeTokensResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldTradeTokensResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldTradeTokensResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldTradeTokensResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldTradeTokensResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldTradeTokensResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_tokens_received()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_tokens_received());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.response_ = from._impl_.response_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldTradeTokensResponse::CopyFrom(const CMsgClientToGCOverworldTradeTokensResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldTradeTokensResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldTradeTokensResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldTradeTokensResponse::InternalSwap(CMsgClientToGCOverworldTradeTokensResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldTradeTokensResponse, _impl_.response_)
      + sizeof(CMsgClientToGCOverworldTradeTokensResponse::_impl_.response_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldTradeTokensResponse, _impl_.tokens_received_)>(
          reinterpret_cast<char*>(&_impl_.tokens_received_),
          reinterpret_cast<char*>(&other->_impl_.tokens_received_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldTradeTokensResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[28]);
}

// ===================================================================

class CMsgClientToGCOverworldGiftTokens::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGiftTokens>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldTokenCount& token_gift(const CMsgClientToGCOverworldGiftTokens* msg);
  static void set_has_token_gift(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_recipient_account_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_periodic_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgOverworldTokenCount&
CMsgClientToGCOverworldGiftTokens::_Internal::token_gift(const CMsgClientToGCOverworldGiftTokens* msg) {
  return *msg->_impl_.token_gift_;
}
CMsgClientToGCOverworldGiftTokens::CMsgClientToGCOverworldGiftTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGiftTokens)
}
CMsgClientToGCOverworldGiftTokens::CMsgClientToGCOverworldGiftTokens(const CMsgClientToGCOverworldGiftTokens& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGiftTokens* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_gift_){nullptr}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.recipient_account_id_){}
    , decltype(_impl_.periodic_resource_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_gift()) {
    _this->_impl_.token_gift_ = new ::CMsgOverworldTokenCount(*from._impl_.token_gift_);
  }
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.periodic_resource_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.periodic_resource_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGiftTokens)
}

inline void CMsgClientToGCOverworldGiftTokens::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_gift_){nullptr}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.recipient_account_id_){0u}
    , decltype(_impl_.periodic_resource_id_){0u}
  };
}

CMsgClientToGCOverworldGiftTokens::~CMsgClientToGCOverworldGiftTokens() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGiftTokens)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGiftTokens::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_gift_;
}

void CMsgClientToGCOverworldGiftTokens::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGiftTokens::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGiftTokens)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.token_gift_ != nullptr);
    _impl_.token_gift_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.periodic_resource_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.periodic_resource_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGiftTokens::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenCount token_gift = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_gift(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 recipient_account_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_recipient_account_id(&has_bits);
          _impl_.recipient_account_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 periodic_resource_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_periodic_resource_id(&has_bits);
          _impl_.periodic_resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGiftTokens::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGiftTokens)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional .CMsgOverworldTokenCount token_gift = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::token_gift(this),
        _Internal::token_gift(this).GetCachedSize(), target, stream);
  }

  // optional uint32 recipient_account_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_recipient_account_id(), target);
  }

  // optional uint32 periodic_resource_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_periodic_resource_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGiftTokens)
  return target;
}

size_t CMsgClientToGCOverworldGiftTokens::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGiftTokens)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgOverworldTokenCount token_gift = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_gift_);
    }

    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 recipient_account_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_recipient_account_id());
    }

    // optional uint32 periodic_resource_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_periodic_resource_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGiftTokens::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGiftTokens::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGiftTokens::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGiftTokens::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGiftTokens*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGiftTokens&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGiftTokens)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_gift()->::CMsgOverworldTokenCount::MergeFrom(
          from._internal_token_gift());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.recipient_account_id_ = from._impl_.recipient_account_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.periodic_resource_id_ = from._impl_.periodic_resource_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGiftTokens::CopyFrom(const CMsgClientToGCOverworldGiftTokens& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGiftTokens)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGiftTokens::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGiftTokens::InternalSwap(CMsgClientToGCOverworldGiftTokens* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGiftTokens, _impl_.periodic_resource_id_)
      + sizeof(CMsgClientToGCOverworldGiftTokens::_impl_.periodic_resource_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGiftTokens, _impl_.token_gift_)>(
          reinterpret_cast<char*>(&_impl_.token_gift_),
          reinterpret_cast<char*>(&other->_impl_.token_gift_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGiftTokens::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[29]);
}

// ===================================================================

class CMsgClientToGCOverworldGiftTokensResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGiftTokensResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldGiftTokensResponse::CMsgClientToGCOverworldGiftTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGiftTokensResponse)
}
CMsgClientToGCOverworldGiftTokensResponse::CMsgClientToGCOverworldGiftTokensResponse(const CMsgClientToGCOverworldGiftTokensResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGiftTokensResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGiftTokensResponse)
}

inline void CMsgClientToGCOverworldGiftTokensResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldGiftTokensResponse::~CMsgClientToGCOverworldGiftTokensResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGiftTokensResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGiftTokensResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldGiftTokensResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGiftTokensResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGiftTokensResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGiftTokensResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldGiftTokensResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldGiftTokensResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldGiftTokensResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGiftTokensResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGiftTokensResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldGiftTokensResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGiftTokensResponse)
  return target;
}

size_t CMsgClientToGCOverworldGiftTokensResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGiftTokensResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldGiftTokensResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGiftTokensResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGiftTokensResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGiftTokensResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGiftTokensResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGiftTokensResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGiftTokensResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGiftTokensResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGiftTokensResponse::CopyFrom(const CMsgClientToGCOverworldGiftTokensResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGiftTokensResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGiftTokensResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGiftTokensResponse::InternalSwap(CMsgClientToGCOverworldGiftTokensResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGiftTokensResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[30]);
}

// ===================================================================

class CMsgClientToGCOverworldDevResetAll::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevResetAll>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldDevResetAll::CMsgClientToGCOverworldDevResetAll(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevResetAll)
}
CMsgClientToGCOverworldDevResetAll::CMsgClientToGCOverworldDevResetAll(const CMsgClientToGCOverworldDevResetAll& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevResetAll* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevResetAll)
}

inline void CMsgClientToGCOverworldDevResetAll::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
  };
}

CMsgClientToGCOverworldDevResetAll::~CMsgClientToGCOverworldDevResetAll() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevResetAll)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevResetAll::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevResetAll::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevResetAll::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevResetAll)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevResetAll::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevResetAll::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevResetAll)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevResetAll)
  return target;
}

size_t CMsgClientToGCOverworldDevResetAll::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevResetAll)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 overworld_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevResetAll::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevResetAll::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevResetAll::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevResetAll::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevResetAll*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevResetAll&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevResetAll)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_overworld_id()) {
    _this->_internal_set_overworld_id(from._internal_overworld_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevResetAll::CopyFrom(const CMsgClientToGCOverworldDevResetAll& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevResetAll)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevResetAll::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevResetAll::InternalSwap(CMsgClientToGCOverworldDevResetAll* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.overworld_id_, other->_impl_.overworld_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevResetAll::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[31]);
}

// ===================================================================

class CMsgClientToGCOverworldDevResetAllResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevResetAllResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldDevResetAllResponse::CMsgClientToGCOverworldDevResetAllResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevResetAllResponse)
}
CMsgClientToGCOverworldDevResetAllResponse::CMsgClientToGCOverworldDevResetAllResponse(const CMsgClientToGCOverworldDevResetAllResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevResetAllResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevResetAllResponse)
}

inline void CMsgClientToGCOverworldDevResetAllResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldDevResetAllResponse::~CMsgClientToGCOverworldDevResetAllResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevResetAllResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevResetAllResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevResetAllResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevResetAllResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevResetAllResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevResetAllResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldDevResetAllResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldDevResetAllResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldDevResetAllResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevResetAllResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevResetAllResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldDevResetAllResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevResetAllResponse)
  return target;
}

size_t CMsgClientToGCOverworldDevResetAllResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevResetAllResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldDevResetAllResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevResetAllResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevResetAllResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevResetAllResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevResetAllResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevResetAllResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevResetAllResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevResetAllResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevResetAllResponse::CopyFrom(const CMsgClientToGCOverworldDevResetAllResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevResetAllResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevResetAllResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevResetAllResponse::InternalSwap(CMsgClientToGCOverworldDevResetAllResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevResetAllResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[32]);
}

// ===================================================================

class CMsgClientToGCOverworldDevResetNode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevResetNode>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgClientToGCOverworldDevResetNode::CMsgClientToGCOverworldDevResetNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevResetNode)
}
CMsgClientToGCOverworldDevResetNode::CMsgClientToGCOverworldDevResetNode(const CMsgClientToGCOverworldDevResetNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevResetNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}
    , decltype(_impl_.node_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.overworld_id_, &from._impl_.overworld_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.node_id_) -
    reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.node_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevResetNode)
}

inline void CMsgClientToGCOverworldDevResetNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
    , decltype(_impl_.node_id_){0u}
  };
}

CMsgClientToGCOverworldDevResetNode::~CMsgClientToGCOverworldDevResetNode() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevResetNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevResetNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevResetNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevResetNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevResetNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.overworld_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.node_id_) -
        reinterpret_cast<char*>(&_impl_.overworld_id_)) + sizeof(_impl_.node_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevResetNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevResetNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevResetNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional uint32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_node_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevResetNode)
  return target;
}

size_t CMsgClientToGCOverworldDevResetNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevResetNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

    // optional uint32 node_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevResetNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevResetNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevResetNode::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevResetNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevResetNode*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevResetNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevResetNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevResetNode::CopyFrom(const CMsgClientToGCOverworldDevResetNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevResetNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevResetNode::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevResetNode::InternalSwap(CMsgClientToGCOverworldDevResetNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldDevResetNode, _impl_.node_id_)
      + sizeof(CMsgClientToGCOverworldDevResetNode::_impl_.node_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldDevResetNode, _impl_.overworld_id_)>(
          reinterpret_cast<char*>(&_impl_.overworld_id_),
          reinterpret_cast<char*>(&other->_impl_.overworld_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevResetNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[33]);
}

// ===================================================================

class CMsgClientToGCOverworldDevResetNodeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevResetNodeResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldDevResetNodeResponse::CMsgClientToGCOverworldDevResetNodeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevResetNodeResponse)
}
CMsgClientToGCOverworldDevResetNodeResponse::CMsgClientToGCOverworldDevResetNodeResponse(const CMsgClientToGCOverworldDevResetNodeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevResetNodeResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevResetNodeResponse)
}

inline void CMsgClientToGCOverworldDevResetNodeResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldDevResetNodeResponse::~CMsgClientToGCOverworldDevResetNodeResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevResetNodeResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevResetNodeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevResetNodeResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevResetNodeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevResetNodeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevResetNodeResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldDevResetNodeResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldDevResetNodeResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldDevResetNodeResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevResetNodeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevResetNodeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldDevResetNodeResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevResetNodeResponse)
  return target;
}

size_t CMsgClientToGCOverworldDevResetNodeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevResetNodeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldDevResetNodeResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevResetNodeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevResetNodeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevResetNodeResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevResetNodeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevResetNodeResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevResetNodeResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevResetNodeResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevResetNodeResponse::CopyFrom(const CMsgClientToGCOverworldDevResetNodeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevResetNodeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevResetNodeResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevResetNodeResponse::InternalSwap(CMsgClientToGCOverworldDevResetNodeResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevResetNodeResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[34]);
}

// ===================================================================

class CMsgClientToGCOverworldDevGrantTokens::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevGrantTokens>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgOverworldTokenQuantity& token_quantity(const CMsgClientToGCOverworldDevGrantTokens* msg);
  static void set_has_token_quantity(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgOverworldTokenQuantity&
CMsgClientToGCOverworldDevGrantTokens::_Internal::token_quantity(const CMsgClientToGCOverworldDevGrantTokens* msg) {
  return *msg->_impl_.token_quantity_;
}
CMsgClientToGCOverworldDevGrantTokens::CMsgClientToGCOverworldDevGrantTokens(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevGrantTokens)
}
CMsgClientToGCOverworldDevGrantTokens::CMsgClientToGCOverworldDevGrantTokens(const CMsgClientToGCOverworldDevGrantTokens& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevGrantTokens* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_quantity_){nullptr}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_token_quantity()) {
    _this->_impl_.token_quantity_ = new ::CMsgOverworldTokenQuantity(*from._impl_.token_quantity_);
  }
  _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevGrantTokens)
}

inline void CMsgClientToGCOverworldDevGrantTokens::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_quantity_){nullptr}
    , decltype(_impl_.overworld_id_){0u}
  };
}

CMsgClientToGCOverworldDevGrantTokens::~CMsgClientToGCOverworldDevGrantTokens() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevGrantTokens)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevGrantTokens::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.token_quantity_;
}

void CMsgClientToGCOverworldDevGrantTokens::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevGrantTokens::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevGrantTokens)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.token_quantity_ != nullptr);
    _impl_.token_quantity_->Clear();
  }
  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevGrantTokens::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgOverworldTokenQuantity token_quantity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_token_quantity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevGrantTokens::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevGrantTokens)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  // optional .CMsgOverworldTokenQuantity token_quantity = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::token_quantity(this),
        _Internal::token_quantity(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevGrantTokens)
  return target;
}

size_t CMsgClientToGCOverworldDevGrantTokens::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevGrantTokens)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgOverworldTokenQuantity token_quantity = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.token_quantity_);
    }

    // optional uint32 overworld_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevGrantTokens::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevGrantTokens::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevGrantTokens::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevGrantTokens::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevGrantTokens*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevGrantTokens&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevGrantTokens)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_token_quantity()->::CMsgOverworldTokenQuantity::MergeFrom(
          from._internal_token_quantity());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevGrantTokens::CopyFrom(const CMsgClientToGCOverworldDevGrantTokens& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevGrantTokens)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevGrantTokens::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevGrantTokens::InternalSwap(CMsgClientToGCOverworldDevGrantTokens* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldDevGrantTokens, _impl_.overworld_id_)
      + sizeof(CMsgClientToGCOverworldDevGrantTokens::_impl_.overworld_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldDevGrantTokens, _impl_.token_quantity_)>(
          reinterpret_cast<char*>(&_impl_.token_quantity_),
          reinterpret_cast<char*>(&other->_impl_.token_quantity_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevGrantTokens::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[35]);
}

// ===================================================================

class CMsgClientToGCOverworldDevGrantTokensResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevGrantTokensResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldDevGrantTokensResponse::CMsgClientToGCOverworldDevGrantTokensResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevGrantTokensResponse)
}
CMsgClientToGCOverworldDevGrantTokensResponse::CMsgClientToGCOverworldDevGrantTokensResponse(const CMsgClientToGCOverworldDevGrantTokensResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevGrantTokensResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevGrantTokensResponse)
}

inline void CMsgClientToGCOverworldDevGrantTokensResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldDevGrantTokensResponse::~CMsgClientToGCOverworldDevGrantTokensResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevGrantTokensResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevGrantTokensResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevGrantTokensResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevGrantTokensResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevGrantTokensResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevGrantTokensResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldDevGrantTokensResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldDevGrantTokensResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevGrantTokensResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevGrantTokensResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldDevGrantTokensResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevGrantTokensResponse)
  return target;
}

size_t CMsgClientToGCOverworldDevGrantTokensResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevGrantTokensResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldDevGrantTokensResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevGrantTokensResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevGrantTokensResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevGrantTokensResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevGrantTokensResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevGrantTokensResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevGrantTokensResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevGrantTokensResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevGrantTokensResponse::CopyFrom(const CMsgClientToGCOverworldDevGrantTokensResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevGrantTokensResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevGrantTokensResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevGrantTokensResponse::InternalSwap(CMsgClientToGCOverworldDevGrantTokensResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevGrantTokensResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[36]);
}

// ===================================================================

class CMsgClientToGCOverworldDevClearInventory::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevClearInventory>()._impl_._has_bits_);
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldDevClearInventory::CMsgClientToGCOverworldDevClearInventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevClearInventory)
}
CMsgClientToGCOverworldDevClearInventory::CMsgClientToGCOverworldDevClearInventory(const CMsgClientToGCOverworldDevClearInventory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevClearInventory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevClearInventory)
}

inline void CMsgClientToGCOverworldDevClearInventory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.overworld_id_){0u}
  };
}

CMsgClientToGCOverworldDevClearInventory::~CMsgClientToGCOverworldDevClearInventory() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevClearInventory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevClearInventory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevClearInventory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevClearInventory::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevClearInventory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.overworld_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevClearInventory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 overworld_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevClearInventory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevClearInventory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 overworld_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_overworld_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevClearInventory)
  return target;
}

size_t CMsgClientToGCOverworldDevClearInventory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevClearInventory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 overworld_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevClearInventory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevClearInventory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevClearInventory::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevClearInventory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevClearInventory*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevClearInventory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevClearInventory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_overworld_id()) {
    _this->_internal_set_overworld_id(from._internal_overworld_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevClearInventory::CopyFrom(const CMsgClientToGCOverworldDevClearInventory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevClearInventory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevClearInventory::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevClearInventory::InternalSwap(CMsgClientToGCOverworldDevClearInventory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.overworld_id_, other->_impl_.overworld_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevClearInventory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[37]);
}

// ===================================================================

class CMsgClientToGCOverworldDevClearInventoryResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldDevClearInventoryResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldDevClearInventoryResponse::CMsgClientToGCOverworldDevClearInventoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldDevClearInventoryResponse)
}
CMsgClientToGCOverworldDevClearInventoryResponse::CMsgClientToGCOverworldDevClearInventoryResponse(const CMsgClientToGCOverworldDevClearInventoryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldDevClearInventoryResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldDevClearInventoryResponse)
}

inline void CMsgClientToGCOverworldDevClearInventoryResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldDevClearInventoryResponse::~CMsgClientToGCOverworldDevClearInventoryResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldDevClearInventoryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldDevClearInventoryResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldDevClearInventoryResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldDevClearInventoryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldDevClearInventoryResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldDevClearInventoryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldDevClearInventoryResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldDevClearInventoryResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldDevClearInventoryResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldDevClearInventoryResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldDevClearInventoryResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldDevClearInventoryResponse)
  return target;
}

size_t CMsgClientToGCOverworldDevClearInventoryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldDevClearInventoryResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldDevClearInventoryResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldDevClearInventoryResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldDevClearInventoryResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldDevClearInventoryResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldDevClearInventoryResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldDevClearInventoryResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldDevClearInventoryResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldDevClearInventoryResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldDevClearInventoryResponse::CopyFrom(const CMsgClientToGCOverworldDevClearInventoryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldDevClearInventoryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldDevClearInventoryResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldDevClearInventoryResponse::InternalSwap(CMsgClientToGCOverworldDevClearInventoryResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldDevClearInventoryResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[38]);
}

// ===================================================================

class CMsgClientToGCOverworldFeedback::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldFeedback>()._impl_._has_bits_);
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overworld_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_feedback(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldFeedback::CMsgClientToGCOverworldFeedback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldFeedback)
}
CMsgClientToGCOverworldFeedback::CMsgClientToGCOverworldFeedback(const CMsgClientToGCOverworldFeedback& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldFeedback* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feedback_){}
    , decltype(_impl_.language_){}
    , decltype(_impl_.overworld_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.feedback_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.feedback_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_feedback()) {
    _this->_impl_.feedback_.Set(from._internal_feedback(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.language_, &from._impl_.language_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.overworld_id_) -
    reinterpret_cast<char*>(&_impl_.language_)) + sizeof(_impl_.overworld_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldFeedback)
}

inline void CMsgClientToGCOverworldFeedback::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.feedback_){}
    , decltype(_impl_.language_){0u}
    , decltype(_impl_.overworld_id_){0u}
  };
  _impl_.feedback_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.feedback_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientToGCOverworldFeedback::~CMsgClientToGCOverworldFeedback() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldFeedback)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldFeedback::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.feedback_.Destroy();
}

void CMsgClientToGCOverworldFeedback::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldFeedback::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldFeedback)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.feedback_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.language_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.overworld_id_) -
        reinterpret_cast<char*>(&_impl_.language_)) + sizeof(_impl_.overworld_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldFeedback::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 language = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 overworld_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_overworld_id(&has_bits);
          _impl_.overworld_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string feedback = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_feedback();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgClientToGCOverworldFeedback.feedback");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldFeedback::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldFeedback)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 language = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_language(), target);
  }

  // optional uint32 overworld_id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_overworld_id(), target);
  }

  // optional string feedback = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_feedback().data(), static_cast<int>(this->_internal_feedback().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgClientToGCOverworldFeedback.feedback");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_feedback(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldFeedback)
  return target;
}

size_t CMsgClientToGCOverworldFeedback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldFeedback)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string feedback = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_feedback());
    }

    // optional uint32 language = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_language());
    }

    // optional uint32 overworld_id = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_overworld_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldFeedback::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldFeedback::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldFeedback::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldFeedback::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldFeedback*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldFeedback&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldFeedback)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_feedback(from._internal_feedback());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.overworld_id_ = from._impl_.overworld_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldFeedback::CopyFrom(const CMsgClientToGCOverworldFeedback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldFeedback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldFeedback::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldFeedback::InternalSwap(CMsgClientToGCOverworldFeedback* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.feedback_, lhs_arena,
      &other->_impl_.feedback_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldFeedback, _impl_.overworld_id_)
      + sizeof(CMsgClientToGCOverworldFeedback::_impl_.overworld_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldFeedback, _impl_.language_)>(
          reinterpret_cast<char*>(&_impl_.language_),
          reinterpret_cast<char*>(&other->_impl_.language_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldFeedback::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[39]);
}

// ===================================================================

class CMsgClientToGCOverworldFeedbackResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldFeedbackResponse>()._impl_._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldFeedbackResponse::CMsgClientToGCOverworldFeedbackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldFeedbackResponse)
}
CMsgClientToGCOverworldFeedbackResponse::CMsgClientToGCOverworldFeedbackResponse(const CMsgClientToGCOverworldFeedbackResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldFeedbackResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.response_ = from._impl_.response_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldFeedbackResponse)
}

inline void CMsgClientToGCOverworldFeedbackResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.response_){0}
  };
}

CMsgClientToGCOverworldFeedbackResponse::~CMsgClientToGCOverworldFeedbackResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldFeedbackResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldFeedbackResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldFeedbackResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldFeedbackResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldFeedbackResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.response_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldFeedbackResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgClientToGCOverworldFeedbackResponse.EResponse response = 1 [default = k_eInternalError];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldFeedbackResponse_EResponse_IsValid(val))) {
            _internal_set_response(static_cast<::CMsgClientToGCOverworldFeedbackResponse_EResponse>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldFeedbackResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldFeedbackResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgClientToGCOverworldFeedbackResponse.EResponse response = 1 [default = k_eInternalError];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_response(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldFeedbackResponse)
  return target;
}

size_t CMsgClientToGCOverworldFeedbackResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldFeedbackResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgClientToGCOverworldFeedbackResponse.EResponse response = 1 [default = k_eInternalError];
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldFeedbackResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldFeedbackResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldFeedbackResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldFeedbackResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldFeedbackResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldFeedbackResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldFeedbackResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_response()) {
    _this->_internal_set_response(from._internal_response());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldFeedbackResponse::CopyFrom(const CMsgClientToGCOverworldFeedbackResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldFeedbackResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldFeedbackResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldFeedbackResponse::InternalSwap(CMsgClientToGCOverworldFeedbackResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.response_, other->_impl_.response_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldFeedbackResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[40]);
}

// ===================================================================

class CMsgClientToGCOverworldGetDynamicImage::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGetDynamicImage>()._impl_._has_bits_);
  static void set_has_magic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_image_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgClientToGCOverworldGetDynamicImage::CMsgClientToGCOverworldGetDynamicImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGetDynamicImage)
}
CMsgClientToGCOverworldGetDynamicImage::CMsgClientToGCOverworldGetDynamicImage(const CMsgClientToGCOverworldGetDynamicImage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGetDynamicImage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.magic_){}
    , decltype(_impl_.image_id_){}
    , decltype(_impl_.language_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.magic_, &from._impl_.magic_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.language_) -
    reinterpret_cast<char*>(&_impl_.magic_)) + sizeof(_impl_.language_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGetDynamicImage)
}

inline void CMsgClientToGCOverworldGetDynamicImage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.magic_){0u}
    , decltype(_impl_.image_id_){0u}
    , decltype(_impl_.language_){0u}
  };
}

CMsgClientToGCOverworldGetDynamicImage::~CMsgClientToGCOverworldGetDynamicImage() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGetDynamicImage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGetDynamicImage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgClientToGCOverworldGetDynamicImage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGetDynamicImage::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGetDynamicImage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.magic_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.language_) -
        reinterpret_cast<char*>(&_impl_.magic_)) + sizeof(_impl_.language_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGetDynamicImage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 magic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_magic(&has_bits);
          _impl_.magic_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 image_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_image_id(&has_bits);
          _impl_.image_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 language = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_language(&has_bits);
          _impl_.language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGetDynamicImage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGetDynamicImage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 magic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_magic(), target);
  }

  // optional uint32 image_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_image_id(), target);
  }

  // optional uint32 language = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGetDynamicImage)
  return target;
}

size_t CMsgClientToGCOverworldGetDynamicImage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGetDynamicImage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 magic = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_magic());
    }

    // optional uint32 image_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_image_id());
    }

    // optional uint32 language = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_language());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGetDynamicImage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGetDynamicImage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGetDynamicImage::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGetDynamicImage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGetDynamicImage*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGetDynamicImage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGetDynamicImage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.magic_ = from._impl_.magic_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.image_id_ = from._impl_.image_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.language_ = from._impl_.language_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGetDynamicImage::CopyFrom(const CMsgClientToGCOverworldGetDynamicImage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGetDynamicImage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGetDynamicImage::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGetDynamicImage::InternalSwap(CMsgClientToGCOverworldGetDynamicImage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGetDynamicImage, _impl_.language_)
      + sizeof(CMsgClientToGCOverworldGetDynamicImage::_impl_.language_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGetDynamicImage, _impl_.magic_)>(
          reinterpret_cast<char*>(&_impl_.magic_),
          reinterpret_cast<char*>(&other->_impl_.magic_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGetDynamicImage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[41]);
}

// ===================================================================

class CMsgClientToGCOverworldGetDynamicImageResponse_Image::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGetDynamicImageResponse_Image>()._impl_._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_image_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldGetDynamicImageResponse_Image::CMsgClientToGCOverworldGetDynamicImageResponse_Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
}
CMsgClientToGCOverworldGetDynamicImageResponse_Image::CMsgClientToGCOverworldGetDynamicImageResponse_Image(const CMsgClientToGCOverworldGetDynamicImageResponse_Image& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGetDynamicImageResponse_Image* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.image_bytes_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.format_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.image_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image_bytes()) {
    _this->_impl_.image_bytes_.Set(from._internal_image_bytes(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.format_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.format_));
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
}

inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.image_bytes_){}
    , decltype(_impl_.width_){0u}
    , decltype(_impl_.height_){0u}
    , decltype(_impl_.format_){0}
  };
  _impl_.image_bytes_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.image_bytes_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgClientToGCOverworldGetDynamicImageResponse_Image::~CMsgClientToGCOverworldGetDynamicImageResponse_Image() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGetDynamicImageResponse_Image::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.image_bytes_.Destroy();
}

void CMsgClientToGCOverworldGetDynamicImageResponse_Image::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGetDynamicImageResponse_Image::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.image_bytes_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.format_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.format_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGetDynamicImageResponse_Image::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat format = 3 [default = k_eUnknown];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat_IsValid(val))) {
            _internal_set_format(static_cast<::CMsgClientToGCOverworldGetDynamicImageResponse_EDynamicImageFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes image_bytes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_image_bytes();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGetDynamicImageResponse_Image::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 width = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_width(), target);
  }

  // optional uint32 height = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_height(), target);
  }

  // optional .CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat format = 3 [default = k_eUnknown];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_format(), target);
  }

  // optional bytes image_bytes = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_image_bytes(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  return target;
}

size_t CMsgClientToGCOverworldGetDynamicImageResponse_Image::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes image_bytes = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image_bytes());
    }

    // optional uint32 width = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
    }

    // optional uint32 height = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
    }

    // optional .CMsgClientToGCOverworldGetDynamicImageResponse.EDynamicImageFormat format = 3 [default = k_eUnknown];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGetDynamicImageResponse_Image::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGetDynamicImageResponse_Image::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGetDynamicImageResponse_Image::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGetDynamicImageResponse_Image::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGetDynamicImageResponse_Image*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGetDynamicImageResponse_Image&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_image_bytes(from._internal_image_bytes());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGetDynamicImageResponse_Image::CopyFrom(const CMsgClientToGCOverworldGetDynamicImageResponse_Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGetDynamicImageResponse.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGetDynamicImageResponse_Image::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGetDynamicImageResponse_Image::InternalSwap(CMsgClientToGCOverworldGetDynamicImageResponse_Image* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.image_bytes_, lhs_arena,
      &other->_impl_.image_bytes_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_.format_)
      + sizeof(CMsgClientToGCOverworldGetDynamicImageResponse_Image::_impl_.format_)
      - PROTOBUF_FIELD_OFFSET(CMsgClientToGCOverworldGetDynamicImageResponse_Image, _impl_.width_)>(
          reinterpret_cast<char*>(&_impl_.width_),
          reinterpret_cast<char*>(&other->_impl_.width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGetDynamicImageResponse_Image::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[42]);
}

// ===================================================================

class CMsgClientToGCOverworldGetDynamicImageResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgClientToGCOverworldGetDynamicImageResponse>()._impl_._has_bits_);
  static void set_has_image_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgClientToGCOverworldGetDynamicImageResponse::CMsgClientToGCOverworldGetDynamicImageResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgClientToGCOverworldGetDynamicImageResponse)
}
CMsgClientToGCOverworldGetDynamicImageResponse::CMsgClientToGCOverworldGetDynamicImageResponse(const CMsgClientToGCOverworldGetDynamicImageResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgClientToGCOverworldGetDynamicImageResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.images_){from._impl_.images_}
    , decltype(_impl_.image_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.image_id_ = from._impl_.image_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgClientToGCOverworldGetDynamicImageResponse)
}

inline void CMsgClientToGCOverworldGetDynamicImageResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.images_){arena}
    , decltype(_impl_.image_id_){0u}
  };
}

CMsgClientToGCOverworldGetDynamicImageResponse::~CMsgClientToGCOverworldGetDynamicImageResponse() {
  // @@protoc_insertion_point(destructor:CMsgClientToGCOverworldGetDynamicImageResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgClientToGCOverworldGetDynamicImageResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.images_.~RepeatedPtrField();
}

void CMsgClientToGCOverworldGetDynamicImageResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgClientToGCOverworldGetDynamicImageResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgClientToGCOverworldGetDynamicImageResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.images_.Clear();
  _impl_.image_id_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgClientToGCOverworldGetDynamicImageResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 image_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_image_id(&has_bits);
          _impl_.image_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgClientToGCOverworldGetDynamicImageResponse.Image images = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_images(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgClientToGCOverworldGetDynamicImageResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgClientToGCOverworldGetDynamicImageResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 image_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_image_id(), target);
  }

  // repeated .CMsgClientToGCOverworldGetDynamicImageResponse.Image images = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_images_size()); i < n; i++) {
    const auto& repfield = this->_internal_images(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgClientToGCOverworldGetDynamicImageResponse)
  return target;
}

size_t CMsgClientToGCOverworldGetDynamicImageResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgClientToGCOverworldGetDynamicImageResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgClientToGCOverworldGetDynamicImageResponse.Image images = 2;
  total_size += 1UL * this->_internal_images_size();
  for (const auto& msg : this->_impl_.images_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 image_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_image_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgClientToGCOverworldGetDynamicImageResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgClientToGCOverworldGetDynamicImageResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgClientToGCOverworldGetDynamicImageResponse::GetClassData() const { return &_class_data_; }


void CMsgClientToGCOverworldGetDynamicImageResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgClientToGCOverworldGetDynamicImageResponse*>(&to_msg);
  auto& from = static_cast<const CMsgClientToGCOverworldGetDynamicImageResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgClientToGCOverworldGetDynamicImageResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.images_.MergeFrom(from._impl_.images_);
  if (from._internal_has_image_id()) {
    _this->_internal_set_image_id(from._internal_image_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgClientToGCOverworldGetDynamicImageResponse::CopyFrom(const CMsgClientToGCOverworldGetDynamicImageResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgClientToGCOverworldGetDynamicImageResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgClientToGCOverworldGetDynamicImageResponse::IsInitialized() const {
  return true;
}

void CMsgClientToGCOverworldGetDynamicImageResponse::InternalSwap(CMsgClientToGCOverworldGetDynamicImageResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.images_.InternalSwap(&other->_impl_.images_);
  swap(_impl_.image_id_, other->_impl_.image_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgClientToGCOverworldGetDynamicImageResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_getter, &descriptor_table_dota_5fgcmessages_5fcommon_5foverworld_2eproto_once,
      file_level_metadata_dota_5fgcmessages_5fcommon_5foverworld_2eproto[43]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgOverworldTokenCount*
Arena::CreateMaybeMessage< ::CMsgOverworldTokenCount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldTokenCount >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldTokenQuantity*
Arena::CreateMaybeMessage< ::CMsgOverworldTokenQuantity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldTokenQuantity >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterTokenTreasureData_RewardOption*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterTokenTreasureData_RewardOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterTokenTreasureData_RewardOption >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterTokenTreasureData*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterTokenTreasureData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterTokenTreasureData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterTokenQuestData_Quest*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterTokenQuestData_Quest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterTokenQuestData_Quest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterTokenQuestData*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterTokenQuestData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterTokenQuestData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldHeroList*
Arena::CreateMaybeMessage< ::CMsgOverworldHeroList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldHeroList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterChooseHeroData*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterChooseHeroData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterChooseHeroData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterProgressData*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterProgressData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterProgressData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterData*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldNode*
Arena::CreateMaybeMessage< ::CMsgOverworldNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldNode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldPath*
Arena::CreateMaybeMessage< ::CMsgOverworldPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldPath >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldUserData*
Arena::CreateMaybeMessage< ::CMsgOverworldUserData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldUserData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldMatchRewards_Player*
Arena::CreateMaybeMessage< ::CMsgOverworldMatchRewards_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldMatchRewards_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldMatchRewards*
Arena::CreateMaybeMessage< ::CMsgOverworldMatchRewards >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldMatchRewards >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGetUserData*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGetUserData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGetUserData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGetUserDataResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGetUserDataResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGetUserDataResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGCToClientOverworldUserDataUpdated*
Arena::CreateMaybeMessage< ::CMsgGCToClientOverworldUserDataUpdated >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGCToClientOverworldUserDataUpdated >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldCompletePath*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldCompletePath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldCompletePath >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldCompletePathResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldCompletePathResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldCompletePathResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgOverworldEncounterPitFighterRewardData*
Arena::CreateMaybeMessage< ::CMsgOverworldEncounterPitFighterRewardData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgOverworldEncounterPitFighterRewardData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldClaimEncounterReward*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldClaimEncounterReward >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldClaimEncounterReward >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldClaimEncounterRewardResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldClaimEncounterRewardResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldClaimEncounterRewardResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldVisitEncounter*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldVisitEncounter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldVisitEncounter >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldVisitEncounterResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldVisitEncounterResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldVisitEncounterResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldMoveToNode*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldMoveToNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldMoveToNode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldMoveToNodeResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldMoveToNodeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldMoveToNodeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldTradeTokens*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldTradeTokens >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldTradeTokens >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldTradeTokensResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldTradeTokensResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldTradeTokensResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGiftTokens*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGiftTokens >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGiftTokens >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGiftTokensResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGiftTokensResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGiftTokensResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevResetAll*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevResetAll >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevResetAll >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevResetAllResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevResetAllResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevResetAllResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevResetNode*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevResetNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevResetNode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevResetNodeResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevResetNodeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevResetNodeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevGrantTokens*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevGrantTokens >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevGrantTokens >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevGrantTokensResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevGrantTokensResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevGrantTokensResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevClearInventory*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevClearInventory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevClearInventory >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldDevClearInventoryResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldDevClearInventoryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldDevClearInventoryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldFeedback*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldFeedback >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldFeedback >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldFeedbackResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldFeedbackResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldFeedbackResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGetDynamicImage*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGetDynamicImage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGetDynamicImage >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGetDynamicImageResponse_Image*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGetDynamicImageResponse_Image >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgClientToGCOverworldGetDynamicImageResponse*
Arena::CreateMaybeMessage< ::CMsgClientToGCOverworldGetDynamicImageResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgClientToGCOverworldGetDynamicImageResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
